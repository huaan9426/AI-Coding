# 第14章：准入控制与策略管理

## 章节概述

在第13章中，我们学习了如何通过CRD和Operator扩展Kubernetes的功能。本章将深入学习Kubernetes的**准入控制（Admission Control）**机制，这是Kubernetes安全和策略管理的核心组件。

**本章核心目标**：
- 深入理解准入控制器的工作原理
- 掌握Validating Webhook和Mutating Webhook的开发
- 学习使用OPA（Open Policy Agent）实施策略管理
- 掌握Kyverno策略引擎的使用
- 实战：构建企业级策略管理系统

**为什么需要准入控制？**

```
Kubernetes API请求流程：
┌────────────────────────────────────────────┐
│  1. 用户/系统发起API请求                    │
│     kubectl apply -f pod.yaml              │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  2. 认证（Authentication）                 │
│     验证用户身份                           │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  3. 授权（Authorization）                  │
│     验证用户权限（RBAC）                   │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  4. 准入控制（Admission Control）⭐        │
│     ├─ Mutating Admission（修改请求）      │
│     └─ Validating Admission（验证请求）    │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  5. 持久化到etcd                           │
│     资源创建成功                           │
└────────────────────────────────────────────┘
```

**准入控制的作用**：

```
准入控制器的典型应用场景：
┌────────────────────────────────────────────┐
│  安全策略                                   │
│  ├─ 禁止特权容器                           │
│  ├─ 强制镜像来源验证                       │
│  ├─ 要求设置资源限制                       │
│  └─ 禁止hostPath挂载                       │
├────────────────────────────────────────────┤
│  资源管理                                   │
│  ├─ 自动注入资源限制                       │
│  ├─ 自动添加标签和注解                     │
│  ├─ 自动设置默认值                         │
│  └─ 配额管理                               │
├────────────────────────────────────────────┤
│  合规性                                     │
│  ├─ 强制命名规范                           │
│  ├─ 要求特定标签                           │
│  ├─ 审计日志                               │
│  └─ 数据保护                               │
├────────────────────────────────────────────┤
│  运维自动化                                 │
│  ├─ 自动注入Sidecar                        │
│  ├─ 自动配置网络策略                       │
│  ├─ 自动添加监控配置                       │
│  └─ 自动设置亲和性                         │
└────────────────────────────────────────────┘
```

**本章学习路径**：

```
14.1 准入控制器原理
  ↓
14.2 Validating Webhook
  ↓
14.3 Mutating Webhook
  ↓
14.4 OPA (Open Policy Agent)
  ↓
14.5 Kyverno策略引擎
  ↓
14.6 实战：实施企业级策略管理
```

---

## 14.1 准入控制器原理

### 14.1.1 准入控制器概述

准入控制器（Admission Controller）是Kubernetes API Server的插件，用于在对象持久化之前拦截API请求。

**准入控制器的类型**：

```
准入控制器分类：
┌────────────────────────────────────────────┐
│  1. 内置准入控制器（Built-in）              │
│     - Kubernetes原生提供                   │
│     - 编译到API Server中                   │
│     - 通过--enable-admission-plugins启用   │
│     - 示例：                               │
│       * NamespaceLifecycle                 │
│       * LimitRanger                        │
│       * ServiceAccount                     │
│       * ResourceQuota                      │
│       * PodSecurityPolicy                  │
├────────────────────────────────────────────┤
│  2. 动态准入控制器（Dynamic）               │
│     - 通过Webhook实现                      │
│     - 可以独立部署和更新                   │
│     - 分为两类：                           │
│       * Mutating Admission Webhook         │
│       * Validating Admission Webhook       │
└────────────────────────────────────────────┘
```

### 14.1.2 准入控制流程

**完整的准入控制流程**：

```
API请求处理流程：
┌──────────────────────────────────────────────┐
│  1. API请求到达                              │
│     POST /api/v1/namespaces/default/pods     │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  2. 认证（Authentication）                   │
│     - 客户端证书                             │
│     - Bearer Token                           │
│     - ServiceAccount                         │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  3. 授权（Authorization）                    │
│     - RBAC检查                               │
│     - 验证用户是否有权限执行操作             │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  4. Mutating Admission（变更准入）           │
│     按顺序执行所有Mutating Webhook：         │
│     ├─ Webhook 1: 添加默认标签              │
│     ├─ Webhook 2: 注入Sidecar容器           │
│     ├─ Webhook 3: 设置资源限制              │
│     └─ Webhook 4: 添加环境变量              │
│     注意：每个Webhook可以修改请求对象        │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  5. Schema验证                               │
│     验证对象是否符合API Schema               │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  6. Validating Admission（验证准入）         │
│     并行执行所有Validating Webhook：         │
│     ├─ Webhook 1: 验证镜像来源              │
│     ├─ Webhook 2: 验证资源配额              │
│     ├─ Webhook 3: 验证安全策略              │
│     └─ Webhook 4: 验证命名规范              │
│     注意：任何一个Webhook拒绝则请求失败      │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  7. 持久化到etcd                             │
│     对象创建成功                             │
└──────────────────────────────────────────────┘
```

**Mutating vs Validating**：

| 特性 | Mutating Admission | Validating Admission |
|------|-------------------|---------------------|
| **执行顺序** | 先执行 | 后执行 |
| **执行方式** | 串行（顺序执行） | 并行（同时执行） |
| **主要作用** | 修改请求对象 | 验证请求对象 |
| **典型用途** | 注入Sidecar、设置默认值 | 策略验证、合规检查 |
| **失败影响** | 继续执行下一个 | 立即拒绝请求 |
| **返回结果** | 修改后的对象 | 允许/拒绝 |

### 14.1.3 内置准入控制器

**常用的内置准入控制器**：

```yaml
# 查看API Server启用的准入控制器
kubectl exec -n kube-system kube-apiserver-master --   kube-apiserver -h | grep enable-admission-plugins
```

**1. NamespaceLifecycle**

防止在不存在或正在删除的Namespace中创建资源。

```bash
# 示例：尝试在不存在的Namespace创建Pod
kubectl run nginx --image=nginx -n non-existent-ns
# Error: namespaces "non-existent-ns" not found
```

**2. LimitRanger**

为Pod和容器设置默认的资源请求和限制。

```yaml
# LimitRange示例
apiVersion: v1
kind: LimitRange
metadata:
  name: mem-limit-range
  namespace: default
spec:
  limits:
  - default:  # 默认限制
      memory: 512Mi
      cpu: 500m
    defaultRequest:  # 默认请求
      memory: 256Mi
      cpu: 250m
    type: Container
```

**3. ServiceAccount**

自动为Pod注入ServiceAccount。

```yaml
# Pod会自动注入default ServiceAccount
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: nginx
    image: nginx
  # 自动添加：
  # serviceAccountName: default
  # volumes:
  # - name: kube-api-access-xxxxx
  #   projected:
  #     sources:
  #     - serviceAccountToken: ...
```

**4. ResourceQuota**

强制执行Namespace的资源配额。

```yaml
# ResourceQuota示例
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: default
spec:
  hard:
    requests.cpu: "10"
    requests.memory: 20Gi
    limits.cpu: "20"
    limits.memory: 40Gi
    pods: "50"
```

```bash
# 超过配额时创建Pod会失败
kubectl run nginx --image=nginx --requests=cpu=15
# Error: exceeded quota: compute-quota
```

**5. PodSecurityPolicy（已弃用，使用Pod Security Admission替代）**

控制Pod的安全相关配置。

```yaml
# Pod Security Admission（PSA）
apiVersion: v1
kind: Namespace
metadata:
  name: my-namespace
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
```

**6. NodeRestriction**

限制kubelet只能修改自己节点上的资源。

```bash
# kubelet只能修改自己节点的Node对象和Pod
# 防止恶意kubelet修改其他节点的资源
```

**7. AlwaysPullImages**

强制每次都拉取镜像，防止使用本地缓存的镜像。

```yaml
# 启用后，所有Pod的imagePullPolicy都会被设置为Always
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: nginx
    image: nginx
    # 自动设置：imagePullPolicy: Always
```

### 14.1.4 配置准入控制器

**查看当前启用的准入控制器**：

```bash
# 方法1：查看API Server配置
kubectl get pod -n kube-system kube-apiserver-master -o yaml | grep admission

# 方法2：查看API Server进程参数
ps aux | grep kube-apiserver | grep admission-plugins

# 方法3：查看API Server manifest
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep admission
```

**启用/禁用准入控制器**：

```yaml
# /etc/kubernetes/manifests/kube-apiserver.yaml
apiVersion: v1
kind: Pod
metadata:
  name: kube-apiserver
  namespace: kube-system
spec:
  containers:
  - command:
    - kube-apiserver
    # 启用准入控制器
    - --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodSecurity
    # 禁用准入控制器
    - --disable-admission-plugins=AlwaysPullImages
    # ... 其他参数
```

**推荐的准入控制器配置**：

```bash
# 生产环境推荐配置
--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodSecurity,NodeRestriction,Priority,StorageObjectInUseProtection,PersistentVolumeClaimResize
```

### 14.1.5 准入控制器最佳实践

**1. 安全相关**

```yaml
# ✅ 推荐启用的安全准入控制器
- PodSecurity              # Pod安全标准
- NodeRestriction          # 限制kubelet权限
- ServiceAccount           # 自动注入ServiceAccount
- AlwaysPullImages         # 强制拉取镜像（可选）

# ✅ 使用Webhook实施自定义安全策略
- 验证镜像签名
- 禁止特权容器
- 强制使用非root用户
- 限制hostPath使用
```

**2. 资源管理**

```yaml
# ✅ 推荐启用的资源管理准入控制器
- LimitRanger              # 设置默认资源限制
- ResourceQuota            # 强制资源配额
- PersistentVolumeClaimResize  # 允许PVC扩容

# ✅ 使用Webhook实施自定义资源策略
- 自动设置资源请求和限制
- 验证资源配置合理性
- 防止资源过度分配
```

**3. 运维自动化**

```yaml
# ✅ 使用Mutating Webhook自动化运维任务
- 自动注入Sidecar容器（如Istio、Linkerd）
- 自动添加标签和注解
- 自动配置环境变量
- 自动设置亲和性和容忍度
```

**4. 合规性**

```yaml
# ✅ 使用Validating Webhook实施合规策略
- 强制命名规范
- 要求特定标签
- 验证镜像来源
- 审计日志记录
```

### 14.1.6 准入控制器调试

**1. 查看准入控制器日志**

```bash
# 查看API Server日志
kubectl logs -n kube-system kube-apiserver-master | grep admission

# 查看Webhook日志
kubectl logs -n webhook-system webhook-server-xxx
```

**2. 测试准入控制器**

```bash
# 使用--dry-run测试
kubectl apply -f pod.yaml --dry-run=server

# 查看详细错误信息
kubectl apply -f pod.yaml -v=8
```

**3. 调试Webhook**

```yaml
# 在Webhook配置中启用详细日志
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: my-webhook
webhooks:
- name: my-webhook.example.com
  # 失败策略：Ignore表示Webhook失败时允许请求通过
  failurePolicy: Ignore  # 调试时使用，生产环境使用Fail
  # 超时时间
  timeoutSeconds: 10
  # ... 其他配置
```

**4. 常见问题排查**

```bash
# 问题1：Webhook超时
# 检查Webhook服务是否正常
kubectl get svc -n webhook-system
kubectl get endpoints -n webhook-system

# 问题2：证书错误
# 检查Webhook证书
kubectl get validatingwebhookconfiguration my-webhook -o yaml | grep caBundle

# 问题3：请求被拒绝
# 查看拒绝原因
kubectl describe pod my-pod | grep -A 10 Events
```

### 14.1.7 准入控制器性能考虑

**性能影响因素**：

```
准入控制器性能影响：
┌────────────────────────────────────────────┐
│  1. Webhook数量                            │
│     - 每个Webhook增加延迟                  │
│     - 建议：合并相关Webhook                │
├────────────────────────────────────────────┤
│  2. Webhook响应时间                        │
│     - 网络延迟                             │
│     - 处理时间                             │
│     - 建议：优化Webhook逻辑，设置超时      │
├────────────────────────────────────────────┤
│  3. 失败策略                               │
│     - Fail：Webhook失败则请求失败          │
│     - Ignore：Webhook失败则请求通过        │
│     - 建议：生产环境使用Fail               │
├────────────────────────────────────────────┤
│  4. 对象大小                               │
│     - 大对象增加序列化/反序列化时间        │
│     - 建议：避免在Webhook中处理大对象      │
└────────────────────────────────────────────┘
```

**性能优化建议**：

```yaml
# 1. 设置合理的超时时间
timeoutSeconds: 5  # 默认10秒，可以根据实际情况调整

# 2. 使用objectSelector减少Webhook调用
objectSelector:
  matchLabels:
    webhook: enabled

# 3. 使用namespaceSelector限制作用范围
namespaceSelector:
  matchExpressions:
  - key: environment
    operator: In
    values: ["production"]

# 4. 配置合理的失败策略
failurePolicy: Fail  # 生产环境
# failurePolicy: Ignore  # 开发环境

# 5. 使用sideEffects声明副作用
sideEffects: None  # 表示Webhook没有副作用，可以安全地并行调用
```

---

## 14.2 Validating Webhook

### 14.2.1 Validating Webhook概述

**什么是Validating Webhook？**

Validating Webhook是一种动态准入控制器，允许你在对象持久化到etcd之前验证请求。与内置准入控制器不同，Validating Webhook可以独立部署和更新，无需重启API Server。

**工作流程**：

```
Validating Webhook执行流程：
┌────────────────────────────────────────────┐
│  1. API Server接收创建/更新请求            │
│     kubectl apply -f pod.yaml              │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  2. 通过认证和授权                         │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  3. 执行Mutating Admission                 │
│     （可能修改对象）                       │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  4. Schema验证                             │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  5. API Server调用Validating Webhook       │
│     POST https://webhook-svc/validate      │
│     {                                      │
│       "request": {                         │
│         "object": {...},                   │
│         "oldObject": {...},                │
│         "operation": "CREATE"              │
│       }                                    │
│     }                                      │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  6. Webhook验证对象                        │
│     - 检查镜像来源                         │
│     - 验证资源配额                         │
│     - 检查安全策略                         │
│     - 验证命名规范                         │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  7. Webhook返回响应                        │
│     {                                      │
│       "response": {                        │
│         "allowed": true/false,             │
│         "status": {                        │
│           "message": "拒绝原因"            │
│         }                                  │
│       }                                    │
│     }                                      │
└────────────────────────────────────────────┘
                ↓
     ┌──────────┴──────────┐
     ↓                     ↓
┌─────────┐         ┌─────────┐
│ allowed │         │ denied  │
│ = true  │         │ = false │
└─────────┘         └─────────┘
     ↓                     ↓
  持久化              请求失败
  到etcd              返回错误
```

**Validating Webhook的特点**：

| 特性 | 说明 |
|------|------|
| **执行时机** | Mutating Admission之后、对象持久化之前 |
| **执行方式** | 并行执行所有Webhook |
| **修改能力** | 不能修改对象，只能允许或拒绝 |
| **失败处理** | 任何一个Webhook拒绝，整个请求失败 |
| **典型用途** | 策略验证、合规检查、安全审计 |

**使用场景**：

```
Validating Webhook典型应用场景：
┌────────────────────────────────────────────┐
│  安全策略验证                               │
│  ├─ 验证镜像来自可信仓库                   │
│  ├─ 禁止特权容器                           │
│  ├─ 要求非root用户运行                     │
│  ├─ 禁止hostPath挂载                       │
│  └─ 验证镜像签名                           │
├────────────────────────────────────────────┤
│  资源合规性                                 │
│  ├─ 强制设置资源limits                     │
│  ├─ 验证资源配额合理性                     │
│  ├─ 检查CPU/内存比例                       │
│  └─ 防止资源过度分配                       │
├────────────────────────────────────────────┤
│  命名和标签规范                             │
│  ├─ 强制命名格式                           │
│  ├─ 要求特定标签                           │
│  ├─ 验证标签值                             │
│  └─ 检查注解完整性                         │
├────────────────────────────────────────────┤
│  网络策略                                   │
│  ├─ 验证Ingress配置                        │
│  ├─ 检查Service端口                        │
│  ├─ 验证NetworkPolicy                      │
│  └─ 限制外部访问                           │
└────────────────────────────────────────────┘
```

### 14.2.2 ValidatingWebhookConfiguration资源

**资源定义**：

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: pod-policy-webhook
webhooks:
- name: pod-policy.example.com
  # Webhook调用地址
  clientConfig:
    # 方式1：使用Service（推荐）
    service:
      namespace: webhook-system
      name: webhook-server
      path: /validate-pod
      port: 443
    # CA证书（Base64编码）
    caBundle: LS0tLS1CRUdJTi...

    # 方式2：使用外部URL
    # url: https://external-webhook.example.com/validate

  # 匹配规则
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
    scope: "Namespaced"  # 或 "Cluster"、"*"

  # Namespace选择器（可选）
  namespaceSelector:
    matchLabels:
      environment: production
    # 或使用matchExpressions
    # matchExpressions:
    # - key: environment
    #   operator: In
    #   values: ["production", "staging"]

  # 对象选择器（可选）
  objectSelector:
    matchLabels:
      validate: "true"

  # 失败策略
  failurePolicy: Fail  # Fail: Webhook失败则拒绝请求
                       # Ignore: Webhook失败则允许请求

  # 匹配策略
  matchPolicy: Equivalent  # Equivalent: 等价匹配
                          # Exact: 精确匹配

  # 副作用声明
  sideEffects: None  # None: 无副作用
                     # NoneOnDryRun: dry-run时无副作用

  # 超时时间（秒）
  timeoutSeconds: 10  # 默认10秒，范围1-30

  # 准入审查版本
  admissionReviewVersions: ["v1", "v1beta1"]
```

**配置参数详解**：

**1. rules（匹配规则）**

```yaml
rules:
# 示例1：只匹配Pod的CREATE操作
- operations: ["CREATE"]
  apiGroups: [""]
  apiVersions: ["v1"]
  resources: ["pods"]

# 示例2：匹配所有Deployment操作
- operations: ["CREATE", "UPDATE", "DELETE"]
  apiGroups: ["apps"]
  apiVersions: ["v1"]
  resources: ["deployments"]

# 示例3：匹配所有资源
- operations: ["*"]
  apiGroups: ["*"]
  apiVersions: ["*"]
  resources: ["*"]

# 示例4：匹配子资源
- operations: ["CREATE"]
  apiGroups: [""]
  apiVersions: ["v1"]
  resources: ["pods/exec", "pods/portforward"]
```

**2. namespaceSelector（命名空间选择器）**

```yaml
# 示例1：匹配特定标签的Namespace
namespaceSelector:
  matchLabels:
    environment: production

# 示例2：排除特定Namespace
namespaceSelector:
  matchExpressions:
  - key: exclude-webhook
    operator: DoesNotExist

# 示例3：匹配多个环境
namespaceSelector:
  matchExpressions:
  - key: environment
    operator: In
    values: ["production", "staging"]
```

**3. objectSelector（对象选择器）**

```yaml
# 示例1：只验证带特定标签的Pod
objectSelector:
  matchLabels:
    validate: "true"

# 示例2：排除系统Pod
objectSelector:
  matchExpressions:
  - key: app
    operator: NotIn
    values: ["kube-proxy", "kube-dns"]
```

**4. failurePolicy（失败策略）**

```yaml
# Fail：Webhook失败则拒绝请求（生产环境推荐）
failurePolicy: Fail

# Ignore：Webhook失败则允许请求（开发环境可用）
failurePolicy: Ignore
```

**完整示例：Pod安全策略验证Webhook**

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: pod-security-policy
webhooks:
- name: pod-security.example.com
  clientConfig:
    service:
      namespace: webhook-system
      name: webhook-server
      path: /validate-pod-security
      port: 443
    caBundle: ${CA_BUNDLE}

  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]

  # 只在生产环境启用
  namespaceSelector:
    matchLabels:
      environment: production

  # 排除系统Pod
  objectSelector:
    matchExpressions:
    - key: app
      operator: NotIn
      values: ["kube-system", "kube-public"]

  failurePolicy: Fail
  sideEffects: None
  timeoutSeconds: 5
  admissionReviewVersions: ["v1"]
```

### 14.2.3 Webhook服务端实现

**Go语言实现Validating Webhook**

**项目结构**：

```
webhook-server/
├── main.go              # 主程序
├── pkg/
│   ├── webhook/
│   │   ├── server.go    # HTTP服务器
│   │   └── validator.go # 验证逻辑
│   └── admission/
│       └── types.go     # 请求/响应类型
├── deploy/
│   ├── deployment.yaml
│   ├── service.yaml
│   └── webhook-config.yaml
└── Dockerfile
```

**1. 定义请求/响应类型**

```go
// pkg/admission/types.go
package admission

import (
    admissionv1 "k8s.io/api/admission/v1"
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// AdmissionReview请求结构
type AdmissionReview struct {
    Request  *admissionv1.AdmissionRequest  `json:"request"`
    Response *admissionv1.AdmissionResponse `json:"response"`
}

// 构建允许响应
func Allowed(message string) *admissionv1.AdmissionResponse {
    return &admissionv1.AdmissionResponse{
        Allowed: true,
        Result: &metav1.Status{
            Message: message,
        },
    }
}

// 构建拒绝响应
func Denied(message string) *admissionv1.AdmissionResponse {
    return &admissionv1.AdmissionResponse{
        Allowed: false,
        Result: &metav1.Status{
            Message: message,
            Code:    403,
        },
    }
}
```

**2. 实现验证逻辑**

```go
// pkg/webhook/validator.go
package webhook

import (
    "encoding/json"
    "fmt"
    "strings"

    admissionv1 "k8s.io/api/admission/v1"
    corev1 "k8s.io/api/core/v1"
    "webhook-server/pkg/admission"
)

// PodValidator Pod验证器
type PodValidator struct {
    AllowedRegistries []string
}

// ValidatePod 验证Pod
func (v *PodValidator) ValidatePod(ar *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {
    // 1. 解析Pod对象
    pod := &corev1.Pod{}
    if err := json.Unmarshal(ar.Object.Raw, pod); err != nil {
        return admission.Denied(fmt.Sprintf("无法解析Pod: %v", err))
    }

    // 2. 验证镜像来源
    if err := v.validateImageRegistry(pod); err != nil {
        return admission.Denied(err.Error())
    }

    // 3. 验证资源限制
    if err := v.validateResourceLimits(pod); err != nil {
        return admission.Denied(err.Error())
    }

    // 4. 验证安全上下文
    if err := v.validateSecurityContext(pod); err != nil {
        return admission.Denied(err.Error())
    }

    // 5. 验证命名规范
    if err := v.validateNaming(pod); err != nil {
        return admission.Denied(err.Error())
    }

    return admission.Allowed("Pod验证通过")
}

// 验证镜像来源
func (v *PodValidator) validateImageRegistry(pod *corev1.Pod) error {
    for _, container := range pod.Spec.Containers {
        if !v.isAllowedRegistry(container.Image) {
            return fmt.Errorf(
                "镜像 %s 来自未授权的仓库。允许的仓库：%v",
                container.Image,
                v.AllowedRegistries,
            )
        }
    }
    return nil
}

// 检查镜像是否来自允许的仓库
func (v *PodValidator) isAllowedRegistry(image string) bool {
    for _, registry := range v.AllowedRegistries {
        if strings.HasPrefix(image, registry) {
            return true
        }
    }
    return false
}

// 验证资源限制
func (v *PodValidator) validateResourceLimits(pod *corev1.Pod) error {
    for _, container := range pod.Spec.Containers {
        // 检查是否设置了资源限制
        if container.Resources.Limits == nil {
            return fmt.Errorf(
                "容器 %s 未设置资源限制（limits）",
                container.Name,
            )
        }

        // 检查CPU和内存限制
        cpuLimit := container.Resources.Limits.Cpu()
        memLimit := container.Resources.Limits.Memory()

        if cpuLimit.IsZero() {
            return fmt.Errorf(
                "容器 %s 未设置CPU限制",
                container.Name,
            )
        }

        if memLimit.IsZero() {
            return fmt.Errorf(
                "容器 %s 未设置内存限制",
                container.Name,
            )
        }
    }
    return nil
}

// 验证安全上下文
func (v *PodValidator) validateSecurityContext(pod *corev1.Pod) error {
    for _, container := range pod.Spec.Containers {
        sc := container.SecurityContext

        // 禁止特权容器
        if sc != nil && sc.Privileged != nil && *sc.Privileged {
            return fmt.Errorf(
                "容器 %s 不允许使用特权模式",
                container.Name,
            )
        }

        // 要求非root用户
        if sc != nil && sc.RunAsNonRoot != nil && !*sc.RunAsNonRoot {
            return fmt.Errorf(
                "容器 %s 必须以非root用户运行",
                container.Name,
            )
        }

        // 禁止hostPath
        for _, volume := range pod.Spec.Volumes {
            if volume.HostPath != nil {
                return fmt.Errorf(
                    "不允许使用hostPath卷：%s",
                    volume.Name,
                )
            }
        }
    }
    return nil
}

// 验证命名规范
func (v *PodValidator) validateNaming(pod *corev1.Pod) error {
    // 检查是否有必需的标签
    requiredLabels := []string{"app", "environment"}
    for _, label := range requiredLabels {
        if _, exists := pod.Labels[label]; !exists {
            return fmt.Errorf(
                "Pod缺少必需的标签：%s",
                label,
            )
        }
    }

    // 检查命名格式
    if !strings.Contains(pod.Name, "-") {
        return fmt.Errorf(
            "Pod名称必须包含连字符，格式：<app>-<version>",
        )
    }

    return nil
}
```

**3. 实现HTTP服务器**

```go
// pkg/webhook/server.go
package webhook

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"

    admissionv1 "k8s.io/api/admission/v1"
)

// WebhookServer Webhook服务器
type WebhookServer struct {
    Validator *PodValidator
}

// ServePodValidation 处理Pod验证请求
func (s *WebhookServer) ServePodValidation(w http.ResponseWriter, r *http.Request) {
    log.Println("收到验证请求")

    // 1. 读取请求体
    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
        log.Printf("读取请求失败: %v", err)
        http.Error(w, "无法读取请求", http.StatusBadRequest)
        return
    }
    defer r.Body.Close()

    // 2. 解析AdmissionReview
    ar := &admissionv1.AdmissionReview{}
    if err := json.Unmarshal(body, ar); err != nil {
        log.Printf("解析AdmissionReview失败: %v", err)
        http.Error(w, "无效的AdmissionReview", http.StatusBadRequest)
        return
    }

    // 3. 验证请求
    if ar.Request == nil {
        log.Println("AdmissionReview.Request为空")
        http.Error(w, "无效的请求", http.StatusBadRequest)
        return
    }

    // 4. 执行验证逻辑
    response := s.Validator.ValidatePod(ar.Request)

    // 5. 构建响应
    ar.Response = response
    ar.Response.UID = ar.Request.UID

    // 6. 返回响应
    respBytes, err := json.Marshal(ar)
    if err != nil {
        log.Printf("序列化响应失败: %v", err)
        http.Error(w, "无法序列化响应", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    w.Write(respBytes)

    log.Printf("验证结果: allowed=%v, message=%s",
        response.Allowed, response.Result.Message)
}

// HealthCheck 健康检查
func (s *WebhookServer) HealthCheck(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, "OK")
}
```

**4. 主程序**

```go
// main.go
package main

import (
    "log"
    "net/http"

    "webhook-server/pkg/webhook"
)

func main() {
    // 创建验证器
    validator := &webhook.PodValidator{
        AllowedRegistries: []string{
            "docker.io/",
            "gcr.io/",
            "registry.example.com/",
        },
    }

    // 创建Webhook服务器
    server := &webhook.WebhookServer{
        Validator: validator,
    }

    // 注册路由
    http.HandleFunc("/validate-pod", server.ServePodValidation)
    http.HandleFunc("/healthz", server.HealthCheck)

    // 启动HTTPS服务器
    log.Println("启动Webhook服务器，监听端口 8443...")
    err := http.ListenAndServeTLS(
        ":8443",
        "/etc/webhook/certs/tls.crt",  // TLS证书
        "/etc/webhook/certs/tls.key",  // TLS私钥
        nil,
    )
    if err != nil {
        log.Fatalf("启动服务器失败: %v", err)
    }
}
```

**5. Dockerfile**

```dockerfile
# Dockerfile
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o webhook-server .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/webhook-server .
EXPOSE 8443
CMD ["./webhook-server"]
```

### 14.2.4 TLS证书配置

**方式1：使用脚本生成自签名证书**

```bash
#!/bin/bash
# generate-cert.sh

set -e

# 配置
SERVICE_NAME="webhook-server"
NAMESPACE="webhook-system"
SECRET_NAME="webhook-server-tls"

# 创建临时目录
TMP_DIR=$(mktemp -d)
cd $TMP_DIR

# 1. 生成CA私钥
openssl genrsa -out ca.key 2048

# 2. 生成CA证书
openssl req -x509 -new -nodes -key ca.key -days 3650 \
    -out ca.crt -subj "/CN=webhook-ca"

# 3. 生成服务器私钥
openssl genrsa -out tls.key 2048

# 4. 创建证书签名请求配置
cat > csr.conf <<EOF
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = ${SERVICE_NAME}
DNS.2 = ${SERVICE_NAME}.${NAMESPACE}
DNS.3 = ${SERVICE_NAME}.${NAMESPACE}.svc
DNS.4 = ${SERVICE_NAME}.${NAMESPACE}.svc.cluster.local
EOF

# 5. 生成证书签名请求
openssl req -new -key tls.key -out tls.csr \
    -subj "/CN=${SERVICE_NAME}.${NAMESPACE}.svc" \
    -config csr.conf

# 6. 签发服务器证书
openssl x509 -req -in tls.csr -CA ca.crt -CAkey ca.key \
    -CAcreateserial -out tls.crt -days 3650 \
    -extensions v3_req -extfile csr.conf

# 7. 创建Secret
kubectl create secret tls ${SECRET_NAME} \
    --cert=tls.crt \
    --key=tls.key \
    -n ${NAMESPACE} \
    --dry-run=client -o yaml > webhook-tls-secret.yaml

# 8. 获取CA证书的Base64编码（用于ValidatingWebhookConfiguration）
CA_BUNDLE=$(cat ca.crt | base64 | tr -d '\n')
echo "CA_BUNDLE: ${CA_BUNDLE}"

# 9. 清理
cd -
rm -rf $TMP_DIR

echo "证书生成完成！"
echo "Secret YAML: webhook-tls-secret.yaml"
echo "请在ValidatingWebhookConfiguration中设置 caBundle: ${CA_BUNDLE}"
```

**执行脚本**：

```bash
chmod +x generate-cert.sh
./generate-cert.sh

# 应用Secret
kubectl apply -f webhook-tls-secret.yaml
```

**方式2：使用cert-manager自动化证书管理（推荐）**

```bash
# 1. 安装cert-manager
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml

# 2. 等待cert-manager就绪
kubectl wait --for=condition=ready pod -l app=cert-manager -n cert-manager --timeout=300s
```

**创建自签名Issuer**：

```yaml
# cert-issuer.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: webhook-system
---
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: selfsigned-issuer
  namespace: webhook-system
spec:
  selfSigned: {}
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: webhook-server-cert
  namespace: webhook-system
spec:
  secretName: webhook-server-tls
  duration: 8760h  # 1年
  renewBefore: 720h  # 30天前续期
  subject:
    organizations:
    - example-org
  commonName: webhook-server.webhook-system.svc
  dnsNames:
  - webhook-server
  - webhook-server.webhook-system
  - webhook-server.webhook-system.svc
  - webhook-server.webhook-system.svc.cluster.local
  issuerRef:
    name: selfsigned-issuer
    kind: Issuer
```

**应用配置**：

```bash
kubectl apply -f cert-issuer.yaml

# 检查证书状态
kubectl get certificate -n webhook-system
kubectl describe certificate webhook-server-cert -n webhook-system

# 检查生成的Secret
kubectl get secret webhook-server-tls -n webhook-system
```

**使用cert-manager注入caBundle（推荐）**：

```yaml
# webhook-config.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: pod-policy-webhook
  annotations:
    # cert-manager会自动注入caBundle
    cert-manager.io/inject-ca-from: webhook-system/webhook-server-cert
webhooks:
- name: pod-policy.example.com
  clientConfig:
    service:
      namespace: webhook-system
      name: webhook-server
      path: /validate-pod
      port: 443
    # caBundle会被cert-manager自动注入
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
  failurePolicy: Fail
  sideEffects: None
  admissionReviewVersions: ["v1"]
```

### 14.2.5 部署Webhook服务

**1. 部署Webhook Server**

```yaml
# deploy/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webhook-server
  namespace: webhook-system
  labels:
    app: webhook-server
spec:
  replicas: 2
  selector:
    matchLabels:
      app: webhook-server
  template:
    metadata:
      labels:
        app: webhook-server
    spec:
      containers:
      - name: webhook
        image: registry.example.com/webhook-server:v1.0.0
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8443
          name: webhook
          protocol: TCP
        volumeMounts:
        - name: webhook-certs
          mountPath: /etc/webhook/certs
          readOnly: true
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8443
            scheme: HTTPS
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /healthz
            port: 8443
            scheme: HTTPS
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: webhook-certs
        secret:
          secretName: webhook-server-tls
---
apiVersion: v1
kind: Service
metadata:
  name: webhook-server
  namespace: webhook-system
  labels:
    app: webhook-server
spec:
  selector:
    app: webhook-server
  ports:
  - port: 443
    targetPort: 8443
    protocol: TCP
    name: webhook
  type: ClusterIP
```

**2. 应用部署**：

```bash
# 创建Namespace
kubectl create namespace webhook-system

# 部署Webhook服务
kubectl apply -f deploy/deployment.yaml

# 检查部署状态
kubectl get pods -n webhook-system
kubectl get svc -n webhook-system

# 检查日志
kubectl logs -n webhook-system -l app=webhook-server -f
```

**3. 创建ValidatingWebhookConfiguration**：

```yaml
# deploy/webhook-config.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: pod-policy-webhook
  annotations:
    cert-manager.io/inject-ca-from: webhook-system/webhook-server-cert
webhooks:
- name: pod-policy.example.com
  clientConfig:
    service:
      namespace: webhook-system
      name: webhook-server
      path: /validate-pod
      port: 443
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
  # 只在生产环境启用
  namespaceSelector:
    matchLabels:
      environment: production
  failurePolicy: Fail
  sideEffects: None
  timeoutSeconds: 10
  admissionReviewVersions: ["v1"]
```

**应用配置**：

```bash
kubectl apply -f deploy/webhook-config.yaml

# 检查配置
kubectl get validatingwebhookconfiguration pod-policy-webhook
kubectl describe validatingwebhookconfiguration pod-policy-webhook
```

### 14.2.6 测试Validating Webhook

**1. 准备测试Namespace**

```bash
# 创建生产环境Namespace
kubectl create namespace production
kubectl label namespace production environment=production

# 创建开发环境Namespace（不会被Webhook拦截）
kubectl create namespace development
kubectl label namespace development environment=development
```

**2. 测试用例1：验证通过的Pod**

```yaml
# test-pod-valid.yaml
apiVersion: v1
kind: Pod
metadata:
  name: valid-pod
  namespace: production
  labels:
    app: nginx
    environment: production
spec:
  containers:
  - name: nginx
    image: docker.io/nginx:1.21
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 200m
        memory: 256Mi
    securityContext:
      runAsNonRoot: true
      runAsUser: 1000
```

```bash
# 应该成功创建
kubectl apply -f test-pod-valid.yaml

# 检查Pod状态
kubectl get pod valid-pod -n production
```

**3. 测试用例2：镜像来源验证失败**

```yaml
# test-pod-invalid-registry.yaml
apiVersion: v1
kind: Pod
metadata:
  name: invalid-registry-pod
  namespace: production
  labels:
    app: nginx
    environment: production
spec:
  containers:
  - name: nginx
    image: untrusted-registry.com/nginx:latest
    resources:
      limits:
        cpu: 200m
        memory: 256Mi
    securityContext:
      runAsNonRoot: true
```

```bash
# 应该被拒绝
kubectl apply -f test-pod-invalid-registry.yaml
# Error from server: admission webhook "pod-policy.example.com" denied the request:
# 镜像 untrusted-registry.com/nginx:latest 来自未授权的仓库
```

**4. 测试用例3：缺少资源限制**

```yaml
# test-pod-no-limits.yaml
apiVersion: v1
kind: Pod
metadata:
  name: no-limits-pod
  namespace: production
  labels:
    app: nginx
    environment: production
spec:
  containers:
  - name: nginx
    image: docker.io/nginx:1.21
    # 缺少resources.limits
```

```bash
# 应该被拒绝
kubectl apply -f test-pod-no-limits.yaml
# Error from server: admission webhook "pod-policy.example.com" denied the request:
# 容器 nginx 未设置资源限制（limits）
```

**5. 测试用例4：特权容器**

```yaml
# test-pod-privileged.yaml
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
  namespace: production
  labels:
    app: nginx
    environment: production
spec:
  containers:
  - name: nginx
    image: docker.io/nginx:1.21
    resources:
      limits:
        cpu: 200m
        memory: 256Mi
    securityContext:
      privileged: true  # 不允许
```

```bash
# 应该被拒绝
kubectl apply -f test-pod-privileged.yaml
# Error from server: admission webhook "pod-policy.example.com" denied the request:
# 容器 nginx 不允许使用特权模式
```

**6. 测试用例5：缺少必需标签**

```yaml
# test-pod-missing-labels.yaml
apiVersion: v1
kind: Pod
metadata:
  name: missing-labels-pod
  namespace: production
  # 缺少必需的标签: app, environment
spec:
  containers:
  - name: nginx
    image: docker.io/nginx:1.21
    resources:
      limits:
        cpu: 200m
        memory: 256Mi
```

```bash
# 应该被拒绝
kubectl apply -f test-pod-missing-labels.yaml
# Error from server: admission webhook "pod-policy.example.com" denied the request:
# Pod缺少必需的标签：app
```

**7. 在开发环境测试（不受Webhook限制）**

```yaml
# test-pod-dev.yaml
apiVersion: v1
kind: Pod
metadata:
  name: dev-pod
  namespace: development  # 开发环境，不会被Webhook拦截
spec:
  containers:
  - name: nginx
    image: untrusted-registry.com/nginx:latest
    # 可以不设置资源限制
```

```bash
# 应该成功创建（因为namespaceSelector不匹配）
kubectl apply -f test-pod-dev.yaml
kubectl get pod dev-pod -n development
```

### 14.2.7 实战案例：多策略验证Webhook

**场景**：实现一个综合性的Webhook，支持多种策略验证。

**增强的验证器实现**：

```go
// pkg/webhook/advanced_validator.go
package webhook

import (
    "fmt"
    "regexp"
    "strings"

    corev1 "k8s.io/api/core/v1"
    "k8s.io/apimachinery/pkg/api/resource"
)

// AdvancedPodValidator 高级Pod验证器
type AdvancedPodValidator struct {
    // 镜像策略
    AllowedRegistries []string
    RequireImageScan  bool

    // 资源策略
    RequireResourceLimits bool
    MaxCPU                resource.Quantity
    MaxMemory             resource.Quantity
    CPUMemoryRatio        float64  // CPU:内存比例（如1:4表示1核配4Gi）

    // 安全策略
    DenyPrivileged      bool
    RequireNonRoot      bool
    DenyHostPath        bool
    DenyHostNetwork     bool
    AllowedCapabilities []string

    // 命名策略
    RequiredLabels      []string
    RequiredAnnotations []string
    NamePattern         *regexp.Regexp
}

// Validate 执行全面验证
func (v *AdvancedPodValidator) Validate(pod *corev1.Pod) error {
    // 1. 镜像策略验证
    if err := v.validateImagePolicy(pod); err != nil {
        return err
    }

    // 2. 资源策略验证
    if err := v.validateResourcePolicy(pod); err != nil {
        return err
    }

    // 3. 安全策略验证
    if err := v.validateSecurityPolicy(pod); err != nil {
        return err
    }

    // 4. 命名策略验证
    if err := v.validateNamingPolicy(pod); err != nil {
        return err
    }

    return nil
}

// 验证镜像策略
func (v *AdvancedPodValidator) validateImagePolicy(pod *corev1.Pod) error {
    for _, container := range append(pod.Spec.Containers, pod.Spec.InitContainers...) {
        // 检查镜像仓库
        if !v.isAllowedRegistry(container.Image) {
            return fmt.Errorf(
                "镜像 %s 来自未授权的仓库。允许的仓库：%v",
                container.Image,
                v.AllowedRegistries,
            )
        }

        // 检查镜像标签
        if strings.HasSuffix(container.Image, ":latest") {
            return fmt.Errorf(
                "不允许使用 :latest 标签，请使用具体版本：%s",
                container.Image,
            )
        }

        // 要求镜像扫描（通过注解）
        if v.RequireImageScan {
            if _, ok := pod.Annotations["image-scan-status"]; !ok {
                return fmt.Errorf(
                    "缺少镜像扫描状态注解：image-scan-status",
                )
            }
        }
    }
    return nil
}

// 验证资源策略
func (v *AdvancedPodValidator) validateResourcePolicy(pod *corev1.Pod) error {
    for _, container := range pod.Spec.Containers {
        limits := container.Resources.Limits
        requests := container.Resources.Requests

        // 要求设置资源限制
        if v.RequireResourceLimits {
            if limits.Cpu().IsZero() || limits.Memory().IsZero() {
                return fmt.Errorf(
                    "容器 %s 必须设置CPU和内存限制",
                    container.Name,
                )
            }

            if requests.Cpu().IsZero() || requests.Memory().IsZero() {
                return fmt.Errorf(
                    "容器 %s 必须设置CPU和内存请求",
                    container.Name,
                )
            }
        }

        // 检查资源上限
        if !v.MaxCPU.IsZero() && limits.Cpu().Cmp(v.MaxCPU) > 0 {
            return fmt.Errorf(
                "容器 %s 的CPU限制 %s 超过最大值 %s",
                container.Name,
                limits.Cpu().String(),
                v.MaxCPU.String(),
            )
        }

        if !v.MaxMemory.IsZero() && limits.Memory().Cmp(v.MaxMemory) > 0 {
            return fmt.Errorf(
                "容器 %s 的内存限制 %s 超过最大值 %s",
                container.Name,
                limits.Memory().String(),
                v.MaxMemory.String(),
            )
        }

        // 检查CPU:内存比例
        if v.CPUMemoryRatio > 0 {
            cpuCores := float64(limits.Cpu().MilliValue()) / 1000.0
            memoryGi := float64(limits.Memory().Value()) / (1024 * 1024 * 1024)

            expectedMemory := cpuCores * v.CPUMemoryRatio
            if memoryGi < expectedMemory*0.8 || memoryGi > expectedMemory*1.2 {
                return fmt.Errorf(
                    "容器 %s 的CPU:内存比例不符合要求。CPU: %.2f核, 内存: %.2fGi, 期望比例: 1:%.0f",
                    container.Name,
                    cpuCores,
                    memoryGi,
                    v.CPUMemoryRatio,
                )
            }
        }
    }
    return nil
}

// 验证安全策略
func (v *AdvancedPodValidator) validateSecurityPolicy(pod *corev1.Pod) error {
    // 检查Pod级别安全上下文
    if v.DenyHostNetwork && pod.Spec.HostNetwork {
        return fmt.Errorf("不允许使用宿主机网络（hostNetwork: true）")
    }

    if v.DenyHostPath {
        for _, volume := range pod.Spec.Volumes {
            if volume.HostPath != nil {
                return fmt.Errorf("不允许使用hostPath卷：%s", volume.Name)
            }
        }
    }

    // 检查容器安全上下文
    for _, container := range append(pod.Spec.Containers, pod.Spec.InitContainers...) {
        sc := container.SecurityContext
        if sc == nil {
            if v.RequireNonRoot || v.DenyPrivileged {
                return fmt.Errorf(
                    "容器 %s 必须设置securityContext",
                    container.Name,
                )
            }
            continue
        }

        // 禁止特权容器
        if v.DenyPrivileged && sc.Privileged != nil && *sc.Privileged {
            return fmt.Errorf(
                "容器 %s 不允许使用特权模式",
                container.Name,
            )
        }

        // 要求非root用户
        if v.RequireNonRoot {
            if sc.RunAsNonRoot == nil || !*sc.RunAsNonRoot {
                return fmt.Errorf(
                    "容器 %s 必须以非root用户运行",
                    container.Name,
                )
            }
        }

        // 检查Capabilities
        if sc.Capabilities != nil {
            for _, cap := range sc.Capabilities.Add {
                if !v.isAllowedCapability(string(cap)) {
                    return fmt.Errorf(
                        "容器 %s 不允许添加能力：%s",
                        container.Name,
                        cap,
                    )
                }
            }
        }
    }

    return nil
}

// 验证命名策略
func (v *AdvancedPodValidator) validateNamingPolicy(pod *corev1.Pod) error {
    // 检查命名格式
    if v.NamePattern != nil && !v.NamePattern.MatchString(pod.Name) {
        return fmt.Errorf(
            "Pod名称 %s 不符合命名规范：%s",
            pod.Name,
            v.NamePattern.String(),
        )
    }

    // 检查必需标签
    for _, label := range v.RequiredLabels {
        if _, ok := pod.Labels[label]; !ok {
            return fmt.Errorf("缺少必需的标签：%s", label)
        }
    }

    // 检查必需注解
    for _, annotation := range v.RequiredAnnotations {
        if _, ok := pod.Annotations[annotation]; !ok {
            return fmt.Errorf("缺少必需的注解：%s", annotation)
        }
    }

    return nil
}

// 辅助方法
func (v *AdvancedPodValidator) isAllowedRegistry(image string) bool {
    for _, registry := range v.AllowedRegistries {
        if strings.HasPrefix(image, registry) {
            return true
        }
    }
    return false
}

func (v *AdvancedPodValidator) isAllowedCapability(cap string) bool {
    for _, allowed := range v.AllowedCapabilities {
        if cap == allowed {
            return true
        }
    }
    return false
}
```

**配置示例**：

```go
// main.go
package main

import (
    "log"
    "net/http"
    "regexp"

    "k8s.io/apimachinery/pkg/api/resource"
    "webhook-server/pkg/webhook"
)

func main() {
    // 创建高级验证器
    validator := &webhook.AdvancedPodValidator{
        // 镜像策略
        AllowedRegistries: []string{
            "docker.io/",
            "gcr.io/",
            "registry.example.com/",
        },
        RequireImageScan: true,

        // 资源策略
        RequireResourceLimits: true,
        MaxCPU:                resource.MustParse("4"),     // 最大4核
        MaxMemory:             resource.MustParse("16Gi"),  // 最大16Gi
        CPUMemoryRatio:        4.0,  // 1核:4Gi内存

        // 安全策略
        DenyPrivileged:  true,
        RequireNonRoot:  true,
        DenyHostPath:    true,
        DenyHostNetwork: true,
        AllowedCapabilities: []string{
            "NET_BIND_SERVICE",
            "CHOWN",
            "SETUID",
            "SETGID",
        },

        // 命名策略
        RequiredLabels: []string{
            "app",
            "environment",
            "team",
        },
        RequiredAnnotations: []string{
            "owner",
            "cost-center",
        },
        NamePattern: regexp.MustCompile(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`),
    }

    // 创建服务器
    server := &webhook.WebhookServer{
        Validator: validator,
    }

    http.HandleFunc("/validate-pod", server.ServePodValidation)
    http.HandleFunc("/healthz", server.HealthCheck)

    log.Println("启动Webhook服务器...")
    log.Fatal(http.ListenAndServeTLS(":8443",
        "/etc/webhook/certs/tls.crt",
        "/etc/webhook/certs/tls.key",
        nil))
}
```

### 14.2.8 最佳实践

**1. 性能优化**

```yaml
# 使用objectSelector减少不必要的Webhook调用
objectSelector:
  matchExpressions:
  - key: skip-validation
    operator: DoesNotExist

# 设置合理的超时时间
timeoutSeconds: 5  # 不要太长

# 使用sideEffects声明
sideEffects: None  # 允许并行调用
```

**2. 错误处理**

```go
// 提供详细的错误信息
return admission.Denied(fmt.Sprintf(
    "验证失败：容器 %s 使用了未授权的镜像 %s。\n"+
    "允许的镜像仓库：%v\n"+
    "如需使用其他镜像，请联系安全团队",
    container.Name,
    container.Image,
    v.AllowedRegistries,
))
```

**3. 可观测性**

```go
// 添加结构化日志
log.Printf(
    "验证请求 - Namespace: %s, Pod: %s, Operation: %s, User: %s, Result: %v",
    ar.Request.Namespace,
    pod.Name,
    ar.Request.Operation,
    ar.Request.UserInfo.Username,
    response.Allowed,
)

// 导出Prometheus指标
validationTotal.WithLabelValues(
    ar.Request.Namespace,
    string(ar.Request.Operation),
    fmt.Sprint(response.Allowed),
).Inc()
```

**4. 高可用性**

```yaml
# 部署多副本
replicas: 3

# 设置Pod反亲和性
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchLabels:
            app: webhook-server
        topologyKey: kubernetes.io/hostname

# 设置PodDisruptionBudget
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: webhook-server-pdb
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: webhook-server
```

**5. 渐进式部署**

```yaml
# 阶段1：开发环境测试
namespaceSelector:
  matchLabels:
    environment: development
failurePolicy: Ignore  # 开发环境允许失败

# 阶段2：预生产环境
namespaceSelector:
  matchLabels:
    environment: staging
failurePolicy: Fail  # 严格模式

# 阶段3：生产环境
namespaceSelector:
  matchLabels:
    environment: production
failurePolicy: Fail
```

### 14.2.9 故障排查

**常见问题和解决方案**：

**问题1：Webhook超时**

```bash
# 症状
Error from server (InternalError): Internal error occurred:
failed calling webhook "pod-policy.example.com":
Post "https://webhook-server.webhook-system.svc:443/validate-pod?timeout=10s":
context deadline exceeded

# 排查步骤
# 1. 检查Webhook服务状态
kubectl get pods -n webhook-system
kubectl get svc -n webhook-system
kubectl get endpoints -n webhook-system

# 2. 检查Webhook日志
kubectl logs -n webhook-system -l app=webhook-server --tail=100

# 3. 测试服务连通性
kubectl run test-pod --image=busybox --rm -it --restart=Never -- \
  wget -O- https://webhook-server.webhook-system.svc:443/healthz --no-check-certificate

# 4. 增加超时时间（临时方案）
kubectl edit validatingwebhookconfiguration pod-policy-webhook
# 修改 timeoutSeconds: 30

# 解决方案
- 优化Webhook验证逻辑
- 增加Webhook副本数
- 检查网络策略是否阻止连接
```

**问题2：证书错误**

```bash
# 症状
Error from server (InternalError): Internal error occurred:
failed calling webhook "pod-policy.example.com":
Post "https://webhook-server.webhook-system.svc:443/validate-pod":
x509: certificate signed by unknown authority

# 排查步骤
# 1. 检查caBundle是否正确设置
kubectl get validatingwebhookconfiguration pod-policy-webhook -o yaml | grep caBundle

# 2. 检查Secret中的证书
kubectl get secret webhook-server-tls -n webhook-system -o yaml

# 3. 验证证书有效期
kubectl get secret webhook-server-tls -n webhook-system -o jsonpath='{.data.tls\.crt}' | \
  base64 -d | openssl x509 -noout -dates

# 解决方案
- 重新生成证书
- 确保caBundle与tls.crt的CA一致
- 使用cert-manager自动管理证书
```

**问题3：Webhook被意外调用**

```bash
# 症状
开发环境的Pod也被Webhook拦截了

# 排查步骤
kubectl get validatingwebhookconfiguration pod-policy-webhook -o yaml | \
  grep -A 5 namespaceSelector

# 解决方案
# 配置正确的namespaceSelector
namespaceSelector:
  matchLabels:
    environment: production
```

**问题4：无法删除ValidatingWebhookConfiguration**

```bash
# 症状
kubectl delete validatingwebhookconfiguration pod-policy-webhook
# 卡住不动

# 原因：存在Finalizer

# 解决方案
kubectl patch validatingwebhookconfiguration pod-policy-webhook \
  -p '{"metadata":{"finalizers":[]}}' --type=merge
```

---

**当前第14章进度**：
- ✅ 14.1 准入控制器原理（完成）
- ✅ 14.2 Validating Webhook（完成）
- ⏳ 14.3 Mutating Webhook（待编写）
- 📅 14.4 OPA (Open Policy Agent)（待编写）
- 📅 14.5 Kyverno策略引擎（待编写）
- 📅 14.6 实战：实施企业级策略管理（待编写）

接下来将继续编写14.3节的内容。
