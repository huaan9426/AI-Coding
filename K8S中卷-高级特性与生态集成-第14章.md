# 第14章：准入控制与策略管理

## 章节概述

在第13章中，我们学习了如何通过CRD和Operator扩展Kubernetes的功能。本章将深入学习Kubernetes的**准入控制（Admission Control）**机制，这是Kubernetes安全和策略管理的核心组件。

**本章核心目标**：
- 深入理解准入控制器的工作原理
- 掌握Validating Webhook和Mutating Webhook的开发
- 学习使用OPA（Open Policy Agent）实施策略管理
- 掌握Kyverno策略引擎的使用
- 实战：构建企业级策略管理系统

**为什么需要准入控制？**

```
Kubernetes API请求流程：
┌────────────────────────────────────────────┐
│  1. 用户/系统发起API请求                    │
│     kubectl apply -f pod.yaml              │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  2. 认证（Authentication）                 │
│     验证用户身份                           │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  3. 授权（Authorization）                  │
│     验证用户权限（RBAC）                   │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  4. 准入控制（Admission Control）⭐        │
│     ├─ Mutating Admission（修改请求）      │
│     └─ Validating Admission（验证请求）    │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  5. 持久化到etcd                           │
│     资源创建成功                           │
└────────────────────────────────────────────┘
```

**准入控制的作用**：

```
准入控制器的典型应用场景：
┌────────────────────────────────────────────┐
│  安全策略                                   │
│  ├─ 禁止特权容器                           │
│  ├─ 强制镜像来源验证                       │
│  ├─ 要求设置资源限制                       │
│  └─ 禁止hostPath挂载                       │
├────────────────────────────────────────────┤
│  资源管理                                   │
│  ├─ 自动注入资源限制                       │
│  ├─ 自动添加标签和注解                     │
│  ├─ 自动设置默认值                         │
│  └─ 配额管理                               │
├────────────────────────────────────────────┤
│  合规性                                     │
│  ├─ 强制命名规范                           │
│  ├─ 要求特定标签                           │
│  ├─ 审计日志                               │
│  └─ 数据保护                               │
├────────────────────────────────────────────┤
│  运维自动化                                 │
│  ├─ 自动注入Sidecar                        │
│  ├─ 自动配置网络策略                       │
│  ├─ 自动添加监控配置                       │
│  └─ 自动设置亲和性                         │
└────────────────────────────────────────────┘
```

**本章学习路径**：

```
14.1 准入控制器原理
  ↓
14.2 Validating Webhook
  ↓
14.3 Mutating Webhook
  ↓
14.4 OPA (Open Policy Agent)
  ↓
14.5 Kyverno策略引擎
  ↓
14.6 实战：实施企业级策略管理
```

---

## 14.1 准入控制器原理

### 14.1.1 准入控制器概述

准入控制器（Admission Controller）是Kubernetes API Server的插件，用于在对象持久化之前拦截API请求。

**准入控制器的类型**：

```
准入控制器分类：
┌────────────────────────────────────────────┐
│  1. 内置准入控制器（Built-in）              │
│     - Kubernetes原生提供                   │
│     - 编译到API Server中                   │
│     - 通过--enable-admission-plugins启用   │
│     - 示例：                               │
│       * NamespaceLifecycle                 │
│       * LimitRanger                        │
│       * ServiceAccount                     │
│       * ResourceQuota                      │
│       * PodSecurityPolicy                  │
├────────────────────────────────────────────┤
│  2. 动态准入控制器（Dynamic）               │
│     - 通过Webhook实现                      │
│     - 可以独立部署和更新                   │
│     - 分为两类：                           │
│       * Mutating Admission Webhook         │
│       * Validating Admission Webhook       │
└────────────────────────────────────────────┘
```

### 14.1.2 准入控制流程

**完整的准入控制流程**：

```
API请求处理流程：
┌──────────────────────────────────────────────┐
│  1. API请求到达                              │
│     POST /api/v1/namespaces/default/pods     │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  2. 认证（Authentication）                   │
│     - 客户端证书                             │
│     - Bearer Token                           │
│     - ServiceAccount                         │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  3. 授权（Authorization）                    │
│     - RBAC检查                               │
│     - 验证用户是否有权限执行操作             │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  4. Mutating Admission（变更准入）           │
│     按顺序执行所有Mutating Webhook：         │
│     ├─ Webhook 1: 添加默认标签              │
│     ├─ Webhook 2: 注入Sidecar容器           │
│     ├─ Webhook 3: 设置资源限制              │
│     └─ Webhook 4: 添加环境变量              │
│     注意：每个Webhook可以修改请求对象        │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  5. Schema验证                               │
│     验证对象是否符合API Schema               │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  6. Validating Admission（验证准入）         │
│     并行执行所有Validating Webhook：         │
│     ├─ Webhook 1: 验证镜像来源              │
│     ├─ Webhook 2: 验证资源配额              │
│     ├─ Webhook 3: 验证安全策略              │
│     └─ Webhook 4: 验证命名规范              │
│     注意：任何一个Webhook拒绝则请求失败      │
└──────────────────────────────────────────────┘
                ↓
┌──────────────────────────────────────────────┐
│  7. 持久化到etcd                             │
│     对象创建成功                             │
└──────────────────────────────────────────────┘
```

**Mutating vs Validating**：

| 特性 | Mutating Admission | Validating Admission |
|------|-------------------|---------------------|
| **执行顺序** | 先执行 | 后执行 |
| **执行方式** | 串行（顺序执行） | 并行（同时执行） |
| **主要作用** | 修改请求对象 | 验证请求对象 |
| **典型用途** | 注入Sidecar、设置默认值 | 策略验证、合规检查 |
| **失败影响** | 继续执行下一个 | 立即拒绝请求 |
| **返回结果** | 修改后的对象 | 允许/拒绝 |

### 14.1.3 内置准入控制器

**常用的内置准入控制器**：

```yaml
# 查看API Server启用的准入控制器
kubectl exec -n kube-system kube-apiserver-master --   kube-apiserver -h | grep enable-admission-plugins
```

**1. NamespaceLifecycle**

防止在不存在或正在删除的Namespace中创建资源。

```bash
# 示例：尝试在不存在的Namespace创建Pod
kubectl run nginx --image=nginx -n non-existent-ns
# Error: namespaces "non-existent-ns" not found
```

**2. LimitRanger**

为Pod和容器设置默认的资源请求和限制。

```yaml
# LimitRange示例
apiVersion: v1
kind: LimitRange
metadata:
  name: mem-limit-range
  namespace: default
spec:
  limits:
  - default:  # 默认限制
      memory: 512Mi
      cpu: 500m
    defaultRequest:  # 默认请求
      memory: 256Mi
      cpu: 250m
    type: Container
```

**3. ServiceAccount**

自动为Pod注入ServiceAccount。

```yaml
# Pod会自动注入default ServiceAccount
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: nginx
    image: nginx
  # 自动添加：
  # serviceAccountName: default
  # volumes:
  # - name: kube-api-access-xxxxx
  #   projected:
  #     sources:
  #     - serviceAccountToken: ...
```

**4. ResourceQuota**

强制执行Namespace的资源配额。

```yaml
# ResourceQuota示例
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: default
spec:
  hard:
    requests.cpu: "10"
    requests.memory: 20Gi
    limits.cpu: "20"
    limits.memory: 40Gi
    pods: "50"
```

```bash
# 超过配额时创建Pod会失败
kubectl run nginx --image=nginx --requests=cpu=15
# Error: exceeded quota: compute-quota
```

**5. PodSecurityPolicy（已弃用，使用Pod Security Admission替代）**

控制Pod的安全相关配置。

```yaml
# Pod Security Admission（PSA）
apiVersion: v1
kind: Namespace
metadata:
  name: my-namespace
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
```

**6. NodeRestriction**

限制kubelet只能修改自己节点上的资源。

```bash
# kubelet只能修改自己节点的Node对象和Pod
# 防止恶意kubelet修改其他节点的资源
```

**7. AlwaysPullImages**

强制每次都拉取镜像，防止使用本地缓存的镜像。

```yaml
# 启用后，所有Pod的imagePullPolicy都会被设置为Always
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: nginx
    image: nginx
    # 自动设置：imagePullPolicy: Always
```

### 14.1.4 配置准入控制器

**查看当前启用的准入控制器**：

```bash
# 方法1：查看API Server配置
kubectl get pod -n kube-system kube-apiserver-master -o yaml | grep admission

# 方法2：查看API Server进程参数
ps aux | grep kube-apiserver | grep admission-plugins

# 方法3：查看API Server manifest
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep admission
```

**启用/禁用准入控制器**：

```yaml
# /etc/kubernetes/manifests/kube-apiserver.yaml
apiVersion: v1
kind: Pod
metadata:
  name: kube-apiserver
  namespace: kube-system
spec:
  containers:
  - command:
    - kube-apiserver
    # 启用准入控制器
    - --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodSecurity
    # 禁用准入控制器
    - --disable-admission-plugins=AlwaysPullImages
    # ... 其他参数
```

**推荐的准入控制器配置**：

```bash
# 生产环境推荐配置
--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodSecurity,NodeRestriction,Priority,StorageObjectInUseProtection,PersistentVolumeClaimResize
```

### 14.1.5 准入控制器最佳实践

**1. 安全相关**

```yaml
# ✅ 推荐启用的安全准入控制器
- PodSecurity              # Pod安全标准
- NodeRestriction          # 限制kubelet权限
- ServiceAccount           # 自动注入ServiceAccount
- AlwaysPullImages         # 强制拉取镜像（可选）

# ✅ 使用Webhook实施自定义安全策略
- 验证镜像签名
- 禁止特权容器
- 强制使用非root用户
- 限制hostPath使用
```

**2. 资源管理**

```yaml
# ✅ 推荐启用的资源管理准入控制器
- LimitRanger              # 设置默认资源限制
- ResourceQuota            # 强制资源配额
- PersistentVolumeClaimResize  # 允许PVC扩容

# ✅ 使用Webhook实施自定义资源策略
- 自动设置资源请求和限制
- 验证资源配置合理性
- 防止资源过度分配
```

**3. 运维自动化**

```yaml
# ✅ 使用Mutating Webhook自动化运维任务
- 自动注入Sidecar容器（如Istio、Linkerd）
- 自动添加标签和注解
- 自动配置环境变量
- 自动设置亲和性和容忍度
```

**4. 合规性**

```yaml
# ✅ 使用Validating Webhook实施合规策略
- 强制命名规范
- 要求特定标签
- 验证镜像来源
- 审计日志记录
```

### 14.1.6 准入控制器调试

**1. 查看准入控制器日志**

```bash
# 查看API Server日志
kubectl logs -n kube-system kube-apiserver-master | grep admission

# 查看Webhook日志
kubectl logs -n webhook-system webhook-server-xxx
```

**2. 测试准入控制器**

```bash
# 使用--dry-run测试
kubectl apply -f pod.yaml --dry-run=server

# 查看详细错误信息
kubectl apply -f pod.yaml -v=8
```

**3. 调试Webhook**

```yaml
# 在Webhook配置中启用详细日志
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: my-webhook
webhooks:
- name: my-webhook.example.com
  # 失败策略：Ignore表示Webhook失败时允许请求通过
  failurePolicy: Ignore  # 调试时使用，生产环境使用Fail
  # 超时时间
  timeoutSeconds: 10
  # ... 其他配置
```

**4. 常见问题排查**

```bash
# 问题1：Webhook超时
# 检查Webhook服务是否正常
kubectl get svc -n webhook-system
kubectl get endpoints -n webhook-system

# 问题2：证书错误
# 检查Webhook证书
kubectl get validatingwebhookconfiguration my-webhook -o yaml | grep caBundle

# 问题3：请求被拒绝
# 查看拒绝原因
kubectl describe pod my-pod | grep -A 10 Events
```

### 14.1.7 准入控制器性能考虑

**性能影响因素**：

```
准入控制器性能影响：
┌────────────────────────────────────────────┐
│  1. Webhook数量                            │
│     - 每个Webhook增加延迟                  │
│     - 建议：合并相关Webhook                │
├────────────────────────────────────────────┤
│  2. Webhook响应时间                        │
│     - 网络延迟                             │
│     - 处理时间                             │
│     - 建议：优化Webhook逻辑，设置超时      │
├────────────────────────────────────────────┤
│  3. 失败策略                               │
│     - Fail：Webhook失败则请求失败          │
│     - Ignore：Webhook失败则请求通过        │
│     - 建议：生产环境使用Fail               │
├────────────────────────────────────────────┤
│  4. 对象大小                               │
│     - 大对象增加序列化/反序列化时间        │
│     - 建议：避免在Webhook中处理大对象      │
└────────────────────────────────────────────┘
```

**性能优化建议**：

```yaml
# 1. 设置合理的超时时间
timeoutSeconds: 5  # 默认10秒，可以根据实际情况调整

# 2. 使用objectSelector减少Webhook调用
objectSelector:
  matchLabels:
    webhook: enabled

# 3. 使用namespaceSelector限制作用范围
namespaceSelector:
  matchExpressions:
  - key: environment
    operator: In
    values: ["production"]

# 4. 配置合理的失败策略
failurePolicy: Fail  # 生产环境
# failurePolicy: Ignore  # 开发环境

# 5. 使用sideEffects声明副作用
sideEffects: None  # 表示Webhook没有副作用，可以安全地并行调用
```

---

## 14.2 Validating Webhook

### 14.2.1 Validating Webhook概述

**什么是Validating Webhook？**

Validating Webhook是一种动态准入控制器，允许你在对象持久化到etcd之前验证请求。与内置准入控制器不同，Validating Webhook可以独立部署和更新，无需重启API Server。

**工作流程**：

```
Validating Webhook执行流程：
┌────────────────────────────────────────────┐
│  1. API Server接收创建/更新请求            │
│     kubectl apply -f pod.yaml              │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  2. 通过认证和授权                         │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  3. 执行Mutating Admission                 │
│     （可能修改对象）                       │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  4. Schema验证                             │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  5. API Server调用Validating Webhook       │
│     POST https://webhook-svc/validate      │
│     {                                      │
│       "request": {                         │
│         "object": {...},                   │
│         "oldObject": {...},                │
│         "operation": "CREATE"              │
│       }                                    │
│     }                                      │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  6. Webhook验证对象                        │
│     - 检查镜像来源                         │
│     - 验证资源配额                         │
│     - 检查安全策略                         │
│     - 验证命名规范                         │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  7. Webhook返回响应                        │
│     {                                      │
│       "response": {                        │
│         "allowed": true/false,             │
│         "status": {                        │
│           "message": "拒绝原因"            │
│         }                                  │
│       }                                    │
│     }                                      │
└────────────────────────────────────────────┘
                ↓
     ┌──────────┴──────────┐
     ↓                     ↓
┌─────────┐         ┌─────────┐
│ allowed │         │ denied  │
│ = true  │         │ = false │
└─────────┘         └─────────┘
     ↓                     ↓
  持久化              请求失败
  到etcd              返回错误
```

**Validating Webhook的特点**：

| 特性 | 说明 |
|------|------|
| **执行时机** | Mutating Admission之后、对象持久化之前 |
| **执行方式** | 并行执行所有Webhook |
| **修改能力** | 不能修改对象，只能允许或拒绝 |
| **失败处理** | 任何一个Webhook拒绝，整个请求失败 |
| **典型用途** | 策略验证、合规检查、安全审计 |

**使用场景**：

```
Validating Webhook典型应用场景：
┌────────────────────────────────────────────┐
│  安全策略验证                               │
│  ├─ 验证镜像来自可信仓库                   │
│  ├─ 禁止特权容器                           │
│  ├─ 要求非root用户运行                     │
│  ├─ 禁止hostPath挂载                       │
│  └─ 验证镜像签名                           │
├────────────────────────────────────────────┤
│  资源合规性                                 │
│  ├─ 强制设置资源limits                     │
│  ├─ 验证资源配额合理性                     │
│  ├─ 检查CPU/内存比例                       │
│  └─ 防止资源过度分配                       │
├────────────────────────────────────────────┤
│  命名和标签规范                             │
│  ├─ 强制命名格式                           │
│  ├─ 要求特定标签                           │
│  ├─ 验证标签值                             │
│  └─ 检查注解完整性                         │
├────────────────────────────────────────────┤
│  网络策略                                   │
│  ├─ 验证Ingress配置                        │
│  ├─ 检查Service端口                        │
│  ├─ 验证NetworkPolicy                      │
│  └─ 限制外部访问                           │
└────────────────────────────────────────────┘
```

### 14.2.2 ValidatingWebhookConfiguration资源

**资源定义**：

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: pod-policy-webhook
webhooks:
- name: pod-policy.example.com
  # Webhook调用地址
  clientConfig:
    # 方式1：使用Service（推荐）
    service:
      namespace: webhook-system
      name: webhook-server
      path: /validate-pod
      port: 443
    # CA证书（Base64编码）
    caBundle: LS0tLS1CRUdJTi...

    # 方式2：使用外部URL
    # url: https://external-webhook.example.com/validate

  # 匹配规则
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
    scope: "Namespaced"  # 或 "Cluster"、"*"

  # Namespace选择器（可选）
  namespaceSelector:
    matchLabels:
      environment: production
    # 或使用matchExpressions
    # matchExpressions:
    # - key: environment
    #   operator: In
    #   values: ["production", "staging"]

  # 对象选择器（可选）
  objectSelector:
    matchLabels:
      validate: "true"

  # 失败策略
  failurePolicy: Fail  # Fail: Webhook失败则拒绝请求
                       # Ignore: Webhook失败则允许请求

  # 匹配策略
  matchPolicy: Equivalent  # Equivalent: 等价匹配
                          # Exact: 精确匹配

  # 副作用声明
  sideEffects: None  # None: 无副作用
                     # NoneOnDryRun: dry-run时无副作用

  # 超时时间（秒）
  timeoutSeconds: 10  # 默认10秒，范围1-30

  # 准入审查版本
  admissionReviewVersions: ["v1", "v1beta1"]
```

**配置参数详解**：

**1. rules（匹配规则）**

```yaml
rules:
# 示例1：只匹配Pod的CREATE操作
- operations: ["CREATE"]
  apiGroups: [""]
  apiVersions: ["v1"]
  resources: ["pods"]

# 示例2：匹配所有Deployment操作
- operations: ["CREATE", "UPDATE", "DELETE"]
  apiGroups: ["apps"]
  apiVersions: ["v1"]
  resources: ["deployments"]

# 示例3：匹配所有资源
- operations: ["*"]
  apiGroups: ["*"]
  apiVersions: ["*"]
  resources: ["*"]

# 示例4：匹配子资源
- operations: ["CREATE"]
  apiGroups: [""]
  apiVersions: ["v1"]
  resources: ["pods/exec", "pods/portforward"]
```

**2. namespaceSelector（命名空间选择器）**

```yaml
# 示例1：匹配特定标签的Namespace
namespaceSelector:
  matchLabels:
    environment: production

# 示例2：排除特定Namespace
namespaceSelector:
  matchExpressions:
  - key: exclude-webhook
    operator: DoesNotExist

# 示例3：匹配多个环境
namespaceSelector:
  matchExpressions:
  - key: environment
    operator: In
    values: ["production", "staging"]
```

**3. objectSelector（对象选择器）**

```yaml
# 示例1：只验证带特定标签的Pod
objectSelector:
  matchLabels:
    validate: "true"

# 示例2：排除系统Pod
objectSelector:
  matchExpressions:
  - key: app
    operator: NotIn
    values: ["kube-proxy", "kube-dns"]
```

**4. failurePolicy（失败策略）**

```yaml
# Fail：Webhook失败则拒绝请求（生产环境推荐）
failurePolicy: Fail

# Ignore：Webhook失败则允许请求（开发环境可用）
failurePolicy: Ignore
```

**完整示例：Pod安全策略验证Webhook**

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: pod-security-policy
webhooks:
- name: pod-security.example.com
  clientConfig:
    service:
      namespace: webhook-system
      name: webhook-server
      path: /validate-pod-security
      port: 443
    caBundle: ${CA_BUNDLE}

  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]

  # 只在生产环境启用
  namespaceSelector:
    matchLabels:
      environment: production

  # 排除系统Pod
  objectSelector:
    matchExpressions:
    - key: app
      operator: NotIn
      values: ["kube-system", "kube-public"]

  failurePolicy: Fail
  sideEffects: None
  timeoutSeconds: 5
  admissionReviewVersions: ["v1"]
```

### 14.2.3 Webhook服务端实现

**Go语言实现Validating Webhook**

**项目结构**：

```
webhook-server/
├── main.go              # 主程序
├── pkg/
│   ├── webhook/
│   │   ├── server.go    # HTTP服务器
│   │   └── validator.go # 验证逻辑
│   └── admission/
│       └── types.go     # 请求/响应类型
├── deploy/
│   ├── deployment.yaml
│   ├── service.yaml
│   └── webhook-config.yaml
└── Dockerfile
```

**1. 定义请求/响应类型**

```go
// pkg/admission/types.go
package admission

import (
    admissionv1 "k8s.io/api/admission/v1"
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// AdmissionReview请求结构
type AdmissionReview struct {
    Request  *admissionv1.AdmissionRequest  `json:"request"`
    Response *admissionv1.AdmissionResponse `json:"response"`
}

// 构建允许响应
func Allowed(message string) *admissionv1.AdmissionResponse {
    return &admissionv1.AdmissionResponse{
        Allowed: true,
        Result: &metav1.Status{
            Message: message,
        },
    }
}

// 构建拒绝响应
func Denied(message string) *admissionv1.AdmissionResponse {
    return &admissionv1.AdmissionResponse{
        Allowed: false,
        Result: &metav1.Status{
            Message: message,
            Code:    403,
        },
    }
}
```

**2. 实现验证逻辑**

```go
// pkg/webhook/validator.go
package webhook

import (
    "encoding/json"
    "fmt"
    "strings"

    admissionv1 "k8s.io/api/admission/v1"
    corev1 "k8s.io/api/core/v1"
    "webhook-server/pkg/admission"
)

// PodValidator Pod验证器
type PodValidator struct {
    AllowedRegistries []string
}

// ValidatePod 验证Pod
func (v *PodValidator) ValidatePod(ar *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {
    // 1. 解析Pod对象
    pod := &corev1.Pod{}
    if err := json.Unmarshal(ar.Object.Raw, pod); err != nil {
        return admission.Denied(fmt.Sprintf("无法解析Pod: %v", err))
    }

    // 2. 验证镜像来源
    if err := v.validateImageRegistry(pod); err != nil {
        return admission.Denied(err.Error())
    }

    // 3. 验证资源限制
    if err := v.validateResourceLimits(pod); err != nil {
        return admission.Denied(err.Error())
    }

    // 4. 验证安全上下文
    if err := v.validateSecurityContext(pod); err != nil {
        return admission.Denied(err.Error())
    }

    // 5. 验证命名规范
    if err := v.validateNaming(pod); err != nil {
        return admission.Denied(err.Error())
    }

    return admission.Allowed("Pod验证通过")
}

// 验证镜像来源
func (v *PodValidator) validateImageRegistry(pod *corev1.Pod) error {
    for _, container := range pod.Spec.Containers {
        if !v.isAllowedRegistry(container.Image) {
            return fmt.Errorf(
                "镜像 %s 来自未授权的仓库。允许的仓库：%v",
                container.Image,
                v.AllowedRegistries,
            )
        }
    }
    return nil
}

// 检查镜像是否来自允许的仓库
func (v *PodValidator) isAllowedRegistry(image string) bool {
    for _, registry := range v.AllowedRegistries {
        if strings.HasPrefix(image, registry) {
            return true
        }
    }
    return false
}

// 验证资源限制
func (v *PodValidator) validateResourceLimits(pod *corev1.Pod) error {
    for _, container := range pod.Spec.Containers {
        // 检查是否设置了资源限制
        if container.Resources.Limits == nil {
            return fmt.Errorf(
                "容器 %s 未设置资源限制（limits）",
                container.Name,
            )
        }

        // 检查CPU和内存限制
        cpuLimit := container.Resources.Limits.Cpu()
        memLimit := container.Resources.Limits.Memory()

        if cpuLimit.IsZero() {
            return fmt.Errorf(
                "容器 %s 未设置CPU限制",
                container.Name,
            )
        }

        if memLimit.IsZero() {
            return fmt.Errorf(
                "容器 %s 未设置内存限制",
                container.Name,
            )
        }
    }
    return nil
}

// 验证安全上下文
func (v *PodValidator) validateSecurityContext(pod *corev1.Pod) error {
    for _, container := range pod.Spec.Containers {
        sc := container.SecurityContext

        // 禁止特权容器
        if sc != nil && sc.Privileged != nil && *sc.Privileged {
            return fmt.Errorf(
                "容器 %s 不允许使用特权模式",
                container.Name,
            )
        }

        // 要求非root用户
        if sc != nil && sc.RunAsNonRoot != nil && !*sc.RunAsNonRoot {
            return fmt.Errorf(
                "容器 %s 必须以非root用户运行",
                container.Name,
            )
        }

        // 禁止hostPath
        for _, volume := range pod.Spec.Volumes {
            if volume.HostPath != nil {
                return fmt.Errorf(
                    "不允许使用hostPath卷：%s",
                    volume.Name,
                )
            }
        }
    }
    return nil
}

// 验证命名规范
func (v *PodValidator) validateNaming(pod *corev1.Pod) error {
    // 检查是否有必需的标签
    requiredLabels := []string{"app", "environment"}
    for _, label := range requiredLabels {
        if _, exists := pod.Labels[label]; !exists {
            return fmt.Errorf(
                "Pod缺少必需的标签：%s",
                label,
            )
        }
    }

    // 检查命名格式
    if !strings.Contains(pod.Name, "-") {
        return fmt.Errorf(
            "Pod名称必须包含连字符，格式：<app>-<version>",
        )
    }

    return nil
}
```

**3. 实现HTTP服务器**

```go
// pkg/webhook/server.go
package webhook

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"

    admissionv1 "k8s.io/api/admission/v1"
)

// WebhookServer Webhook服务器
type WebhookServer struct {
    Validator *PodValidator
}

// ServePodValidation 处理Pod验证请求
func (s *WebhookServer) ServePodValidation(w http.ResponseWriter, r *http.Request) {
    log.Println("收到验证请求")

    // 1. 读取请求体
    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
        log.Printf("读取请求失败: %v", err)
        http.Error(w, "无法读取请求", http.StatusBadRequest)
        return
    }
    defer r.Body.Close()

    // 2. 解析AdmissionReview
    ar := &admissionv1.AdmissionReview{}
    if err := json.Unmarshal(body, ar); err != nil {
        log.Printf("解析AdmissionReview失败: %v", err)
        http.Error(w, "无效的AdmissionReview", http.StatusBadRequest)
        return
    }

    // 3. 验证请求
    if ar.Request == nil {
        log.Println("AdmissionReview.Request为空")
        http.Error(w, "无效的请求", http.StatusBadRequest)
        return
    }

    // 4. 执行验证逻辑
    response := s.Validator.ValidatePod(ar.Request)

    // 5. 构建响应
    ar.Response = response
    ar.Response.UID = ar.Request.UID

    // 6. 返回响应
    respBytes, err := json.Marshal(ar)
    if err != nil {
        log.Printf("序列化响应失败: %v", err)
        http.Error(w, "无法序列化响应", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    w.Write(respBytes)

    log.Printf("验证结果: allowed=%v, message=%s",
        response.Allowed, response.Result.Message)
}

// HealthCheck 健康检查
func (s *WebhookServer) HealthCheck(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, "OK")
}
```

**4. 主程序**

```go
// main.go
package main

import (
    "log"
    "net/http"

    "webhook-server/pkg/webhook"
)

func main() {
    // 创建验证器
    validator := &webhook.PodValidator{
        AllowedRegistries: []string{
            "docker.io/",
            "gcr.io/",
            "registry.example.com/",
        },
    }

    // 创建Webhook服务器
    server := &webhook.WebhookServer{
        Validator: validator,
    }

    // 注册路由
    http.HandleFunc("/validate-pod", server.ServePodValidation)
    http.HandleFunc("/healthz", server.HealthCheck)

    // 启动HTTPS服务器
    log.Println("启动Webhook服务器，监听端口 8443...")
    err := http.ListenAndServeTLS(
        ":8443",
        "/etc/webhook/certs/tls.crt",  // TLS证书
        "/etc/webhook/certs/tls.key",  // TLS私钥
        nil,
    )
    if err != nil {
        log.Fatalf("启动服务器失败: %v", err)
    }
}
```

**5. Dockerfile**

```dockerfile
# Dockerfile
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o webhook-server .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/webhook-server .
EXPOSE 8443
CMD ["./webhook-server"]
```

### 14.2.4 TLS证书配置

**方式1：使用脚本生成自签名证书**

```bash
#!/bin/bash
# generate-cert.sh

set -e

# 配置
SERVICE_NAME="webhook-server"
NAMESPACE="webhook-system"
SECRET_NAME="webhook-server-tls"

# 创建临时目录
TMP_DIR=$(mktemp -d)
cd $TMP_DIR

# 1. 生成CA私钥
openssl genrsa -out ca.key 2048

# 2. 生成CA证书
openssl req -x509 -new -nodes -key ca.key -days 3650 \
    -out ca.crt -subj "/CN=webhook-ca"

# 3. 生成服务器私钥
openssl genrsa -out tls.key 2048

# 4. 创建证书签名请求配置
cat > csr.conf <<EOF
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = ${SERVICE_NAME}
DNS.2 = ${SERVICE_NAME}.${NAMESPACE}
DNS.3 = ${SERVICE_NAME}.${NAMESPACE}.svc
DNS.4 = ${SERVICE_NAME}.${NAMESPACE}.svc.cluster.local
EOF

# 5. 生成证书签名请求
openssl req -new -key tls.key -out tls.csr \
    -subj "/CN=${SERVICE_NAME}.${NAMESPACE}.svc" \
    -config csr.conf

# 6. 签发服务器证书
openssl x509 -req -in tls.csr -CA ca.crt -CAkey ca.key \
    -CAcreateserial -out tls.crt -days 3650 \
    -extensions v3_req -extfile csr.conf

# 7. 创建Secret
kubectl create secret tls ${SECRET_NAME} \
    --cert=tls.crt \
    --key=tls.key \
    -n ${NAMESPACE} \
    --dry-run=client -o yaml > webhook-tls-secret.yaml

# 8. 获取CA证书的Base64编码（用于ValidatingWebhookConfiguration）
CA_BUNDLE=$(cat ca.crt | base64 | tr -d '\n')
echo "CA_BUNDLE: ${CA_BUNDLE}"

# 9. 清理
cd -
rm -rf $TMP_DIR

echo "证书生成完成！"
echo "Secret YAML: webhook-tls-secret.yaml"
echo "请在ValidatingWebhookConfiguration中设置 caBundle: ${CA_BUNDLE}"
```

**执行脚本**：

```bash
chmod +x generate-cert.sh
./generate-cert.sh

# 应用Secret
kubectl apply -f webhook-tls-secret.yaml
```

**方式2：使用cert-manager自动化证书管理（推荐）**

```bash
# 1. 安装cert-manager
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml

# 2. 等待cert-manager就绪
kubectl wait --for=condition=ready pod -l app=cert-manager -n cert-manager --timeout=300s
```

**创建自签名Issuer**：

```yaml
# cert-issuer.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: webhook-system
---
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: selfsigned-issuer
  namespace: webhook-system
spec:
  selfSigned: {}
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: webhook-server-cert
  namespace: webhook-system
spec:
  secretName: webhook-server-tls
  duration: 8760h  # 1年
  renewBefore: 720h  # 30天前续期
  subject:
    organizations:
    - example-org
  commonName: webhook-server.webhook-system.svc
  dnsNames:
  - webhook-server
  - webhook-server.webhook-system
  - webhook-server.webhook-system.svc
  - webhook-server.webhook-system.svc.cluster.local
  issuerRef:
    name: selfsigned-issuer
    kind: Issuer
```

**应用配置**：

```bash
kubectl apply -f cert-issuer.yaml

# 检查证书状态
kubectl get certificate -n webhook-system
kubectl describe certificate webhook-server-cert -n webhook-system

# 检查生成的Secret
kubectl get secret webhook-server-tls -n webhook-system
```

**使用cert-manager注入caBundle（推荐）**：

```yaml
# webhook-config.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: pod-policy-webhook
  annotations:
    # cert-manager会自动注入caBundle
    cert-manager.io/inject-ca-from: webhook-system/webhook-server-cert
webhooks:
- name: pod-policy.example.com
  clientConfig:
    service:
      namespace: webhook-system
      name: webhook-server
      path: /validate-pod
      port: 443
    # caBundle会被cert-manager自动注入
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
  failurePolicy: Fail
  sideEffects: None
  admissionReviewVersions: ["v1"]
```

### 14.2.5 部署Webhook服务

**1. 部署Webhook Server**

```yaml
# deploy/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webhook-server
  namespace: webhook-system
  labels:
    app: webhook-server
spec:
  replicas: 2
  selector:
    matchLabels:
      app: webhook-server
  template:
    metadata:
      labels:
        app: webhook-server
    spec:
      containers:
      - name: webhook
        image: registry.example.com/webhook-server:v1.0.0
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8443
          name: webhook
          protocol: TCP
        volumeMounts:
        - name: webhook-certs
          mountPath: /etc/webhook/certs
          readOnly: true
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8443
            scheme: HTTPS
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /healthz
            port: 8443
            scheme: HTTPS
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: webhook-certs
        secret:
          secretName: webhook-server-tls
---
apiVersion: v1
kind: Service
metadata:
  name: webhook-server
  namespace: webhook-system
  labels:
    app: webhook-server
spec:
  selector:
    app: webhook-server
  ports:
  - port: 443
    targetPort: 8443
    protocol: TCP
    name: webhook
  type: ClusterIP
```

**2. 应用部署**：

```bash
# 创建Namespace
kubectl create namespace webhook-system

# 部署Webhook服务
kubectl apply -f deploy/deployment.yaml

# 检查部署状态
kubectl get pods -n webhook-system
kubectl get svc -n webhook-system

# 检查日志
kubectl logs -n webhook-system -l app=webhook-server -f
```

**3. 创建ValidatingWebhookConfiguration**：

```yaml
# deploy/webhook-config.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: pod-policy-webhook
  annotations:
    cert-manager.io/inject-ca-from: webhook-system/webhook-server-cert
webhooks:
- name: pod-policy.example.com
  clientConfig:
    service:
      namespace: webhook-system
      name: webhook-server
      path: /validate-pod
      port: 443
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
  # 只在生产环境启用
  namespaceSelector:
    matchLabels:
      environment: production
  failurePolicy: Fail
  sideEffects: None
  timeoutSeconds: 10
  admissionReviewVersions: ["v1"]
```

**应用配置**：

```bash
kubectl apply -f deploy/webhook-config.yaml

# 检查配置
kubectl get validatingwebhookconfiguration pod-policy-webhook
kubectl describe validatingwebhookconfiguration pod-policy-webhook
```

### 14.2.6 测试Validating Webhook

**1. 准备测试Namespace**

```bash
# 创建生产环境Namespace
kubectl create namespace production
kubectl label namespace production environment=production

# 创建开发环境Namespace（不会被Webhook拦截）
kubectl create namespace development
kubectl label namespace development environment=development
```

**2. 测试用例1：验证通过的Pod**

```yaml
# test-pod-valid.yaml
apiVersion: v1
kind: Pod
metadata:
  name: valid-pod
  namespace: production
  labels:
    app: nginx
    environment: production
spec:
  containers:
  - name: nginx
    image: docker.io/nginx:1.21
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 200m
        memory: 256Mi
    securityContext:
      runAsNonRoot: true
      runAsUser: 1000
```

```bash
# 应该成功创建
kubectl apply -f test-pod-valid.yaml

# 检查Pod状态
kubectl get pod valid-pod -n production
```

**3. 测试用例2：镜像来源验证失败**

```yaml
# test-pod-invalid-registry.yaml
apiVersion: v1
kind: Pod
metadata:
  name: invalid-registry-pod
  namespace: production
  labels:
    app: nginx
    environment: production
spec:
  containers:
  - name: nginx
    image: untrusted-registry.com/nginx:latest
    resources:
      limits:
        cpu: 200m
        memory: 256Mi
    securityContext:
      runAsNonRoot: true
```

```bash
# 应该被拒绝
kubectl apply -f test-pod-invalid-registry.yaml
# Error from server: admission webhook "pod-policy.example.com" denied the request:
# 镜像 untrusted-registry.com/nginx:latest 来自未授权的仓库
```

**4. 测试用例3：缺少资源限制**

```yaml
# test-pod-no-limits.yaml
apiVersion: v1
kind: Pod
metadata:
  name: no-limits-pod
  namespace: production
  labels:
    app: nginx
    environment: production
spec:
  containers:
  - name: nginx
    image: docker.io/nginx:1.21
    # 缺少resources.limits
```

```bash
# 应该被拒绝
kubectl apply -f test-pod-no-limits.yaml
# Error from server: admission webhook "pod-policy.example.com" denied the request:
# 容器 nginx 未设置资源限制（limits）
```

**5. 测试用例4：特权容器**

```yaml
# test-pod-privileged.yaml
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
  namespace: production
  labels:
    app: nginx
    environment: production
spec:
  containers:
  - name: nginx
    image: docker.io/nginx:1.21
    resources:
      limits:
        cpu: 200m
        memory: 256Mi
    securityContext:
      privileged: true  # 不允许
```

```bash
# 应该被拒绝
kubectl apply -f test-pod-privileged.yaml
# Error from server: admission webhook "pod-policy.example.com" denied the request:
# 容器 nginx 不允许使用特权模式
```

**6. 测试用例5：缺少必需标签**

```yaml
# test-pod-missing-labels.yaml
apiVersion: v1
kind: Pod
metadata:
  name: missing-labels-pod
  namespace: production
  # 缺少必需的标签: app, environment
spec:
  containers:
  - name: nginx
    image: docker.io/nginx:1.21
    resources:
      limits:
        cpu: 200m
        memory: 256Mi
```

```bash
# 应该被拒绝
kubectl apply -f test-pod-missing-labels.yaml
# Error from server: admission webhook "pod-policy.example.com" denied the request:
# Pod缺少必需的标签：app
```

**7. 在开发环境测试（不受Webhook限制）**

```yaml
# test-pod-dev.yaml
apiVersion: v1
kind: Pod
metadata:
  name: dev-pod
  namespace: development  # 开发环境，不会被Webhook拦截
spec:
  containers:
  - name: nginx
    image: untrusted-registry.com/nginx:latest
    # 可以不设置资源限制
```

```bash
# 应该成功创建（因为namespaceSelector不匹配）
kubectl apply -f test-pod-dev.yaml
kubectl get pod dev-pod -n development
```

### 14.2.7 实战案例：多策略验证Webhook

**场景**：实现一个综合性的Webhook，支持多种策略验证。

**增强的验证器实现**：

```go
// pkg/webhook/advanced_validator.go
package webhook

import (
    "fmt"
    "regexp"
    "strings"

    corev1 "k8s.io/api/core/v1"
    "k8s.io/apimachinery/pkg/api/resource"
)

// AdvancedPodValidator 高级Pod验证器
type AdvancedPodValidator struct {
    // 镜像策略
    AllowedRegistries []string
    RequireImageScan  bool

    // 资源策略
    RequireResourceLimits bool
    MaxCPU                resource.Quantity
    MaxMemory             resource.Quantity
    CPUMemoryRatio        float64  // CPU:内存比例（如1:4表示1核配4Gi）

    // 安全策略
    DenyPrivileged      bool
    RequireNonRoot      bool
    DenyHostPath        bool
    DenyHostNetwork     bool
    AllowedCapabilities []string

    // 命名策略
    RequiredLabels      []string
    RequiredAnnotations []string
    NamePattern         *regexp.Regexp
}

// Validate 执行全面验证
func (v *AdvancedPodValidator) Validate(pod *corev1.Pod) error {
    // 1. 镜像策略验证
    if err := v.validateImagePolicy(pod); err != nil {
        return err
    }

    // 2. 资源策略验证
    if err := v.validateResourcePolicy(pod); err != nil {
        return err
    }

    // 3. 安全策略验证
    if err := v.validateSecurityPolicy(pod); err != nil {
        return err
    }

    // 4. 命名策略验证
    if err := v.validateNamingPolicy(pod); err != nil {
        return err
    }

    return nil
}

// 验证镜像策略
func (v *AdvancedPodValidator) validateImagePolicy(pod *corev1.Pod) error {
    for _, container := range append(pod.Spec.Containers, pod.Spec.InitContainers...) {
        // 检查镜像仓库
        if !v.isAllowedRegistry(container.Image) {
            return fmt.Errorf(
                "镜像 %s 来自未授权的仓库。允许的仓库：%v",
                container.Image,
                v.AllowedRegistries,
            )
        }

        // 检查镜像标签
        if strings.HasSuffix(container.Image, ":latest") {
            return fmt.Errorf(
                "不允许使用 :latest 标签，请使用具体版本：%s",
                container.Image,
            )
        }

        // 要求镜像扫描（通过注解）
        if v.RequireImageScan {
            if _, ok := pod.Annotations["image-scan-status"]; !ok {
                return fmt.Errorf(
                    "缺少镜像扫描状态注解：image-scan-status",
                )
            }
        }
    }
    return nil
}

// 验证资源策略
func (v *AdvancedPodValidator) validateResourcePolicy(pod *corev1.Pod) error {
    for _, container := range pod.Spec.Containers {
        limits := container.Resources.Limits
        requests := container.Resources.Requests

        // 要求设置资源限制
        if v.RequireResourceLimits {
            if limits.Cpu().IsZero() || limits.Memory().IsZero() {
                return fmt.Errorf(
                    "容器 %s 必须设置CPU和内存限制",
                    container.Name,
                )
            }

            if requests.Cpu().IsZero() || requests.Memory().IsZero() {
                return fmt.Errorf(
                    "容器 %s 必须设置CPU和内存请求",
                    container.Name,
                )
            }
        }

        // 检查资源上限
        if !v.MaxCPU.IsZero() && limits.Cpu().Cmp(v.MaxCPU) > 0 {
            return fmt.Errorf(
                "容器 %s 的CPU限制 %s 超过最大值 %s",
                container.Name,
                limits.Cpu().String(),
                v.MaxCPU.String(),
            )
        }

        if !v.MaxMemory.IsZero() && limits.Memory().Cmp(v.MaxMemory) > 0 {
            return fmt.Errorf(
                "容器 %s 的内存限制 %s 超过最大值 %s",
                container.Name,
                limits.Memory().String(),
                v.MaxMemory.String(),
            )
        }

        // 检查CPU:内存比例
        if v.CPUMemoryRatio > 0 {
            cpuCores := float64(limits.Cpu().MilliValue()) / 1000.0
            memoryGi := float64(limits.Memory().Value()) / (1024 * 1024 * 1024)

            expectedMemory := cpuCores * v.CPUMemoryRatio
            if memoryGi < expectedMemory*0.8 || memoryGi > expectedMemory*1.2 {
                return fmt.Errorf(
                    "容器 %s 的CPU:内存比例不符合要求。CPU: %.2f核, 内存: %.2fGi, 期望比例: 1:%.0f",
                    container.Name,
                    cpuCores,
                    memoryGi,
                    v.CPUMemoryRatio,
                )
            }
        }
    }
    return nil
}

// 验证安全策略
func (v *AdvancedPodValidator) validateSecurityPolicy(pod *corev1.Pod) error {
    // 检查Pod级别安全上下文
    if v.DenyHostNetwork && pod.Spec.HostNetwork {
        return fmt.Errorf("不允许使用宿主机网络（hostNetwork: true）")
    }

    if v.DenyHostPath {
        for _, volume := range pod.Spec.Volumes {
            if volume.HostPath != nil {
                return fmt.Errorf("不允许使用hostPath卷：%s", volume.Name)
            }
        }
    }

    // 检查容器安全上下文
    for _, container := range append(pod.Spec.Containers, pod.Spec.InitContainers...) {
        sc := container.SecurityContext
        if sc == nil {
            if v.RequireNonRoot || v.DenyPrivileged {
                return fmt.Errorf(
                    "容器 %s 必须设置securityContext",
                    container.Name,
                )
            }
            continue
        }

        // 禁止特权容器
        if v.DenyPrivileged && sc.Privileged != nil && *sc.Privileged {
            return fmt.Errorf(
                "容器 %s 不允许使用特权模式",
                container.Name,
            )
        }

        // 要求非root用户
        if v.RequireNonRoot {
            if sc.RunAsNonRoot == nil || !*sc.RunAsNonRoot {
                return fmt.Errorf(
                    "容器 %s 必须以非root用户运行",
                    container.Name,
                )
            }
        }

        // 检查Capabilities
        if sc.Capabilities != nil {
            for _, cap := range sc.Capabilities.Add {
                if !v.isAllowedCapability(string(cap)) {
                    return fmt.Errorf(
                        "容器 %s 不允许添加能力：%s",
                        container.Name,
                        cap,
                    )
                }
            }
        }
    }

    return nil
}

// 验证命名策略
func (v *AdvancedPodValidator) validateNamingPolicy(pod *corev1.Pod) error {
    // 检查命名格式
    if v.NamePattern != nil && !v.NamePattern.MatchString(pod.Name) {
        return fmt.Errorf(
            "Pod名称 %s 不符合命名规范：%s",
            pod.Name,
            v.NamePattern.String(),
        )
    }

    // 检查必需标签
    for _, label := range v.RequiredLabels {
        if _, ok := pod.Labels[label]; !ok {
            return fmt.Errorf("缺少必需的标签：%s", label)
        }
    }

    // 检查必需注解
    for _, annotation := range v.RequiredAnnotations {
        if _, ok := pod.Annotations[annotation]; !ok {
            return fmt.Errorf("缺少必需的注解：%s", annotation)
        }
    }

    return nil
}

// 辅助方法
func (v *AdvancedPodValidator) isAllowedRegistry(image string) bool {
    for _, registry := range v.AllowedRegistries {
        if strings.HasPrefix(image, registry) {
            return true
        }
    }
    return false
}

func (v *AdvancedPodValidator) isAllowedCapability(cap string) bool {
    for _, allowed := range v.AllowedCapabilities {
        if cap == allowed {
            return true
        }
    }
    return false
}
```

**配置示例**：

```go
// main.go
package main

import (
    "log"
    "net/http"
    "regexp"

    "k8s.io/apimachinery/pkg/api/resource"
    "webhook-server/pkg/webhook"
)

func main() {
    // 创建高级验证器
    validator := &webhook.AdvancedPodValidator{
        // 镜像策略
        AllowedRegistries: []string{
            "docker.io/",
            "gcr.io/",
            "registry.example.com/",
        },
        RequireImageScan: true,

        // 资源策略
        RequireResourceLimits: true,
        MaxCPU:                resource.MustParse("4"),     // 最大4核
        MaxMemory:             resource.MustParse("16Gi"),  // 最大16Gi
        CPUMemoryRatio:        4.0,  // 1核:4Gi内存

        // 安全策略
        DenyPrivileged:  true,
        RequireNonRoot:  true,
        DenyHostPath:    true,
        DenyHostNetwork: true,
        AllowedCapabilities: []string{
            "NET_BIND_SERVICE",
            "CHOWN",
            "SETUID",
            "SETGID",
        },

        // 命名策略
        RequiredLabels: []string{
            "app",
            "environment",
            "team",
        },
        RequiredAnnotations: []string{
            "owner",
            "cost-center",
        },
        NamePattern: regexp.MustCompile(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`),
    }

    // 创建服务器
    server := &webhook.WebhookServer{
        Validator: validator,
    }

    http.HandleFunc("/validate-pod", server.ServePodValidation)
    http.HandleFunc("/healthz", server.HealthCheck)

    log.Println("启动Webhook服务器...")
    log.Fatal(http.ListenAndServeTLS(":8443",
        "/etc/webhook/certs/tls.crt",
        "/etc/webhook/certs/tls.key",
        nil))
}
```

### 14.2.8 最佳实践

**1. 性能优化**

```yaml
# 使用objectSelector减少不必要的Webhook调用
objectSelector:
  matchExpressions:
  - key: skip-validation
    operator: DoesNotExist

# 设置合理的超时时间
timeoutSeconds: 5  # 不要太长

# 使用sideEffects声明
sideEffects: None  # 允许并行调用
```

**2. 错误处理**

```go
// 提供详细的错误信息
return admission.Denied(fmt.Sprintf(
    "验证失败：容器 %s 使用了未授权的镜像 %s。\n"+
    "允许的镜像仓库：%v\n"+
    "如需使用其他镜像，请联系安全团队",
    container.Name,
    container.Image,
    v.AllowedRegistries,
))
```

**3. 可观测性**

```go
// 添加结构化日志
log.Printf(
    "验证请求 - Namespace: %s, Pod: %s, Operation: %s, User: %s, Result: %v",
    ar.Request.Namespace,
    pod.Name,
    ar.Request.Operation,
    ar.Request.UserInfo.Username,
    response.Allowed,
)

// 导出Prometheus指标
validationTotal.WithLabelValues(
    ar.Request.Namespace,
    string(ar.Request.Operation),
    fmt.Sprint(response.Allowed),
).Inc()
```

**4. 高可用性**

```yaml
# 部署多副本
replicas: 3

# 设置Pod反亲和性
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchLabels:
            app: webhook-server
        topologyKey: kubernetes.io/hostname

# 设置PodDisruptionBudget
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: webhook-server-pdb
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: webhook-server
```

**5. 渐进式部署**

```yaml
# 阶段1：开发环境测试
namespaceSelector:
  matchLabels:
    environment: development
failurePolicy: Ignore  # 开发环境允许失败

# 阶段2：预生产环境
namespaceSelector:
  matchLabels:
    environment: staging
failurePolicy: Fail  # 严格模式

# 阶段3：生产环境
namespaceSelector:
  matchLabels:
    environment: production
failurePolicy: Fail
```

### 14.2.9 故障排查

**常见问题和解决方案**：

**问题1：Webhook超时**

```bash
# 症状
Error from server (InternalError): Internal error occurred:
failed calling webhook "pod-policy.example.com":
Post "https://webhook-server.webhook-system.svc:443/validate-pod?timeout=10s":
context deadline exceeded

# 排查步骤
# 1. 检查Webhook服务状态
kubectl get pods -n webhook-system
kubectl get svc -n webhook-system
kubectl get endpoints -n webhook-system

# 2. 检查Webhook日志
kubectl logs -n webhook-system -l app=webhook-server --tail=100

# 3. 测试服务连通性
kubectl run test-pod --image=busybox --rm -it --restart=Never -- \
  wget -O- https://webhook-server.webhook-system.svc:443/healthz --no-check-certificate

# 4. 增加超时时间（临时方案）
kubectl edit validatingwebhookconfiguration pod-policy-webhook
# 修改 timeoutSeconds: 30

# 解决方案
- 优化Webhook验证逻辑
- 增加Webhook副本数
- 检查网络策略是否阻止连接
```

**问题2：证书错误**

```bash
# 症状
Error from server (InternalError): Internal error occurred:
failed calling webhook "pod-policy.example.com":
Post "https://webhook-server.webhook-system.svc:443/validate-pod":
x509: certificate signed by unknown authority

# 排查步骤
# 1. 检查caBundle是否正确设置
kubectl get validatingwebhookconfiguration pod-policy-webhook -o yaml | grep caBundle

# 2. 检查Secret中的证书
kubectl get secret webhook-server-tls -n webhook-system -o yaml

# 3. 验证证书有效期
kubectl get secret webhook-server-tls -n webhook-system -o jsonpath='{.data.tls\.crt}' | \
  base64 -d | openssl x509 -noout -dates

# 解决方案
- 重新生成证书
- 确保caBundle与tls.crt的CA一致
- 使用cert-manager自动管理证书
```

**问题3：Webhook被意外调用**

```bash
# 症状
开发环境的Pod也被Webhook拦截了

# 排查步骤
kubectl get validatingwebhookconfiguration pod-policy-webhook -o yaml | \
  grep -A 5 namespaceSelector

# 解决方案
# 配置正确的namespaceSelector
namespaceSelector:
  matchLabels:
    environment: production
```

**问题4：无法删除ValidatingWebhookConfiguration**

```bash
# 症状
kubectl delete validatingwebhookconfiguration pod-policy-webhook
# 卡住不动

# 原因：存在Finalizer

# 解决方案
kubectl patch validatingwebhookconfiguration pod-policy-webhook \
  -p '{"metadata":{"finalizers":[]}}' --type=merge
```

---

## 14.3 Mutating Webhook

### 14.3.1 Mutating Webhook概述

**什么是Mutating Webhook？**

Mutating Webhook是一种动态准入控制器，允许你在对象持久化到etcd之前**修改**请求对象。它在Validating Webhook之前执行，可以自动为资源添加默认值、注入Sidecar容器、添加标签和注解等。

**工作流程**：

```
Mutating Webhook执行流程：
┌────────────────────────────────────────────┐
│  1. API Server接收创建/更新请求            │
│     kubectl apply -f pod.yaml              │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  2. 通过认证和授权                         │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  3. API Server调用Mutating Webhook         │
│     按顺序执行（串行）                      │
│     POST https://webhook-svc/mutate        │
│     {                                      │
│       "request": {                         │
│         "object": {                        │
│           "metadata": {                    │
│             "name": "my-pod"               │
│           },                               │
│           "spec": {...}                    │
│         }                                  │
│       }                                    │
│     }                                      │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  4. Webhook修改对象                        │
│     - 添加标签和注解                       │
│     - 注入Sidecar容器                      │
│     - 设置默认资源限制                     │
│     - 添加环境变量                         │
│     - 设置Volume                           │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  5. Webhook返回修改后的对象                │
│     {                                      │
│       "response": {                        │
│         "allowed": true,                   │
│         "patchType": "JSONPatch",          │
│         "patch": "W3sib3AiOi..."           │
│       }                                    │
│     }                                      │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  6. API Server应用Patch                    │
│     将修改合并到原始对象                   │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  7. Schema验证                             │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  8. Validating Admission                   │
└────────────────────────────────────────────┘
                ↓
┌────────────────────────────────────────────┐
│  9. 持久化到etcd                           │
└────────────────────────────────────────────┘
```

**Mutating vs Validating 对比**：

| 特性 | Mutating Webhook | Validating Webhook |
|------|-----------------|-------------------|
| **执行顺序** | 先执行 | 后执行 |
| **执行方式** | 串行（顺序执行） | 并行（同时执行） |
| **主要功能** | 修改对象 | 验证对象 |
| **修改能力** | ✅ 可以修改 | ❌ 不能修改 |
| **返回内容** | JSONPatch或修改后的对象 | 允许/拒绝 |
| **典型场景** | 注入Sidecar、设置默认值 | 策略验证、合规检查 |
| **执行顺序影响** | 后续Webhook可以看到前面的修改 | 无顺序依赖 |

**使用场景**：

```
Mutating Webhook典型应用场景：
┌────────────────────────────────────────────┐
│  自动注入                                   │
│  ├─ 注入Sidecar容器（Istio、Linkerd）      │
│  ├─ 注入Init容器（配置初始化）             │
│  ├─ 注入Volume（ConfigMap、Secret）        │
│  └─ 注入环境变量（集群信息、元数据）       │
├────────────────────────────────────────────┤
│  设置默认值                                 │
│  ├─ 默认资源限制（requests/limits）        │
│  ├─ 默认镜像拉取策略                       │
│  ├─ 默认重启策略                           │
│  └─ 默认DNS策略                            │
├────────────────────────────────────────────┤
│  自动标签和注解                             │
│  ├─ 添加环境标签（prod/staging/dev）       │
│  ├─ 添加团队标签（team/owner）             │
│  ├─ 添加成本中心标签                       │
│  └─ 添加监控注解（Prometheus）             │
├────────────────────────────────────────────┤
│  安全加固                                   │
│  ├─ 自动设置SecurityContext                │
│  ├─ 添加NetworkPolicy                      │
│  ├─ 设置PodSecurityPolicy                  │
│  └─ 注入CA证书                             │
├────────────────────────────────────────────┤
│  运维自动化                                 │
│  ├─ 自动设置亲和性和反亲和性               │
│  ├─ 自动添加容忍度                         │
│  ├─ 自动配置节点选择器                     │
│  └─ 自动设置优先级                         │
└────────────────────────────────────────────┘
```

### 14.3.2 MutatingWebhookConfiguration资源

**资源定义**：

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: pod-mutator
  annotations:
    cert-manager.io/inject-ca-from: webhook-system/webhook-server-cert
webhooks:
- name: pod-mutator.example.com
  # Webhook调用地址
  clientConfig:
    service:
      namespace: webhook-system
      name: webhook-server
      path: /mutate-pod
      port: 443
    caBundle: ${CA_BUNDLE}

  # 匹配规则
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
    scope: "Namespaced"

  # Namespace选择器
  namespaceSelector:
    matchLabels:
      mutating-webhook: enabled

  # 对象选择器
  objectSelector:
    matchExpressions:
    - key: skip-mutation
      operator: DoesNotExist

  # 失败策略
  failurePolicy: Fail  # Fail或Ignore

  # 匹配策略
  matchPolicy: Equivalent

  # 副作用声明
  sideEffects: None

  # 超时时间
  timeoutSeconds: 10

  # 准入审查版本
  admissionReviewVersions: ["v1", "v1beta1"]

  # 重新调用策略（重要！）
  reinvocationPolicy: IfNeeded  # Never: 不重新调用
                                 # IfNeeded: 如果对象被后续Webhook修改则重新调用
```

**重要参数详解**：

**1. reinvocationPolicy（重新调用策略）**

```yaml
# 场景：多个Mutating Webhook修改同一对象

# Never（默认）：每个Webhook只调用一次
reinvocationPolicy: Never

# 执行顺序：
# Webhook A: 添加标签 app=myapp
# Webhook B: 添加标签 env=prod（看到A的修改）
# Webhook A: 不会再次调用

# IfNeeded：如果对象被修改，则重新调用
reinvocationPolicy: IfNeeded

# 执行顺序：
# Webhook A: 添加标签 app=myapp
# Webhook B: 添加标签 env=prod
# Webhook A: 重新调用（因为对象被B修改了）
# （最多重新调用一次）
```

**2. objectSelector（对象选择器）**

```yaml
# 示例1：只修改带特定标签的Pod
objectSelector:
  matchLabels:
    inject-sidecar: "true"

# 示例2：跳过系统Pod
objectSelector:
  matchExpressions:
  - key: skip-mutation
    operator: DoesNotExist
  - key: app
    operator: NotIn
    values: ["kube-proxy", "kube-dns"]
```

**完整示例：Sidecar注入Webhook**

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: sidecar-injector
  annotations:
    cert-manager.io/inject-ca-from: webhook-system/webhook-server-cert
webhooks:
- name: sidecar-injector.example.com
  clientConfig:
    service:
      namespace: webhook-system
      name: webhook-server
      path: /inject-sidecar
      port: 443

  rules:
  - operations: ["CREATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]

  # 只在标记了注入标签的Namespace中生效
  namespaceSelector:
    matchLabels:
      sidecar-injection: enabled

  # 允许Pod通过标签选择退出注入
  objectSelector:
    matchExpressions:
    - key: sidecar-injection
      operator: NotIn
      values: ["disabled"]

  failurePolicy: Fail
  sideEffects: None
  timeoutSeconds: 10
  admissionReviewVersions: ["v1"]
  reinvocationPolicy: Never  # Sidecar注入不需要重新调用
```

### 14.3.3 JSONPatch响应格式

Mutating Webhook通过**JSONPatch**格式返回修改。

**JSONPatch操作类型**：

```json
// 1. add - 添加字段
{
  "op": "add",
  "path": "/metadata/labels/env",
  "value": "production"
}

// 2. remove - 删除字段
{
  "op": "remove",
  "path": "/metadata/labels/old-label"
}

// 3. replace - 替换字段
{
  "op": "replace",
  "path": "/spec/containers/0/image",
  "value": "nginx:1.21"
}

// 4. copy - 复制字段
{
  "op": "copy",
  "from": "/metadata/labels/app",
  "path": "/metadata/labels/application"
}

// 5. move - 移动字段
{
  "op": "move",
  "from": "/metadata/labels/old-name",
  "path": "/metadata/labels/new-name"
}

// 6. test - 测试字段值（前置条件）
{
  "op": "test",
  "path": "/metadata/labels/env",
  "value": "production"
}
```

**完整的AdmissionResponse示例**：

```json
{
  "apiVersion": "admission.k8s.io/v1",
  "kind": "AdmissionReview",
  "response": {
    "uid": "request-uid-from-request",
    "allowed": true,
    "patchType": "JSONPatch",
    "patch": "W3sib3AiOiJhZGQiLCJwYXRoIjoiL21ldGFkYXRhL2xhYmVscy9lbnYiLCJ2YWx1ZSI6InByb2R1Y3Rpb24ifV0=",
    "status": {
      "message": "Successfully mutated"
    }
  }
}
```

**patch字段说明**：
- `patch`是Base64编码的JSONPatch数组
- 解码后：`[{"op":"add","path":"/metadata/labels/env","value":"production"}]`

### 14.3.4 Webhook服务端实现

**项目结构**：

```
mutating-webhook/
├── main.go
├── pkg/
│   ├── webhook/
│   │   ├── server.go      # HTTP服务器
│   │   ├── mutator.go     # 变更逻辑
│   │   └── patch.go       # JSONPatch构建
│   └── admission/
│       └── types.go
├── deploy/
│   ├── deployment.yaml
│   ├── service.yaml
│   └── webhook-config.yaml
└── Dockerfile
```

**1. JSONPatch构建工具**

```go
// pkg/webhook/patch.go
package webhook

import (
    "encoding/json"
)

// PatchOperation JSONPatch操作
type PatchOperation struct {
    Op    string      `json:"op"`
    Path  string      `json:"path"`
    Value interface{} `json:"value,omitempty"`
}

// CreatePatch 创建JSONPatch
func CreatePatch(patches []PatchOperation) ([]byte, error) {
    return json.Marshal(patches)
}

// AddLabel 添加标签
func AddLabel(key, value string) PatchOperation {
    return PatchOperation{
        Op:    "add",
        Path:  "/metadata/labels/" + escapeJSONPointer(key),
        Value: value,
    }
}

// AddAnnotation 添加注解
func AddAnnotation(key, value string) PatchOperation {
    return PatchOperation{
        Op:    "add",
        Path:  "/metadata/annotations/" + escapeJSONPointer(key),
        Value: value,
    }
}

// AddContainer 添加容器
func AddContainer(index int, container interface{}) PatchOperation {
    path := "/spec/containers"
    if index >= 0 {
        path = path + "/" + string(rune(index))
    } else {
        path = path + "/-"  // 添加到数组末尾
    }
    return PatchOperation{
        Op:    "add",
        Path:  path,
        Value: container,
    }
}

// AddInitContainer 添加Init容器
func AddInitContainer(container interface{}) PatchOperation {
    return PatchOperation{
        Op:    "add",
        Path:  "/spec/initContainers/-",
        Value: container,
    }
}

// AddVolume 添加Volume
func AddVolume(volume interface{}) PatchOperation {
    return PatchOperation{
        Op:    "add",
        Path:  "/spec/volumes/-",
        Value: volume,
    }
}

// AddVolumeMount 添加VolumeMount到容器
func AddVolumeMount(containerIndex int, volumeMount interface{}) PatchOperation {
    return PatchOperation{
        Op:    "add",
        Path:  "/spec/containers/" + string(rune(containerIndex)) + "/volumeMounts/-",
        Value: volumeMount,
    }
}

// SetResourceLimits 设置资源限制
func SetResourceLimits(containerIndex int, limits interface{}) PatchOperation {
    return PatchOperation{
        Op:    "add",
        Path:  "/spec/containers/" + string(rune(containerIndex)) + "/resources/limits",
        Value: limits,
    }
}

// SetResourceRequests 设置资源请求
func SetResourceRequests(containerIndex int, requests interface{}) PatchOperation {
    return PatchOperation{
        Op:    "add",
        Path:  "/spec/containers/" + string(rune(containerIndex)) + "/resources/requests",
        Value: requests,
    }
}

// escapeJSONPointer 转义JSONPointer特殊字符
func escapeJSONPointer(s string) string {
    // JSON Pointer规范：~ 转义为 ~0，/ 转义为 ~1
    s = string([]rune(s))  // 简化处理
    return s
}
```

**2. 实现Mutator逻辑**

```go
// pkg/webhook/mutator.go
package webhook

import (
    "encoding/json"
    "fmt"
    "strings"

    corev1 "k8s.io/api/core/v1"
    "k8s.io/apimachinery/pkg/api/resource"
)

// PodMutator Pod变更器
type PodMutator struct {
    // Sidecar配置
    SidecarImage      string
    SidecarCPU        string
    SidecarMemory     string

    // 默认资源配置
    DefaultCPURequest    string
    DefaultCPULimit      string
    DefaultMemoryRequest string
    DefaultMemoryLimit   string

    // 自动标签
    AutoLabels map[string]string

    // 自动注解
    AutoAnnotations map[string]string
}

// MutatePod 变更Pod
func (m *PodMutator) MutatePod(pod *corev1.Pod) ([]byte, error) {
    var patches []PatchOperation

    // 1. 确保labels和annotations存在
    if pod.Labels == nil {
        patches = append(patches, PatchOperation{
            Op:    "add",
            Path:  "/metadata/labels",
            Value: map[string]string{},
        })
    }
    if pod.Annotations == nil {
        patches = append(patches, PatchOperation{
            Op:    "add",
            Path:  "/metadata/annotations",
            Value: map[string]string{},
        })
    }

    // 2. 添加自动标签
    for key, value := range m.AutoLabels {
        // 检查是否已存在
        if _, exists := pod.Labels[key]; !exists {
            patches = append(patches, AddLabel(key, value))
        }
    }

    // 3. 添加自动注解
    for key, value := range m.AutoAnnotations {
        if _, exists := pod.Annotations[key]; !exists {
            patches = append(patches, AddAnnotation(key, value))
        }
    }

    // 4. 注入Sidecar容器
    if m.shouldInjectSidecar(pod) {
        sidecarPatches, err := m.injectSidecar(pod)
        if err != nil {
            return nil, err
        }
        patches = append(patches, sidecarPatches...)
    }

    // 5. 设置默认资源限制
    resourcePatches := m.setDefaultResources(pod)
    patches = append(patches, resourcePatches...)

    // 6. 创建JSONPatch
    return CreatePatch(patches)
}

// 判断是否需要注入Sidecar
func (m *PodMutator) shouldInjectSidecar(pod *corev1.Pod) bool {
    // 检查标签
    if val, ok := pod.Labels["sidecar-injection"]; ok && val == "disabled" {
        return false
    }

    // 检查注解
    if val, ok := pod.Annotations["sidecar-injection"]; ok && val == "disabled" {
        return false
    }

    // 检查是否已经注入过
    for _, container := range pod.Spec.Containers {
        if container.Name == "sidecar" {
            return false
        }
    }

    return true
}

// 注入Sidecar容器
func (m *PodMutator) injectSidecar(pod *corev1.Pod) ([]PatchOperation, error) {
    var patches []PatchOperation

    // 构建Sidecar容器
    sidecar := corev1.Container{
        Name:  "sidecar",
        Image: m.SidecarImage,
        Ports: []corev1.ContainerPort{
            {
                Name:          "metrics",
                ContainerPort: 9090,
                Protocol:      corev1.ProtocolTCP,
            },
        },
        Resources: corev1.ResourceRequirements{
            Requests: corev1.ResourceList{
                corev1.ResourceCPU:    resource.MustParse(m.SidecarCPU),
                corev1.ResourceMemory: resource.MustParse(m.SidecarMemory),
            },
            Limits: corev1.ResourceList{
                corev1.ResourceCPU:    resource.MustParse(m.SidecarCPU),
                corev1.ResourceMemory: resource.MustParse(m.SidecarMemory),
            },
        },
    }

    // 添加Sidecar容器
    patches = append(patches, AddContainer(-1, sidecar))

    // 添加共享Volume（如果需要）
    sharedVolume := corev1.Volume{
        Name: "shared-data",
        VolumeSource: corev1.VolumeSource{
            EmptyDir: &corev1.EmptyDirVolumeSource{},
        },
    }

    // 检查volumes字段是否存在
    if pod.Spec.Volumes == nil {
        patches = append(patches, PatchOperation{
            Op:    "add",
            Path:  "/spec/volumes",
            Value: []corev1.Volume{},
        })
    }
    patches = append(patches, AddVolume(sharedVolume))

    return patches, nil
}

// 设置默认资源限制
func (m *PodMutator) setDefaultResources(pod *corev1.Pod) []PatchOperation {
    var patches []PatchOperation

    for i, container := range pod.Spec.Containers {
        // 跳过已设置资源的容器
        if container.Resources.Limits != nil && container.Resources.Requests != nil {
            continue
        }

        // 确保resources字段存在
        if container.Resources.Limits == nil && container.Resources.Requests == nil {
            patches = append(patches, PatchOperation{
                Op:   "add",
                Path: fmt.Sprintf("/spec/containers/%d/resources", i),
                Value: corev1.ResourceRequirements{
                    Requests: corev1.ResourceList{},
                    Limits:   corev1.ResourceList{},
                },
            })
        }

        // 设置默认requests
        if container.Resources.Requests.Cpu().IsZero() {
            patches = append(patches, PatchOperation{
                Op:    "add",
                Path:  fmt.Sprintf("/spec/containers/%d/resources/requests/cpu", i),
                Value: m.DefaultCPURequest,
            })
        }
        if container.Resources.Requests.Memory().IsZero() {
            patches = append(patches, PatchOperation{
                Op:    "add",
                Path:  fmt.Sprintf("/spec/containers/%d/resources/requests/memory", i),
                Value: m.DefaultMemoryRequest,
            })
        }

        // 设置默认limits
        if container.Resources.Limits.Cpu().IsZero() {
            patches = append(patches, PatchOperation{
                Op:    "add",
                Path:  fmt.Sprintf("/spec/containers/%d/resources/limits/cpu", i),
                Value: m.DefaultCPULimit,
            })
        }
        if container.Resources.Limits.Memory().IsZero() {
            patches = append(patches, PatchOperation{
                Op:    "add",
                Path:  fmt.Sprintf("/spec/containers/%d/resources/limits/memory", i),
                Value: m.DefaultMemoryLimit,
            })
        }
    }

    return patches
}
```

**3. 实现HTTP服务器**

```go
// pkg/webhook/server.go
package webhook

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"

    admissionv1 "k8s.io/api/admission/v1"
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// MutatingWebhookServer Mutating Webhook服务器
type MutatingWebhookServer struct {
    Mutator *PodMutator
}

// ServePodMutation 处理Pod变更请求
func (s *MutatingWebhookServer) ServePodMutation(w http.ResponseWriter, r *http.Request) {
    log.Println("收到变更请求")

    // 1. 读取请求体
    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
        log.Printf("读取请求失败: %v", err)
        http.Error(w, "无法读取请求", http.StatusBadRequest)
        return
    }
    defer r.Body.Close()

    // 2. 解析AdmissionReview
    ar := &admissionv1.AdmissionReview{}
    if err := json.Unmarshal(body, ar); err != nil {
        log.Printf("解析AdmissionReview失败: %v", err)
        http.Error(w, "无效的AdmissionReview", http.StatusBadRequest)
        return
    }

    // 3. 验证请求
    if ar.Request == nil {
        log.Println("AdmissionReview.Request为空")
        http.Error(w, "无效的请求", http.StatusBadRequest)
        return
    }

    // 4. 解析Pod对象
    pod := &corev1.Pod{}
    if err := json.Unmarshal(ar.Request.Object.Raw, pod); err != nil {
        log.Printf("解析Pod失败: %v", err)
        response := &admissionv1.AdmissionResponse{
            UID:     ar.Request.UID,
            Allowed: false,
            Result: &metav1.Status{
                Message: fmt.Sprintf("无法解析Pod: %v", err),
            },
        }
        s.writeResponse(w, ar, response)
        return
    }

    log.Printf("变更Pod: %s/%s", pod.Namespace, pod.Name)

    // 5. 执行变更
    patchBytes, err := s.Mutator.MutatePod(pod)
    if err != nil {
        log.Printf("变更Pod失败: %v", err)
        response := &admissionv1.AdmissionResponse{
            UID:     ar.Request.UID,
            Allowed: false,
            Result: &metav1.Status{
                Message: fmt.Sprintf("变更失败: %v", err),
            },
        }
        s.writeResponse(w, ar, response)
        return
    }

    // 6. 构建响应
    patchType := admissionv1.PatchTypeJSONPatch
    response := &admissionv1.AdmissionResponse{
        UID:       ar.Request.UID,
        Allowed:   true,
        PatchType: &patchType,
        Patch:     patchBytes,
    }

    log.Printf("成功变更Pod，Patch大小: %d bytes", len(patchBytes))

    // 7. 返回响应
    s.writeResponse(w, ar, response)
}

// writeResponse 写入响应
func (s *MutatingWebhookServer) writeResponse(
    w http.ResponseWriter,
    ar *admissionv1.AdmissionReview,
    response *admissionv1.AdmissionResponse,
) {
    ar.Response = response

    respBytes, err := json.Marshal(ar)
    if err != nil {
        log.Printf("序列化响应失败: %v", err)
        http.Error(w, "无法序列化响应", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    w.Write(respBytes)
}

// HealthCheck 健康检查
func (s *MutatingWebhookServer) HealthCheck(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, "OK")
}
```

**4. 主程序**

```go
// main.go
package main

import (
    "log"
    "net/http"

    "mutating-webhook/pkg/webhook"
)

func main() {
    // 创建Mutator
    mutator := &webhook.PodMutator{
        // Sidecar配置
        SidecarImage:  "envoyproxy/envoy:v1.24.0",
        SidecarCPU:    "100m",
        SidecarMemory: "128Mi",

        // 默认资源配置
        DefaultCPURequest:    "100m",
        DefaultCPULimit:      "500m",
        DefaultMemoryRequest: "128Mi",
        DefaultMemoryLimit:   "512Mi",

        // 自动标签
        AutoLabels: map[string]string{
            "injected-by":   "mutating-webhook",
            "webhook-version": "v1.0.0",
        },

        // 自动注解
        AutoAnnotations: map[string]string{
            "mutation-timestamp": "auto",
            "mutated":            "true",
        },
    }

    // 创建服务器
    server := &webhook.MutatingWebhookServer{
        Mutator: mutator,
    }

    // 注册路由
    http.HandleFunc("/mutate-pod", server.ServePodMutation)
    http.HandleFunc("/healthz", server.HealthCheck)

    // 启动HTTPS服务器
    log.Println("启动Mutating Webhook服务器，监听端口 8443...")
    err := http.ListenAndServeTLS(
        ":8443",
        "/etc/webhook/certs/tls.crt",
        "/etc/webhook/certs/tls.key",
        nil,
    )
    if err != nil {
        log.Fatalf("启动服务器失败: %v", err)
    }
}
```

### 14.3.5 部署Mutating Webhook

**1. Deployment配置**

```yaml
# deploy/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mutating-webhook
  namespace: webhook-system
  labels:
    app: mutating-webhook
spec:
  replicas: 2
  selector:
    matchLabels:
      app: mutating-webhook
  template:
    metadata:
      labels:
        app: mutating-webhook
    spec:
      containers:
      - name: webhook
        image: registry.example.com/mutating-webhook:v1.0.0
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8443
          name: webhook
          protocol: TCP
        volumeMounts:
        - name: webhook-certs
          mountPath: /etc/webhook/certs
          readOnly: true
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8443
            scheme: HTTPS
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /healthz
            port: 8443
            scheme: HTTPS
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: webhook-certs
        secret:
          secretName: webhook-server-tls
---
apiVersion: v1
kind: Service
metadata:
  name: mutating-webhook
  namespace: webhook-system
  labels:
    app: mutating-webhook
spec:
  selector:
    app: mutating-webhook
  ports:
  - port: 443
    targetPort: 8443
    protocol: TCP
    name: webhook
  type: ClusterIP
```

**2. MutatingWebhookConfiguration**

```yaml
# deploy/webhook-config.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: pod-mutator
  annotations:
    cert-manager.io/inject-ca-from: webhook-system/webhook-server-cert
webhooks:
- name: pod-mutator.example.com
  clientConfig:
    service:
      namespace: webhook-system
      name: mutating-webhook
      path: /mutate-pod
      port: 443

  rules:
  - operations: ["CREATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]

  # 在所有启用了sidecar-injection的Namespace中生效
  namespaceSelector:
    matchLabels:
      sidecar-injection: enabled

  # 允许Pod选择退出
  objectSelector:
    matchExpressions:
    - key: sidecar-injection
      operator: NotIn
      values: ["disabled"]

  failurePolicy: Fail
  sideEffects: None
  timeoutSeconds: 10
  admissionReviewVersions: ["v1"]
  reinvocationPolicy: Never
```

**3. 部署步骤**

```bash
# 1. 确保webhook-system命名空间存在
kubectl create namespace webhook-system

# 2. 确保证书Secret存在（使用cert-manager或手动创建）
kubectl get secret webhook-server-tls -n webhook-system

# 3. 部署Webhook服务
kubectl apply -f deploy/deployment.yaml

# 4. 检查部署状态
kubectl get pods -n webhook-system
kubectl get svc -n webhook-system

# 5. 检查日志
kubectl logs -n webhook-system -l app=mutating-webhook -f

# 6. 创建MutatingWebhookConfiguration
kubectl apply -f deploy/webhook-config.yaml

# 7. 检查配置
kubectl get mutatingwebhookconfiguration pod-mutator
kubectl describe mutatingwebhookconfiguration pod-mutator
```

### 14.3.6 测试Mutating Webhook

**1. 准备测试Namespace**

```bash
# 创建测试Namespace并启用Sidecar注入
kubectl create namespace test-mutation
kubectl label namespace test-mutation sidecar-injection=enabled

# 检查标签
kubectl get namespace test-mutation --show-labels
```

**2. 测试用例1：自动注入Sidecar**

```yaml
# test-pod-basic.yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod-basic
  namespace: test-mutation
  labels:
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    ports:
    - containerPort: 80
```

```bash
# 应用Pod
kubectl apply -f test-pod-basic.yaml

# 检查Pod（应该看到注入的Sidecar容器）
kubectl get pod test-pod-basic -n test-mutation -o jsonpath='{.spec.containers[*].name}'
# 输出: nginx sidecar

# 检查标签（应该看到自动添加的标签）
kubectl get pod test-pod-basic -n test-mutation -o jsonpath='{.metadata.labels}'

# 检查完整配置
kubectl get pod test-pod-basic -n test-mutation -o yaml
```

**预期结果**：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod-basic
  namespace: test-mutation
  labels:
    app: nginx
    injected-by: mutating-webhook  # 自动添加
    webhook-version: v1.0.0         # 自动添加
  annotations:
    mutation-timestamp: auto        # 自动添加
    mutated: "true"                 # 自动添加
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    ports:
    - containerPort: 80
    resources:  # 自动添加默认资源
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi
  - name: sidecar  # 自动注入
    image: envoyproxy/envoy:v1.24.0
    ports:
    - name: metrics
      containerPort: 9090
      protocol: TCP
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 100m
        memory: 128Mi
  volumes:
  - name: shared-data  # 自动添加
    emptyDir: {}
```

**3. 测试用例2：选择退出注入**

```yaml
# test-pod-opt-out.yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod-opt-out
  namespace: test-mutation
  labels:
    app: nginx
    sidecar-injection: disabled  # 选择退出
spec:
  containers:
  - name: nginx
    image: nginx:1.21
```

```bash
kubectl apply -f test-pod-opt-out.yaml

# 检查容器（不应该有sidecar）
kubectl get pod test-pod-opt-out -n test-mutation -o jsonpath='{.spec.containers[*].name}'
# 输出: nginx

# 但应该有自动标签和默认资源
kubectl get pod test-pod-opt-out -n test-mutation -o yaml | grep -A 5 labels
kubectl get pod test-pod-opt-out -n test-mutation -o yaml | grep -A 10 resources
```

**4. 测试用例3：已有资源配置**

```yaml
# test-pod-with-resources.yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod-with-resources
  namespace: test-mutation
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 1
        memory: 1Gi
```

```bash
kubectl apply -f test-pod-with-resources.yaml

# 检查资源（应该保持原有配置，不被覆盖）
kubectl get pod test-pod-with-resources -n test-mutation -o yaml | grep -A 10 resources
```

**5. 在未启用注入的Namespace测试**

```bash
# 创建未启用注入的Namespace
kubectl create namespace no-injection

# 部署相同的Pod
kubectl apply -f test-pod-basic.yaml -n no-injection

# 检查（不应该有Sidecar）
kubectl get pod test-pod-basic -n no-injection -o jsonpath='{.spec.containers[*].name}'
# 输出: nginx
```

**6. 查看Webhook日志**

```bash
# 查看变更日志
kubectl logs -n webhook-system -l app=mutating-webhook --tail=50

# 应该看到类似输出：
# 收到变更请求
# 变更Pod: test-mutation/test-pod-basic
# 成功变更Pod，Patch大小: 1234 bytes
```

### 14.3.7 高级实战：Istio风格的Sidecar注入

**场景**：实现类似Istio的智能Sidecar注入，支持多种配置选项。

**增强的Mutator实现**：

```go
// pkg/webhook/istio_mutator.go
package webhook

import (
    "encoding/json"
    "fmt"
    "strconv"

    corev1 "k8s.io/api/core/v1"
    "k8s.io/apimachinery/pkg/api/resource"
)

// IstioMutator Istio风格的Mutator
type IstioMutator struct {
    // Sidecar镜像配置
    ProxyImage       string
    ProxyImageTag    string
    InitImage        string
    InitImageTag     string

    // 默认资源配置
    ProxyCPURequest    string
    ProxyCPULimit      string
    ProxyMemoryRequest string
    ProxyMemoryLimit   string

    // 网络配置
    InterceptMode     string  // REDIRECT, TPROXY
    IncludePorts      string  // "80,443,8080"
    ExcludePorts      string  // "15020,15021"
    IncludeIPRanges   string
    ExcludeIPRanges   string

    // 其他配置
    ProxyLogLevel     string
    StatusPort        int
    PrometheusPort    int
}

// MutatePod 注入Istio Sidecar
func (m *IstioMutator) MutatePod(pod *corev1.Pod) ([]byte, error) {
    var patches []PatchOperation

    // 1. 检查是否需要注入
    if !m.shouldInject(pod) {
        return json.Marshal([]PatchOperation{})
    }

    // 2. 确保metadata字段存在
    patches = append(patches, m.ensureMetadataFields(pod)...)

    // 3. 添加注解
    patches = append(patches, m.addAnnotations(pod)...)

    // 4. 注入Init容器（配置iptables规则）
    initPatches, err := m.injectInitContainer(pod)
    if err != nil {
        return nil, err
    }
    patches = append(patches, initPatches...)

    // 5. 注入Proxy Sidecar
    proxyPatches, err := m.injectProxySidecar(pod)
    if err != nil {
        return nil, err
    }
    patches = append(patches, proxyPatches...)

    // 6. 添加Volumes
    patches = append(patches, m.addVolumes(pod)...)

    return CreatePatch(patches)
}

// 判断是否需要注入
func (m *IstioMutator) shouldInject(pod *corev1.Pod) bool {
    // 检查Pod注解
    if val, ok := pod.Annotations["sidecar.istio.io/inject"]; ok {
        if inject, _ := strconv.ParseBool(val); !inject {
            return false
        }
    }

    // 检查是否已经注入
    for _, container := range pod.Spec.Containers {
        if container.Name == "istio-proxy" {
            return false
        }
    }

    return true
}

// 确保metadata字段存在
func (m *IstioMutator) ensureMetadataFields(pod *corev1.Pod) []PatchOperation {
    var patches []PatchOperation

    if pod.Labels == nil {
        patches = append(patches, PatchOperation{
            Op:    "add",
            Path:  "/metadata/labels",
            Value: map[string]string{},
        })
    }

    if pod.Annotations == nil {
        patches = append(patches, PatchOperation{
            Op:    "add",
            Path:  "/metadata/annotations",
            Value: map[string]string{},
        })
    }

    return patches
}

// 添加注解
func (m *IstioMutator) addAnnotations(pod *corev1.Pod) []PatchOperation {
    var patches []PatchOperation

    annotations := map[string]string{
        "sidecar.istio.io/status":             "injected",
        "sidecar.istio.io/interceptionMode":   m.InterceptMode,
        "traffic.sidecar.istio.io/includePorts": m.IncludePorts,
        "traffic.sidecar.istio.io/excludePorts": m.ExcludePorts,
    }

    for key, value := range annotations {
        if _, exists := pod.Annotations[key]; !exists {
            patches = append(patches, AddAnnotation(key, value))
        }
    }

    return patches
}

// 注入Init容器
func (m *IstioMutator) injectInitContainer(pod *corev1.Pod) ([]PatchOperation, error) {
    var patches []PatchOperation

    // 构建istio-init容器
    initContainer := corev1.Container{
        Name:  "istio-init",
        Image: fmt.Sprintf("%s:%s", m.InitImage, m.InitImageTag),
        Args: []string{
            "istio-iptables",
            "-p", "15001",  // Envoy端口
            "-z", "15006",  // Inbound捕获端口
            "-u", "1337",   // Envoy用户ID
            "-m", m.InterceptMode,
            "-i", m.IncludeIPRanges,
            "-x", m.ExcludeIPRanges,
            "-b", m.IncludePorts,
            "-d", m.ExcludePorts,
        },
        SecurityContext: &corev1.SecurityContext{
            Capabilities: &corev1.Capabilities{
                Add: []corev1.Capability{
                    "NET_ADMIN",
                    "NET_RAW",
                },
            },
            RunAsUser:    int64Ptr(0),
            RunAsNonRoot: boolPtr(false),
        },
        Resources: corev1.ResourceRequirements{
            Requests: corev1.ResourceList{
                corev1.ResourceCPU:    resource.MustParse("10m"),
                corev1.ResourceMemory: resource.MustParse("10Mi"),
            },
            Limits: corev1.ResourceList{
                corev1.ResourceCPU:    resource.MustParse("100m"),
                corev1.ResourceMemory: resource.MustParse("50Mi"),
            },
        },
    }

    // 确保initContainers字段存在
    if pod.Spec.InitContainers == nil {
        patches = append(patches, PatchOperation{
            Op:    "add",
            Path:  "/spec/initContainers",
            Value: []corev1.Container{},
        })
    }

    patches = append(patches, AddInitContainer(initContainer))

    return patches, nil
}

// 注入Proxy Sidecar
func (m *IstioMutator) injectProxySidecar(pod *corev1.Pod) ([]PatchOperation, error) {
    var patches []PatchOperation

    // 构建istio-proxy容器
    proxyContainer := corev1.Container{
        Name:  "istio-proxy",
        Image: fmt.Sprintf("%s:%s", m.ProxyImage, m.ProxyImageTag),
        Args: []string{
            "proxy",
            "sidecar",
            "--domain",
            fmt.Sprintf("%s.%s.svc.cluster.local", pod.Name, pod.Namespace),
            "--proxyLogLevel=" + m.ProxyLogLevel,
            "--proxyComponentLogLevel=misc:error",
            "--concurrency=2",
        },
        Ports: []corev1.ContainerPort{
            {
                Name:          "http-envoy-prom",
                ContainerPort: int32(m.PrometheusPort),
                Protocol:      corev1.ProtocolTCP,
            },
            {
                Name:          "status-port",
                ContainerPort: int32(m.StatusPort),
                Protocol:      corev1.ProtocolTCP,
            },
        },
        Env: []corev1.EnvVar{
            {
                Name: "POD_NAME",
                ValueFrom: &corev1.EnvVarSource{
                    FieldRef: &corev1.ObjectFieldSelector{
                        FieldPath: "metadata.name",
                    },
                },
            },
            {
                Name: "POD_NAMESPACE",
                ValueFrom: &corev1.EnvVarSource{
                    FieldRef: &corev1.ObjectFieldSelector{
                        FieldPath: "metadata.namespace",
                    },
                },
            },
            {
                Name: "POD_IP",
                ValueFrom: &corev1.EnvVarSource{
                    FieldRef: &corev1.ObjectFieldSelector{
                        FieldPath: "status.podIP",
                    },
                },
            },
        },
        Resources: corev1.ResourceRequirements{
            Requests: corev1.ResourceList{
                corev1.ResourceCPU:    resource.MustParse(m.ProxyCPURequest),
                corev1.ResourceMemory: resource.MustParse(m.ProxyMemoryRequest),
            },
            Limits: corev1.ResourceList{
                corev1.ResourceCPU:    resource.MustParse(m.ProxyCPULimit),
                corev1.ResourceMemory: resource.MustParse(m.ProxyMemoryLimit),
            },
        },
        SecurityContext: &corev1.SecurityContext{
            RunAsUser:              int64Ptr(1337),
            RunAsNonRoot:           boolPtr(true),
            AllowPrivilegeEscalation: boolPtr(false),
            ReadOnlyRootFilesystem: boolPtr(true),
            Capabilities: &corev1.Capabilities{
                Drop: []corev1.Capability{"ALL"},
            },
        },
        VolumeMounts: []corev1.VolumeMount{
            {
                Name:      "istio-envoy",
                MountPath: "/etc/istio/proxy",
            },
            {
                Name:      "istiod-ca-cert",
                MountPath: "/var/run/secrets/istio",
            },
        },
        ReadinessProbe: &corev1.Probe{
            ProbeHandler: corev1.ProbeHandler{
                HTTPGet: &corev1.HTTPGetAction{
                    Path: "/healthz/ready",
                    Port: intstr.FromInt(m.StatusPort),
                },
            },
            InitialDelaySeconds: 1,
            PeriodSeconds:       2,
            FailureThreshold:    30,
        },
    }

    patches = append(patches, AddContainer(-1, proxyContainer))

    return patches, nil
}

// 添加Volumes
func (m *IstioMutator) addVolumes(pod *corev1.Pod) []PatchOperation {
    var patches []PatchOperation

    volumes := []corev1.Volume{
        {
            Name: "istio-envoy",
            VolumeSource: corev1.VolumeSource{
                EmptyDir: &corev1.EmptyDirVolumeSource{},
            },
        },
        {
            Name: "istiod-ca-cert",
            VolumeSource: corev1.VolumeSource{
                ConfigMap: &corev1.ConfigMapVolumeSource{
                    LocalObjectReference: corev1.LocalObjectReference{
                        Name: "istio-ca-root-cert",
                    },
                },
            },
        },
    }

    // 确保volumes字段存在
    if pod.Spec.Volumes == nil {
        patches = append(patches, PatchOperation{
            Op:    "add",
            Path:  "/spec/volumes",
            Value: []corev1.Volume{},
        })
    }

    for _, volume := range volumes {
        patches = append(patches, AddVolume(volume))
    }

    return patches
}

// 辅助函数
func int64Ptr(i int64) *int64 {
    return &i
}

func boolPtr(b bool) *bool {
    return &b
}
```

**配置示例**：

```go
// main.go
mutator := &webhook.IstioMutator{
    ProxyImage:    "docker.io/istio/proxyv2",
    ProxyImageTag: "1.16.0",
    InitImage:     "docker.io/istio/proxyv2",
    InitImageTag:  "1.16.0",

    ProxyCPURequest:    "100m",
    ProxyCPULimit:      "2000m",
    ProxyMemoryRequest: "128Mi",
    ProxyMemoryLimit:   "1024Mi",

    InterceptMode:   "REDIRECT",
    IncludePorts:    "*",
    ExcludePorts:    "15020,15021",
    IncludeIPRanges: "*",
    ExcludeIPRanges: "",

    ProxyLogLevel:  "warning",
    StatusPort:     15020,
    PrometheusPort: 15090,
}
```

### 14.3.8 最佳实践

**1. Patch顺序和幂等性**

```go
// ✅ 好的做法：先确保字段存在
func (m *Mutator) MutatePod(pod *corev1.Pod) ([]byte, error) {
    var patches []PatchOperation

    // 1. 先确保父字段存在
    if pod.Labels == nil {
        patches = append(patches, PatchOperation{
            Op:    "add",
            Path:  "/metadata/labels",
            Value: map[string]string{},
        })
    }

    // 2. 再添加具体标签
    patches = append(patches, AddLabel("env", "prod"))

    return CreatePatch(patches)
}

// ❌ 错误做法：直接添加可能不存在的字段
patches = append(patches, AddLabel("env", "prod"))  // labels可能不存在
```

**2. 避免修改冲突**

```go
// 检查是否已存在，避免重复添加
if _, exists := pod.Labels["env"]; !exists {
    patches = append(patches, AddLabel("env", "prod"))
}

// 检查容器是否已存在
for _, container := range pod.Spec.Containers {
    if container.Name == "sidecar" {
        return nil, fmt.Errorf("sidecar已存在")
    }
}
```

**3. 使用reinvocationPolicy**

```yaml
# 场景1：Webhook A添加标签，Webhook B基于标签做决策
webhooks:
- name: webhook-a
  reinvocationPolicy: IfNeeded  # 允许重新调用
- name: webhook-b
  reinvocationPolicy: Never     # 不需要重新调用
```

**4. 性能优化**

```go
// ✅ 批量操作，减少Patch数量
patches := []PatchOperation{
    AddLabel("env", "prod"),
    AddLabel("team", "platform"),
    AddLabel("cost-center", "engineering"),
}

// ❌ 多次小批量Patch
for key, value := range labels {
    patch, _ := CreatePatch([]PatchOperation{AddLabel(key, value)})
    // 发送多次请求...
}
```

**5. 错误处理**

```go
// 提供详细的错误信息
if err := m.validatePod(pod); err != nil {
    return nil, fmt.Errorf(
        "Pod验证失败 - Namespace: %s, Name: %s, 原因: %v",
        pod.Namespace, pod.Name, err,
    )
}
```

**6. 可观测性**

```go
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    mutationTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "webhook_mutations_total",
            Help: "Total number of mutations",
        },
        []string{"namespace", "operation", "status"},
    )

    mutationDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "webhook_mutation_duration_seconds",
            Help:    "Duration of mutation operations",
            Buckets: prometheus.DefBuckets,
        },
        []string{"namespace", "operation"},
    )
)

func (m *Mutator) MutatePod(pod *corev1.Pod) ([]byte, error) {
    start := time.Now()
    defer func() {
        duration := time.Since(start).Seconds()
        mutationDuration.WithLabelValues(
            pod.Namespace,
            "mutate_pod",
        ).Observe(duration)
    }()

    // ... 变更逻辑 ...

    mutationTotal.WithLabelValues(
        pod.Namespace,
        "mutate_pod",
        "success",
    ).Inc()

    return patchBytes, nil
}
```

### 14.3.9 故障排查

**问题1：Patch格式错误**

```bash
# 症状
Error from server (InternalError): Internal error occurred:
failed calling webhook "pod-mutator.example.com":
invalid patch

# 原因：JSONPatch格式不正确

# 调试方法
# 1. 在Webhook服务器中打印生成的Patch
log.Printf("Generated patch: %s", string(patchBytes))

# 2. 手动验证Patch格式
echo 'W3sib3AiOi...' | base64 -d | jq .

# 解决方案
- 确保Patch是有效的JSON数组
- 使用json.Marshal确保正确编码
- 测试Patch的Base64编码
```

**问题2：Patch路径不存在**

```bash
# 症状
Error: add operation does not apply: doc is missing path: "/metadata/labels/env"

# 原因：父路径不存在

# 解决方案
# 先确保父路径存在
if pod.Labels == nil {
    patches = append(patches, PatchOperation{
        Op:    "add",
        Path:  "/metadata/labels",
        Value: map[string]string{},
    })
}
```

**问题3：Webhook被多次调用**

```bash
# 症状
Webhook日志显示同一个Pod被调用了多次

# 原因1：reinvocationPolicy设置为IfNeeded

# 检查配置
kubectl get mutatingwebhookconfiguration pod-mutator -o yaml | grep reinvocationPolicy

# 解决方案
reinvocationPolicy: Never  # 如果不需要重新调用

# 原因2：存在多个匹配的Webhook
kubectl get mutatingwebhookconfiguration
```

**问题4：修改被Validating Webhook拒绝**

```bash
# 症状
Mutating Webhook成功修改，但Validating Webhook拒绝

# 调试
# 1. 检查Validating Webhook的规则
kubectl describe validatingwebhookconfiguration

# 2. 查看拒绝原因
kubectl describe pod <pod-name>

# 解决方案
- 确保Mutating Webhook的修改符合Validating Webhook的策略
- 调整Webhook的执行顺序
- 修改对象选择器避免冲突
```

**问题5：无法注入到某些Pod**

```bash
# 症状
部分Pod没有被注入Sidecar

# 排查步骤
# 1. 检查namespaceSelector
kubectl get namespace <namespace> --show-labels

# 2. 检查objectSelector
kubectl get pod <pod-name> -o yaml | grep -A 5 labels

# 3. 检查Webhook日志
kubectl logs -n webhook-system -l app=mutating-webhook --tail=100

# 4. 测试Webhook是否被调用
kubectl apply -f test-pod.yaml -v=8
```

### 14.3.10 实战技巧

**1. 使用dry-run测试**

```bash
# 生成Pod YAML但不创建
kubectl run test-pod --image=nginx --dry-run=client -o yaml > test-pod.yaml

# 使用server-side dry-run测试Webhook
kubectl apply -f test-pod.yaml --dry-run=server -v=8

# 查看变更后的对象
kubectl apply -f test-pod.yaml --dry-run=server -o yaml
```

**2. 渐进式部署**

```yaml
# 阶段1：仅在开发环境启用
namespaceSelector:
  matchLabels:
    environment: development
failurePolicy: Ignore

# 阶段2：扩展到预生产环境
namespaceSelector:
  matchExpressions:
  - key: environment
    operator: In
    values: ["development", "staging"]
failurePolicy: Fail

# 阶段3：生产环境
namespaceSelector:
  matchExpressions:
  - key: environment
    operator: In
    values: ["development", "staging", "production"]
failurePolicy: Fail
```

**3. 版本控制和灰度发布**

```yaml
# 使用objectSelector实现灰度发布
objectSelector:
  matchLabels:
    webhook-version: v2  # 只对标记了v2的Pod生效
```

**4. 监控和告警**

```yaml
# Prometheus告警规则
groups:
- name: webhook
  rules:
  - alert: WebhookHighErrorRate
    expr: |
      sum(rate(webhook_mutations_total{status="error"}[5m]))
      /
      sum(rate(webhook_mutations_total[5m]))
      > 0.05
    for: 5m
    annotations:
      summary: "Webhook错误率过高"

  - alert: WebhookSlowResponse
    expr: |
      histogram_quantile(0.99,
        sum(rate(webhook_mutation_duration_seconds_bucket[5m])) by (le)
      ) > 1
    for: 5m
    annotations:
      summary: "Webhook响应过慢"
```

---

**当前第14章进度**：
- ✅ 14.1 准入控制器原理（完成）
- ✅ 14.2 Validating Webhook（完成）
- ✅ 14.3 Mutating Webhook（完成）
- ⏳ 14.4 OPA (Open Policy Agent)（待编写）
- 📅 14.5 Kyverno策略引擎（待编写）
- 📅 14.6 实战：实施企业级策略管理（待编写）

接下来将继续编写14.4节的内容。
