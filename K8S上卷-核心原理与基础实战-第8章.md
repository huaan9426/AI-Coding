# 第8章 存储管理

在前面的章节中，我们深入学习了Kubernetes的调度与资源管理机制，掌握了如何高效地将Pod调度到合适的节点上，并通过优先级、亲和性、资源配额等手段实现企业级的资源管理。然而，真实的生产环境中，大部分应用都是**有状态应用**（Stateful Application），它们需要持久化存储来保存数据：

- **数据库**：MySQL、PostgreSQL、MongoDB需要持久化数据库文件
- **消息队列**：Kafka、RabbitMQ需要持久化消息数据
- **文件存储**：MinIO、Ceph需要持久化对象存储
- **日志系统**：Elasticsearch需要持久化日志索引
- **配置中心**：etcd、Consul需要持久化配置数据

容器的本质是**进程**，当Pod被删除或重启时，容器内的数据会随之消失。这对于无状态应用（如Web服务器）不是问题，但对于有状态应用却是致命的。Kubernetes通过强大的**存储管理体系**解决了这一难题，提供了从临时存储到企业级分布式存储的完整解决方案。

本章将系统学习Kubernetes的存储管理机制，从基础概念到高级特性，再到企业级实战，构建完整的存储知识体系。

---

## 本章结构

本章共分为8节，逐步深入Kubernetes存储管理的核心技术：

- **8.1 存储基础概念与架构**：理解Kubernetes存储体系的整体架构，掌握Volume、PV、PVC的核心概念
- **8.2 Volume详解**：深入学习emptyDir、hostPath、configMap、secret等基础Volume类型
- **8.3 持久卷（PersistentVolume）**：掌握PV的生命周期、访问模式、回收策略
- **8.4 持久卷声明（PersistentVolumeClaim）**：理解PVC的绑定机制、存储类选择
- **8.5 存储类（StorageClass）**：学习动态存储供应、参数配置、回收策略
- **8.6 StatefulSet与有状态应用**：掌握StatefulSet的存储管理机制、volumeClaimTemplates
- **8.7 CSI存储插件**：理解Container Storage Interface标准，学习云存储集成
- **8.8 实战项目与本章小结**：通过企业级存储方案实战，总结存储管理最佳实践

---

## 8.1 存储基础概念与架构

在深入具体技术之前，我们需要先建立对Kubernetes存储体系的整体认知。本节将回答以下核心问题：

1. **为什么容器需要持久化存储？** 容器数据的生命周期与存储需求
2. **Kubernetes提供了哪些存储方案？** 临时存储、持久化存储、配置存储的分类
3. **PV、PVC、StorageClass的关系是什么？** 存储抽象的三层架构
4. **存储如何与Pod绑定？** Volume挂载的完整流程

---

### 8.1.1 容器存储的挑战

**问题1：容器数据的临时性**

容器的文件系统是基于镜像的分层文件系统（Union FS），容器内的所有写操作都发生在**可写层**（Writable Layer）：

```
容器文件系统层级结构
┌─────────────────────────┐
│  可写层（Container Layer）  │ ← 容器运行时的所有写操作
├─────────────────────────┤
│  镜像层4（ADD app.jar）    │
├─────────────────────────┤
│  镜像层3（RUN apt update） │
├─────────────────────────┤
│  镜像层2（COPY . /app）    │
├─────────────────────────┤
│  镜像层1（FROM ubuntu）    │ ← 只读基础镜像
└─────────────────────────┘
```

**核心问题：**
- ❌ 容器删除时，可写层数据随之消失
- ❌ 容器重启时，数据重置到镜像初始状态
- ❌ 同一Pod内的多个容器无法共享数据
- ❌ Pod迁移到其他节点时，数据无法跟随

**典型场景的数据丢失：**

```bash
# 场景1：Pod重启导致数据丢失
$ kubectl exec mysql-pod -- mysql -e "CREATE DATABASE test;"
$ kubectl delete pod mysql-pod  # Pod被删除
$ kubectl get pod               # 新Pod被ReplicaSet重建
$ kubectl exec mysql-pod -- mysql -e "SHOW DATABASES;"  # test数据库消失！

# 场景2：容器崩溃导致日志丢失
$ kubectl exec nginx-pod -- sh -c "echo 'important log' >> /var/log/access.log"
$ kubectl exec nginx-pod -- kill 1  # 容器崩溃重启
$ kubectl exec nginx-pod -- cat /var/log/access.log  # 日志文件不存在！
```

---

**问题2：有状态应用的复杂需求**

真实的生产环境中，有状态应用有更复杂的存储需求：

| 应用类型 | 存储需求 | 挑战 |
|---------|---------|------|
| **MySQL主从** | - 主库需要独立持久卷<br>- 从库需要只读访问<br>- 数据目录需要固定路径 | 如何为每个实例分配独立存储？<br>如何保证存储的访问模式正确？ |
| **Elasticsearch集群** | - 每个节点需要独立数据目录<br>- 存储需要高IOPS（SSD）<br>- 需要动态扩容 | 如何根据性能需求选择存储类型？<br>如何支持在线扩容？ |
| **Kafka** | - 日志段需要顺序写入<br>- 消费者offset需要持久化<br>- 存储容量需要动态调整 | 如何保证写入性能？<br>如何处理存储容量不足？ |
| **共享文件服务** | - 多个Pod同时读写<br>- 需要文件锁机制<br>- 跨节点访问 | 如何支持ReadWriteMany模式？<br>如何选择合适的网络存储？ |

---

**问题3：传统存储与容器编排的鸿沟**

在容器化之前，存储管理是运维团队的职责：

```
传统模式（手动管理）
运维团队：创建LUN → 格式化 → 挂载到服务器 → 配置权限
开发团队：在固定路径/data/mysql使用存储
```

容器化后，Pod可能在任意节点启动，传统的手动挂载方式失效：

```
容器化挑战
Pod在node1启动 → 需要自动挂载存储A
Pod被调度到node2 → 需要自动卸载node1并挂载到node2
Pod扩容到3副本 → 需要自动创建3个独立存储
```

**Kubernetes存储体系的设计目标：**
- ✅ **解耦**：应用开发者无需关心底层存储细节（NFS/Ceph/云盘）
- ✅ **自动化**：存储的创建、挂载、卸载、删除全自动
- ✅ **可移植**：同一份YAML可以在不同环境（AWS/阿里云/本地）运行
- ✅ **动态供应**：根据应用需求自动创建存储，无需提前准备

---

### 8.1.2 Kubernetes存储体系架构

Kubernetes通过**三层抽象**解决容器存储难题：

```
┌─────────────────────────────────────────────────────────────┐
│  应用层（Pod）                                                 │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ containers:                                           │  │
│  │   - name: mysql                                       │  │
│  │     volumeMounts:                                     │  │
│  │       - name: data                                    │  │
│  │         mountPath: /var/lib/mysql  ← 应用只关心挂载路径  │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│  抽象层（PVC - 存储需求声明）                                    │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ kind: PersistentVolumeClaim                           │  │
│  │ spec:                                                 │  │
│  │   accessModes: [ReadWriteOnce]                        │  │
│  │   resources:                                          │  │
│  │     requests:                                         │  │
│  │       storage: 10Gi           ← 我需要10GB的RWO存储    │  │
│  │   storageClassName: fast-ssd  ← 我需要SSD类型         │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│  供应层（StorageClass - 存储供应策略）                           │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ kind: StorageClass                                    │  │
│  │ provisioner: kubernetes.io/aws-ebs                    │  │
│  │ parameters:                                           │  │
│  │   type: gp3                   ← 使用AWS GP3 SSD       │  │
│  │   iopsPerGB: "50"             ← 性能参数              │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│  实现层（PV - 真实存储资源）                                     │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ kind: PersistentVolume                                │  │
│  │ spec:                                                 │  │
│  │   capacity:                                           │  │
│  │     storage: 10Gi                                     │  │
│  │   awsElasticBlockStore:                               │  │
│  │     volumeID: vol-0a1b2c3d4e5f  ← 真实的AWS EBS卷ID   │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

**核心概念解析：**

**1. Volume（存储卷）**
- **定义**：Pod中定义的存储抽象，是容器挂载存储的基础单元
- **生命周期**：与Pod绑定，Pod删除时Volume行为取决于类型
- **分类**：
  - **临时卷**：emptyDir（随Pod删除）
  - **节点卷**：hostPath（节点本地路径）
  - **配置卷**：configMap、secret（配置数据）
  - **持久卷**：通过PVC引用PV（独立生命周期）

**2. PersistentVolume（PV，持久卷）**
- **定义**：集群级别的存储资源，由管理员创建或动态供应
- **特点**：
  - 独立于Pod的生命周期（Pod删除后PV依然存在）
  - 包含真实存储的细节（NFS服务器地址、云盘ID等）
  - 有容量、访问模式、回收策略等属性
- **类比**：PV就像数据中心的"存储货架"，是真实的物理资源

**3. PersistentVolumeClaim（PVC，持久卷声明）**
- **定义**：用户对存储的请求声明，描述需要什么样的存储
- **特点**：
  - 命名空间级别（与Pod在同一命名空间）
  - 只描述需求（容量、访问模式、存储类），不关心实现细节
  - 通过绑定机制与PV关联
- **类比**：PVC就像"采购订单"，描述需要多大、什么性能的存储

**4. StorageClass（SC，存储类）**
- **定义**：存储的"配置模板"，定义如何动态创建PV
- **特点**：
  - 包含provisioner（存储供应商插件）
  - 包含parameters（存储参数，如磁盘类型、IOPS）
  - 支持动态供应（PVC创建时自动创建PV）
- **类比**：StorageClass就像"采购合同"，定义了从哪里、如何采购存储

---

### 8.1.3 存储类型分类

Kubernetes支持丰富的存储类型，根据使用场景可以分为以下几类：

**分类1：按生命周期分类**

| 类型 | 生命周期 | 典型场景 | 代表类型 |
|------|---------|---------|---------|
| **临时存储** | 与Pod绑定<br>Pod删除时数据丢失 | - 缓存数据<br>- 临时文件<br>- 容器间共享 | emptyDir |
| **节点存储** | 与节点绑定<br>Pod迁移时数据丢失 | - 节点日志采集<br>- 主机路径访问<br>- DaemonSet数据 | hostPath |
| **持久存储** | 独立生命周期<br>Pod删除后数据保留 | - 数据库数据<br>- 用户上传文件<br>- 持久化队列 | PVC/PV |

**分类2：按访问模式分类**

| 访问模式 | 缩写 | 含义 | 典型场景 | 支持的存储后端 |
|---------|------|------|---------|---------------|
| **ReadWriteOnce** | RWO | 单节点读写 | - 数据库（MySQL/PostgreSQL）<br>- 块存储应用 | AWS EBS、Azure Disk<br>GCE PD、本地磁盘 |
| **ReadOnlyMany** | ROX | 多节点只读 | - 静态资源分发<br>- 共享配置文件 | NFS、CephFS |
| **ReadWriteMany** | RWX | 多节点读写 | - 共享文件服务<br>- 多副本应用共享数据 | NFS、GlusterFS<br>CephFS、Azure File |
| **ReadWriteOncePod** | RWOP | 单Pod读写（K8s 1.22+） | - 独占访问保证<br>- 避免脑裂 | CSI驱动支持 |

**重要提示：**
- ⚠️ **RWO不是指"单个Pod"，而是"单个节点"**：同一节点的多个Pod可以同时挂载RWO卷
- ⚠️ **RWX需要网络存储**：本地磁盘、云盘（EBS/Azure Disk）不支持RWX

**分类3：按存储后端分类**

```
存储后端技术栈
├── 本地存储
│   ├── emptyDir（节点临时目录）
│   ├── hostPath（节点路径）
│   └── local（本地持久卷，1.14+）
├── 网络存储
│   ├── NFS（Network File System）
│   ├── iSCSI（块存储协议）
│   ├── GlusterFS（分布式文件系统）
│   └── CephFS/RBD（Ceph分布式存储）
├── 云存储
│   ├── AWS EBS（Elastic Block Store）
│   ├── Azure Disk（托管磁盘）
│   ├── GCE PD（Persistent Disk）
│   └── 阿里云盘、腾讯云盘
└── 特殊存储
    ├── ConfigMap（配置数据）
    ├── Secret（敏感数据）
    ├── Projected（投射卷，组合多个源）
    └── CSI（Container Storage Interface，统一接口）
```

---

### 8.1.4 PV/PVC绑定机制

**核心流程：**

```
┌──────────────────────────────────────────────────────────────┐
│  步骤1：用户创建PVC（我需要10GB RWO存储）                         │
└────────────────┬─────────────────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────────────────┐
│  步骤2：Controller匹配PV（查找满足条件的PV）                      │
│  匹配条件：                                                     │
│  ✓ 容量 >= PVC请求（10GB）                                     │
│  ✓ 访问模式匹配（RWO）                                          │
│  ✓ StorageClass匹配（或都为空）                                │
│  ✓ Selector标签匹配（如果PVC指定了selector）                    │
└────────────────┬─────────────────────────────────────────────┘
                 │
      ┌──────────┴──────────┐
      │                     │
      ▼                     ▼
┌────────────┐        ┌────────────┐
│ 找到匹配PV  │        │ 未找到PV    │
└─────┬──────┘        └─────┬──────┘
      │                     │
      ▼                     ▼
┌────────────┐        ┌────────────┐
│ 绑定PVC到PV │        │ 触发动态供应 │
│ (Bound状态) │        │ (Pending)   │
└─────┬──────┘        └─────┬──────┘
      │                     │
      │                     ▼
      │              ┌────────────┐
      │              │ SC创建PV   │
      │              └─────┬──────┘
      │                     │
      └──────────┬──────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────────────────┐
│  步骤3：Pod引用PVC（volumeMounts挂载到容器）                      │
└────────────────┬─────────────────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────────────────┐
│  步骤4：Kubelet挂载存储（调用Volume Plugin或CSI驱动）             │
│  - Attach阶段：将存储卷附加到节点（如AWS EBS attach）             │
│  - Mount阶段：将存储卷挂载到容器路径                              │
└──────────────────────────────────────────────────────────────┘
```

**绑定规则详解：**

**规则1：容量匹配**
```yaml
# PVC请求10GB
spec:
  resources:
    requests:
      storage: 10Gi

# 可以绑定到15GB的PV（容量 >= 请求即可）
# 但会浪费5GB空间
# ✅ 推荐：PV容量精确等于PVC请求
```

**规则2：访问模式匹配**
```yaml
# PVC请求RWO
accessModes: [ReadWriteOnce]

# ❌ 无法绑定到只支持ROX的PV
# ✅ 可以绑定到同时支持RWO和RWX的PV
# PV的accessModes必须包含PVC请求的所有模式
```

**规则3：StorageClass匹配**
```yaml
# 场景1：静态绑定（都不指定SC）
PVC: storageClassName: ""  # 明确指定为空
PV:  storageClassName: ""  # 不指定SC
结果: ✅ 可以绑定

# 场景2：动态供应（PVC指定SC）
PVC: storageClassName: "fast-ssd"
结果: 触发StorageClass创建PV

# 场景3：类名匹配
PVC: storageClassName: "fast-ssd"
PV:  storageClassName: "fast-ssd"
结果: ✅ 可以绑定

# 场景4：类名不匹配
PVC: storageClassName: "fast-ssd"
PV:  storageClassName: "standard-hdd"
结果: ❌ 无法绑定
```

**规则4：Selector标签匹配**
```yaml
# PVC通过selector精确选择PV
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes: [ReadWriteOnce]
  resources:
    requests:
      storage: 10Gi
  selector:
    matchLabels:
      environment: production  # 只绑定带此标签的PV
      tier: database
```

---

### 8.1.5 Volume基础类型详解

在深入PV/PVC之前,我们先了解Pod中直接使用的基础Volume类型。

**类型1：emptyDir（临时目录）**

**定义：** Pod创建时自动创建的空目录，Pod删除时数据随之删除。

**典型场景：**
1. 容器间共享数据（同一Pod内的多个容器）
2. 临时缓存（如编译产物、下载文件）
3. 检查点文件（Checkpoint）

**示例：容器间共享日志文件**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: log-sharing-pod
spec:
  containers:
  # 容器1：生成日志
  - name: app
    image: nginx:1.21
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx  # Nginx日志写入此目录

  # 容器2：采集日志
  - name: log-collector
    image: busybox:1.35
    command: ['sh', '-c', 'tail -f /logs/access.log']
    volumeMounts:
    - name: shared-logs
      mountPath: /logs  # 读取同一目录的日志

  volumes:
  - name: shared-logs
    emptyDir: {}  # Pod级别的临时存储
```

**高级特性：基于内存的emptyDir**

```yaml
volumes:
- name: cache
  emptyDir:
    medium: Memory  # 使用内存而非磁盘
    sizeLimit: 1Gi  # 限制最大使用1GB内存
```

**使用场景：**
- ✅ 高性能缓存（读写速度快）
- ⚠️ 注意内存限制（会占用Pod的内存资源）

---

**类型2：hostPath（主机路径）**

**定义：** 将宿主机的文件或目录挂载到Pod中。

**典型场景：**
1. 访问宿主机的Docker socket（/var/run/docker.sock）
2. 节点日志采集（/var/log）
3. 时区同步（/etc/localtime）

**⚠️ 安全警告：** hostPath允许Pod访问节点文件系统，具有较大安全风险，生产环境应谨慎使用。

**示例1：Docker-in-Docker（访问Docker守护进程）**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: docker-cli-pod
spec:
  containers:
  - name: docker-cli
    image: docker:20.10
    command: ['sh', '-c', 'docker ps && sleep 3600']
    volumeMounts:
    - name: docker-sock
      mountPath: /var/run/docker.sock  # 容器内访问宿主机Docker

  volumes:
  - name: docker-sock
    hostPath:
      path: /var/run/docker.sock  # 宿主机Docker socket
      type: Socket  # 类型校验：必须是socket文件
```

**示例2：节点日志采集（DaemonSet典型场景）**

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd-logger
spec:
  selector:
    matchLabels:
      app: fluentd
  template:
    metadata:
      labels:
        app: fluentd
    spec:
      containers:
      - name: fluentd
        image: fluent/fluentd:v1.14
        volumeMounts:
        - name: varlog
          mountPath: /var/log  # 读取节点日志
          readOnly: true  # 只读挂载，安全最佳实践

      volumes:
      - name: varlog
        hostPath:
          path: /var/log  # 节点的日志目录
          type: Directory  # 类型校验：必须是已存在的目录
```

**hostPath类型校验（type字段）：**

| type值 | 含义 | 行为 |
|--------|------|------|
| `""` | 默认（不检查） | 无论路径是否存在都挂载 |
| `DirectoryOrCreate` | 目录或创建 | 目录不存在时自动创建 |
| `Directory` | 必须是目录 | 目录不存在时Pod启动失败 |
| `FileOrCreate` | 文件或创建 | 文件不存在时自动创建 |
| `File` | 必须是文件 | 文件不存在时Pod启动失败 |
| `Socket` | 必须是Socket | 不是socket文件时启动失败 |
| `CharDevice` | 字符设备 | 用于设备文件（如/dev/xxx） |
| `BlockDevice` | 块设备 | 用于块设备文件 |

**最佳实践：**
- ✅ 始终指定`type`字段进行类型校验
- ✅ 尽量使用`readOnly: true`只读挂载
- ✅ 避免挂载敏感路径（如/etc/shadow）
- ⚠️ 注意Pod迁移到其他节点时，hostPath路径可能不存在

---

**类型3：configMap（配置数据）**

**定义：** 将ConfigMap的数据以文件形式挂载到Pod中。

**示例：Nginx配置文件注入**

```yaml
# 第一步：创建ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  nginx.conf: |
    server {
        listen 80;
        server_name example.com;

        location / {
            root /usr/share/nginx/html;
            index index.html;
        }

        location /api {
            proxy_pass http://backend:8080;
        }
    }
  index.html: |
    <html>
      <body><h1>Hello from ConfigMap!</h1></body>
    </html>

---
# 第二步：Pod挂载ConfigMap
apiVersion: v1
kind: Pod
metadata:
  name: nginx-with-config
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    volumeMounts:
    - name: config-volume
      mountPath: /etc/nginx/conf.d  # 配置文件目录
    - name: html-volume
      mountPath: /usr/share/nginx/html  # 静态文件目录

  volumes:
  - name: config-volume
    configMap:
      name: nginx-config
      items:  # 选择性挂载
      - key: nginx.conf
        path: default.conf  # 挂载为default.conf文件

  - name: html-volume
    configMap:
      name: nginx-config
      items:
      - key: index.html
        path: index.html
```

**挂载后的文件结构：**
```bash
# 容器内查看
$ kubectl exec nginx-with-config -- ls -la /etc/nginx/conf.d
total 4
drwxrwxrwx 3 root root  80 Jan 13 10:00 .
drwxr-xr-x 1 root root  41 Jan 13 10:00 ..
drwxr-xr-x 2 root root  28 Jan 13 10:00 ..2024_01_13_10_00_00.123456789
lrwxrwxrwx 1 root root  32 Jan 13 10:00 ..data -> ..2024_01_13_10_00_00.123456789
lrwxrwxrwx 1 root root  19 Jan 13 10:00 default.conf -> ..data/default.conf

# ConfigMap更新时，Kubernetes会自动更新挂载的文件（有约60秒延迟）
```

---

**类型4：secret（敏感数据）**

**定义：** 与ConfigMap类似，但用于存储敏感信息（密码、证书、Token），数据以Base64编码存储。

**示例：MySQL密码注入**

```yaml
# 第一步：创建Secret
apiVersion: v1
kind: Secret
metadata:
  name: mysql-credentials
type: Opaque
data:
  # Base64编码后的值
  username: cm9vdA==  # root
  password: bXlzcWwxMjM0NTY=  # mysql123456

---
# 第二步：Pod使用Secret
apiVersion: v1
kind: Pod
metadata:
  name: mysql-pod
spec:
  containers:
  - name: mysql
    image: mysql:8.0
    env:
    # 方式1：通过环境变量注入
    - name: MYSQL_ROOT_PASSWORD
      valueFrom:
        secretKeyRef:
          name: mysql-credentials
          key: password

    # 方式2：通过文件挂载（更安全）
    volumeMounts:
    - name: credentials
      mountPath: /etc/mysql/conf.d
      readOnly: true  # 只读挂载，防止容器篡改

  volumes:
  - name: credentials
    secret:
      secretName: mysql-credentials
      defaultMode: 0400  # 文件权限：仅所有者可读
```

**Secret vs ConfigMap：**

| 特性 | Secret | ConfigMap |
|------|--------|-----------|
| **数据编码** | Base64编码 | 明文 |
| **API权限** | 更严格（RBAC） | 宽松 |
| **加密存储** | 支持etcd加密（需开启） | 不支持 |
| **文件权限** | 默认0644，可配置 | 默认0644 |
| **典型用途** | 密码、证书、Token | 配置文件、环境变量 |

⚠️ **重要提示：** Base64编码≠加密，Secret在etcd中默认是明文存储，需要配置[etcd加密](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)才能真正加密。

---

### 8.1.6 PV/PVC核心概念深入

现在我们深入学习持久化存储的核心：PV和PVC。

**PersistentVolume（PV）核心属性：**

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-example
  labels:
    type: local
    environment: production
spec:
  # ========== 容量 ==========
  capacity:
    storage: 10Gi  # PV的总容量

  # ========== 访问模式 ==========
  accessModes:
    - ReadWriteOnce  # 单节点读写
    # - ReadOnlyMany   # 多节点只读
    # - ReadWriteMany  # 多节点读写

  # ========== 回收策略 ==========
  persistentVolumeReclaimPolicy: Retain  # PVC删除后的行为
    # Retain：保留数据，手动回收
    # Delete：自动删除PV和底层存储
    # Recycle（废弃）：擦除数据后重新可用

  # ========== 存储类 ==========
  storageClassName: manual  # 关联的StorageClass名称

  # ========== 挂载选项 ==========
  mountOptions:
    - hard
    - nfsvers=4.1

  # ========== 节点亲和性（Local PV必需） ==========
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node1  # 此PV只能在node1上使用

  # ========== 具体存储实现（选择其一） ==========
  nfs:  # NFS存储
    server: 192.168.1.100
    path: /data/pv-example

  # 或者其他类型：
  # hostPath:  # 本地路径
  #   path: /mnt/data
  # awsElasticBlockStore:  # AWS EBS
  #   volumeID: vol-0a1b2c3d4e5f
  #   fsType: ext4
  # cephfs:  # CephFS
  #   monitors: [...]
```

**PersistentVolumeClaim（PVC）核心属性：**

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-example
  namespace: default  # PVC是命名空间级别资源
spec:
  # ========== 访问模式（必需） ==========
  accessModes:
    - ReadWriteOnce  # 必须与PV的accessModes匹配

  # ========== 资源请求（必需） ==========
  resources:
    requests:
      storage: 8Gi  # 请求8GB存储（PV容量需 >= 8Gi）

  # ========== 存储类（可选） ==========
  storageClassName: manual  # 指定使用哪个StorageClass
    # "" - 明确禁用动态供应，只绑定无StorageClass的PV
    # <不指定> - 使用默认StorageClass（如果集群有默认SC）
    # <类名> - 使用指定的StorageClass

  # ========== 选择器（可选） ==========
  selector:
    matchLabels:
      type: local  # 只绑定带此标签的PV
      environment: production
    # matchExpressions:  # 更复杂的选择逻辑
    #   - key: tier
    #     operator: In
    #     values: [database, cache]

  # ========== 卷模式（可选，1.13+） ==========
  volumeMode: Filesystem  # 文件系统模式（默认）
    # Filesystem - 挂载为文件系统（需要格式化）
    # Block - 块设备模式（直接访问裸设备）
```

---

### 8.1.7 完整实战案例：MySQL持久化存储

让我们通过一个完整的案例，将上述概念串联起来。

**场景：** 部署一个MySQL数据库，数据持久化到NFS存储，即使Pod删除数据也不会丢失。

**前提条件：** 已有NFS服务器（192.168.1.100），共享目录/data/mysql

**步骤1：创建PV（管理员操作）**

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv
  labels:
    app: mysql
    environment: production
spec:
  capacity:
    storage: 20Gi  # 提供20GB存储
  accessModes:
    - ReadWriteOnce  # MySQL需要RWO模式
  persistentVolumeReclaimPolicy: Retain  # 删除PVC后保留数据
  storageClassName: nfs-storage  # 存储类名称
  mountOptions:
    - hard  # NFS硬挂载（推荐）
    - nfsvers=4.1  # NFS版本
  nfs:
    server: 192.168.1.100
    path: /data/mysql  # NFS共享路径
```

```bash
# 创建PV
$ kubectl apply -f mysql-pv.yaml
persistentvolume/mysql-pv created

# 查看PV状态
$ kubectl get pv mysql-pv
NAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   AGE
mysql-pv   20Gi       RWO            Retain           Available           nfs-storage    5s
# STATUS=Available 表示PV已就绪，等待PVC绑定
```

**步骤2：创建PVC（开发者操作）**

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: default
spec:
  accessModes:
    - ReadWriteOnce  # 与PV的accessModes匹配
  resources:
    requests:
      storage: 15Gi  # 请求15GB（小于PV的20GB）
  storageClassName: nfs-storage  # 与PV的storageClassName匹配
  selector:
    matchLabels:
      app: mysql  # 精确选择带mysql标签的PV
      environment: production
```

```bash
# 创建PVC
$ kubectl apply -f mysql-pvc.yaml
persistentvolumeclaim/mysql-pvc created

# 查看PVC状态
$ kubectl get pvc mysql-pvc
NAME        STATUS   VOLUME     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
mysql-pvc   Bound    mysql-pv   20Gi       RWO            nfs-storage    3s
# STATUS=Bound 表示PVC已成功绑定到mysql-pv

# 再次查看PV状态
$ kubectl get pv mysql-pv
NAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   AGE
mysql-pv   20Gi       RWO            Retain           Bound    default/mysql-pvc   nfs-storage    2m
# STATUS从Available变为Bound
# CLAIM显示绑定到default/mysql-pvc
```

**步骤3：部署MySQL Pod**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mysql
  labels:
    app: mysql
spec:
  containers:
  - name: mysql
    image: mysql:8.0
    env:
    - name: MYSQL_ROOT_PASSWORD
      value: "mysql123456"  # 生产环境应使用Secret
    ports:
    - containerPort: 3306
      name: mysql
    volumeMounts:
    - name: mysql-storage
      mountPath: /var/lib/mysql  # MySQL数据目录

  volumes:
  - name: mysql-storage
    persistentVolumeClaim:
      claimName: mysql-pvc  # 引用PVC
```

```bash
# 部署MySQL
$ kubectl apply -f mysql-pod.yaml
pod/mysql created

# 等待Pod运行
$ kubectl get pod mysql
NAME    READY   STATUS    RESTARTS   AGE
mysql   1/1     Running   0          30s

# 进入容器验证挂载
$ kubectl exec -it mysql -- df -h /var/lib/mysql
Filesystem                Size  Used Avail Use% Mounted on
192.168.1.100:/data/mysql  20G  1.2G   18G   6% /var/lib/mysql
# 可以看到NFS存储已成功挂载
```

**步骤4：验证数据持久化**

```bash
# 创建测试数据
$ kubectl exec -it mysql -- mysql -uroot -pmysql123456 -e "
CREATE DATABASE testdb;
USE testdb;
CREATE TABLE users (id INT, name VARCHAR(50));
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
SELECT * FROM users;
"
+------+-------+
| id   | name  |
+------+-------+
|    1 | Alice |
|    2 | Bob   |
+------+-------+

# 删除Pod
$ kubectl delete pod mysql
pod "mysql" deleted

# 重新创建Pod（使用相同的PVC）
$ kubectl apply -f mysql-pod.yaml
pod/mysql created

# 等待Pod运行后验证数据
$ kubectl exec -it mysql -- mysql -uroot -pmysql123456 -e "
USE testdb;
SELECT * FROM users;
"
+------+-------+
| id   | name  |
+------+-------+
|    1 | Alice |
|    2 | Bob   |
+------+-------+
# ✅ 数据完整保留！Pod删除重建后数据依然存在
```

**步骤5：清理资源（注意顺序）**

```bash
# 第一步：删除Pod
$ kubectl delete pod mysql
pod "mysql" deleted

# 第二步：删除PVC
$ kubectl delete pvc mysql-pvc
persistentvolumeclaim "mysql-pvc" deleted

# 查看PV状态
$ kubectl get pv mysql-pv
NAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM               STORAGECLASS   AGE
mysql-pv   20Gi       RWO            Retain           Released   default/mysql-pvc   nfs-storage    10m
# STATUS变为Released（已释放，但数据仍保留）

# 第三步：根据需要手动删除PV
$ kubectl delete pv mysql-pv  # 删除PV对象
$ # NFS服务器上的/data/mysql目录数据依然存在（Retain策略）
```

**回收策略的影响：**

| 回收策略 | PVC删除后的行为 | NFS服务器数据 | PV状态 |
|---------|---------------|--------------|--------|
| **Retain** | PV变为Released状态<br>需手动删除PV | 保留 | Released |
| **Delete** | 自动删除PV<br>自动删除底层存储数据 | 删除 | （PV已删除） |
| **Recycle**（废弃） | 执行`rm -rf /volume/*`<br>PV变回Available | 清空 | Available |

---

### 8.1.8 常见问题与排查

**问题1：PVC一直处于Pending状态**

```bash
$ kubectl get pvc
NAME        STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
mysql-pvc   Pending                                      nfs-storage    5m
```

**排查步骤：**

```bash
# 1. 查看PVC详细事件
$ kubectl describe pvc mysql-pvc
Events:
  Type     Reason              Message
  ----     ------              -------
  Warning  ProvisioningFailed  Failed to provision volume with StorageClass "nfs-storage": storageclass.storage.k8s.io "nfs-storage" not found

# 可能原因：
# ✓ StorageClass不存在
# ✓ 没有匹配的PV（静态供应场景）
# ✓ PV容量不足
# ✓ 访问模式不匹配
# ✓ 标签选择器不匹配

# 2. 检查是否有可用PV
$ kubectl get pv
# 如果没有PV，需要创建或检查StorageClass是否支持动态供应

# 3. 检查StorageClass是否存在
$ kubectl get storageclass nfs-storage
```

**解决方案：**
- 创建匹配的PV（静态供应）
- 创建/修复StorageClass（动态供应）
- 调整PVC的请求容量或访问模式

---

**问题2：Pod无法挂载PVC**

```bash
$ kubectl get pod mysql
NAME    READY   STATUS              RESTARTS   AGE
mysql   0/1     ContainerCreating   0          2m
```

```bash
$ kubectl describe pod mysql
Events:
  Warning  FailedMount  Unable to attach or mount volumes: failed to attach volume "mysql-pv": rpc error: code = Internal desc = Could not mount "192.168.1.100:/data/mysql"
```

**可能原因：**
1. **NFS服务器不可达**
   ```bash
   # 在节点上测试NFS连接
   $ showmount -e 192.168.1.100
   clnt_create: RPC: Port mapper failure - Unable to receive: errno 113 (No route to host)
   ```
   解决：检查网络连通性、防火墙规则

2. **NFS目录不存在**
   ```bash
   # NFS服务器上检查
   $ ls -la /data/mysql
   ls: cannot access '/data/mysql': No such file or directory
   ```
   解决：创建目录并配置NFS导出

3. **节点缺少NFS客户端工具**
   ```bash
   # 节点上安装NFS客户端
   $ apt-get install -y nfs-common  # Debian/Ubuntu
   $ yum install -y nfs-utils       # CentOS/RHEL
   ```

---

**问题3：多个Pod竞争同一RWO PVC**

```yaml
# Deployment尝试创建2个副本，都使用同一个RWO PVC
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  replicas: 2  # ❌ 错误：RWO PVC只能被单节点挂载
  template:
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        volumeMounts:
        - name: data
          mountPath: /var/lib/mysql
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: mysql-pvc  # RWO PVC
```

**现象：** 第二个Pod无法启动，报错"Multi-Attach error"

```bash
$ kubectl describe pod mysql-xxx
Events:
  Warning  FailedAttachVolume  Multi-Attach error for volume "pvc-xxx": Volume is already exclusively attached to one node and can't be attached to another
```

**解决方案：**
- ✅ 使用StatefulSet代替Deployment（下一节详解）
- ✅ 使用RWX模式的PVC（需要支持的存储后端如NFS）
- ✅ 将replicas设置为1

---

### 8.1.9 最佳实践总结

**1. Volume类型选择决策树**

```
需要持久化数据吗？
├─ 否 → emptyDir（容器间共享）或不使用Volume
└─ 是
   ├─ 数据只在本节点使用？
   │  └─ 是 → hostPath（谨慎使用）或local PV
   └─ 否
      ├─ 需要多节点同时读写（RWX）？
      │  ├─ 是 → NFS、CephFS、GlusterFS
      │  └─ 否 → AWS EBS、Azure Disk、GCE PD（RWO）
      └─ 数据是配置/密钥？
         ├─ 敏感数据 → Secret
         └─ 普通配置 → ConfigMap
```

**2. PV/PVC使用规范**

| 规范 | 说明 | 示例 |
|------|------|------|
| **PV命名** | 描述性名称，包含存储类型和用途 | `mysql-prod-nfs-pv`<br>`redis-cache-local-pv` |
| **PVC命名** | 与应用关联，描述用途 | `mysql-data-pvc`<br>`nginx-logs-pvc` |
| **容量规划** | PV容量略大于PVC请求（10-20%缓冲） | PVC请求10Gi，PV提供12Gi |
| **标签管理** | 使用标签标识环境、应用、团队 | `environment: production`<br>`app: mysql`<br>`team: platform` |
| **回收策略** | 生产环境使用Retain<br>开发环境可用Delete | `persistentVolumeReclaimPolicy: Retain` |
| **访问模式** | 根据应用需求精确选择 | 数据库用RWO<br>共享文件用RWX |

**3. 安全最佳实践**

```yaml
# ✅ 推荐配置
spec:
  containers:
  - name: app
    volumeMounts:
    - name: config
      mountPath: /etc/config
      readOnly: true  # 只读挂载配置

  volumes:
  - name: config
    secret:
      secretName: app-secret
      defaultMode: 0400  # 限制文件权限为只读
```

**4. 性能优化建议**

- ✅ 数据库使用SSD后端（设置StorageClass的type参数）
- ✅ 日志数据使用HDD后端（成本优化）
- ✅ 避免在emptyDir中存储大量数据（占用节点空间）
- ✅ 对于高IOPS需求，使用本地SSD（local PV）

---

### 8.1.10 下一节预告

在本节中，我们建立了Kubernetes存储体系的整体认知：

- ✅ 理解了容器存储的挑战和Kubernetes的解决方案
- ✅ 掌握了PV、PVC、StorageClass的三层架构
- ✅ 学习了emptyDir、hostPath、ConfigMap、Secret等基础Volume类型
- ✅ 深入理解了PV/PVC的绑定机制和生命周期
- ✅ 通过MySQL案例完整实践了静态存储供应流程

然而,我们还有很多细节需要深入：

- **emptyDir的高级特性**：内存模式、大小限制
- **hostPath的安全隐患**：如何在生产环境安全使用
- **projected卷**：如何组合多个ConfigMap和Secret
- **downwardAPI卷**：如何将Pod元数据注入容器

**在下一节（8.2 Volume详解）中**，我们将深入学习各种Volume类型的高级特性、使用场景和最佳实践，为理解PV/PVC和StorageClass打下坚实基础。

---

**本节完**

*下一节预告：8.2节《Volume详解》- 深入emptyDir、hostPath、projected、downwardAPI等Volume类型的高级特性。*
