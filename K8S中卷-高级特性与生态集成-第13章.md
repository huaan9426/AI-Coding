# ç¬¬13ç« ï¼šè‡ªå®šä¹‰èµ„æºä¸Operatorå¼€å‘

## ç« èŠ‚æ¦‚è¿°

åœ¨å‰12ç« ä¸­ï¼Œæˆ‘ä»¬æ·±å…¥å­¦ä¹ äº†Kubernetesçš„æ ¸å¿ƒæ¦‚å¿µå’ŒåŸºç¡€å®æˆ˜ã€‚ä»æœ¬ç« å¼€å§‹ï¼Œæˆ‘ä»¬å°†è¿›å…¥**ä¸­å·ï¼šé«˜çº§ç‰¹æ€§ä¸ç”Ÿæ€é›†æˆ**çš„å­¦ä¹ ã€‚

**æœ¬ç« æ ¸å¿ƒç›®æ ‡**ï¼š
- æ·±å…¥ç†è§£CRDï¼ˆCustom Resource Definitionï¼‰çš„åŸç†ä¸ä½¿ç”¨
- æŒæ¡Operatoræ¨¡å¼çš„è®¾è®¡ç†å¿µ
- å­¦ä¼šä½¿ç”¨Kubebuilderå’ŒOperator SDKå¼€å‘Operator
- å®æˆ˜å¼€å‘ä¸€ä¸ªå®Œæ•´çš„MySQL Operator

**ä¸ºä»€ä¹ˆéœ€è¦CRDå’ŒOperatorï¼Ÿ**

```
Kuberneteså†…ç½®èµ„æºçš„å±€é™æ€§ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é—®é¢˜1ï¼šæ— æ³•è¡¨è¾¾å¤æ‚çš„åº”ç”¨é€»è¾‘          â”‚
â”‚  ä¾‹å¦‚ï¼šMySQLä¸»ä»å¤åˆ¶ã€Redis Cluster    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  é—®é¢˜2ï¼šæ— æ³•å°è£…è¿ç»´çŸ¥è¯†                â”‚
â”‚  ä¾‹å¦‚ï¼šæ•°æ®åº“å¤‡ä»½ã€æ•…éšœè‡ªåŠ¨æ¢å¤        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  é—®é¢˜3ï¼šæ— æ³•å®ç°åº”ç”¨çº§åˆ«çš„è‡ªåŠ¨åŒ–        â”‚
â”‚  ä¾‹å¦‚ï¼šè‡ªåŠ¨æ‰©å®¹ã€è‡ªåŠ¨å‡çº§ã€è‡ªåŠ¨ä¿®å¤    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CRD + Operatorçš„è§£å†³æ–¹æ¡ˆï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… CRDï¼šæ‰©å±•Kubernetes API             â”‚
â”‚     å®šä¹‰è‡ªå®šä¹‰èµ„æºç±»å‹ï¼ˆå¦‚MySQLï¼‰       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âœ… Operatorï¼šå®ç°è‡ªå®šä¹‰æ§åˆ¶å™¨          â”‚
â”‚     å°è£…è¿ç»´çŸ¥è¯†ï¼Œå®ç°è‡ªåŠ¨åŒ–ç®¡ç†        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âœ… å£°æ˜å¼APIï¼šç”¨æˆ·åªéœ€å£°æ˜æœŸæœ›çŠ¶æ€     â”‚
â”‚     Operatorè´Ÿè´£å®ç°å’Œç»´æŠ¤è¯¥çŠ¶æ€        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Operatoræ¨¡å¼çš„æ ¸å¿ƒæ€æƒ³**ï¼š

Operator = CRD + Controller + é¢†åŸŸçŸ¥è¯†

```
Operatorå·¥ä½œæµç¨‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. ç”¨æˆ·åˆ›å»ºè‡ªå®šä¹‰èµ„æºï¼ˆCRï¼‰              â”‚
â”‚     kubectl apply -f mysql-cluster.yaml  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. Operatorç›‘å¬CRå˜åŒ–                   â”‚
â”‚     Watch API Server                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Operatoræ‰§è¡Œåè°ƒé€»è¾‘ï¼ˆReconcileï¼‰    â”‚
â”‚     - åˆ›å»ºStatefulSetã€Serviceç­‰èµ„æº     â”‚
â”‚     - é…ç½®ä¸»ä»å¤åˆ¶                       â”‚
â”‚     - æ‰§è¡Œå¤‡ä»½ä»»åŠ¡                       â”‚
â”‚     - ç›‘æ§å¥åº·çŠ¶æ€                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. æŒç»­ç›‘æ§å¹¶ç»´æŠ¤æœŸæœ›çŠ¶æ€                â”‚
â”‚     - æ•…éšœè‡ªåŠ¨æ¢å¤                       â”‚
â”‚     - è‡ªåŠ¨æ‰©ç¼©å®¹                         â”‚
â”‚     - è‡ªåŠ¨å‡çº§                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æœ¬ç« å­¦ä¹ è·¯å¾„**ï¼š

```
13.1 CRDæ·±å…¥ç†è§£
  â†“
13.2 Operatoræ¨¡å¼ä¸åŸç†
  â†“
13.3 ä½¿ç”¨Kubebuilderå¼€å‘Operator
  â†“
13.4 ä½¿ç”¨Operator SDKå¼€å‘Operator
  â†“
13.5 Operatoræœ€ä½³å®è·µ
  â†“
13.6 å®æˆ˜ï¼šå¼€å‘MySQL Operator
```

---

## 13.1 CRDæ·±å…¥ç†è§£

### 13.1.1 ä»€ä¹ˆæ˜¯CRD

CRD (Custom Resource Definition) æ˜¯Kubernetesæä¾›çš„æ‰©å±•æœºåˆ¶ï¼Œå…è®¸ç”¨æˆ·å®šä¹‰è‡ªå·±çš„èµ„æºç±»å‹ã€‚

**CRD vs å†…ç½®èµ„æº**ï¼š

| ç‰¹æ€§ | å†…ç½®èµ„æº (Pod/Deployment) | è‡ªå®šä¹‰èµ„æº (CRD) |
|------|--------------------------|------------------|
| **å®šä¹‰æ–¹å¼** | Kuberneteså†…ç½® | ç”¨æˆ·è‡ªå®šä¹‰ |
| **APIç«¯ç‚¹** | /api/v1/pods | /apis/group/version/resources |
| **æ§åˆ¶å™¨** | å†…ç½®æ§åˆ¶å™¨ | ç”¨æˆ·å®ç° |
| **éªŒè¯** | å†…ç½®éªŒè¯ | è‡ªå®šä¹‰éªŒè¯ |
| **å­˜å‚¨** | etcd | etcd |
| **kubectlæ”¯æŒ** | åŸç”Ÿæ”¯æŒ | è‡ªåŠ¨æ”¯æŒ |

### 13.1.2 CRDçš„ç»„æˆéƒ¨åˆ†

ä¸€ä¸ªå®Œæ•´çš„CRDåŒ…å«ä»¥ä¸‹éƒ¨åˆ†ï¼š

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: mysqls.database.example.com  # å¿…é¡»æ˜¯ <plural>.<group>
spec:
  # 1. APIç»„å’Œç‰ˆæœ¬
  group: database.example.com
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                replicas:
                  type: integer
                  minimum: 1
                  maximum: 10
                version:
                  type: string
                  enum: ["5.7", "8.0"]
                storage:
                  type: string
                  pattern: '^[0-9]+Gi$'
            status:
              type: object
              properties:
                phase:
                  type: string
                ready:
                  type: integer
  
  # 2. ä½œç”¨åŸŸ
  scope: Namespaced  # æˆ– Cluster
  
  # 3. èµ„æºåç§°
  names:
    plural: mysqls
    singular: mysql
    kind: MySQL
    shortNames:
      - my
  
  # 4. å­èµ„æº
  subresources:
    status: {}
    scale:
      specReplicasPath: .spec.replicas
      statusReplicasPath: .status.ready
```

### 13.1.3 åˆ›å»ºç¬¬ä¸€ä¸ªCRD

**æ­¥éª¤1ï¼šå®šä¹‰CRD**

```yaml
# mysql-crd.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: mysqls.database.example.com
spec:
  group: database.example.com
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              required: ["version", "storage"]
              properties:
                version:
                  type: string
                  description: "MySQL version"
                  enum: ["5.7", "8.0"]
                storage:
                  type: string
                  description: "Storage size"
                  pattern: '^[0-9]+Gi$'
                replicas:
                  type: integer
                  description: "Number of replicas"
                  minimum: 1
                  maximum: 10
                  default: 1
            status:
              type: object
              properties:
                phase:
                  type: string
                  description: "Current phase"
                ready:
                  type: integer
                  description: "Number of ready replicas"
                message:
                  type: string
                  description: "Status message"
      # å®šä¹‰é¢å¤–çš„æ‰“å°åˆ—
      additionalPrinterColumns:
        - name: Version
          type: string
          jsonPath: .spec.version
        - name: Replicas
          type: integer
          jsonPath: .spec.replicas
        - name: Ready
          type: integer
          jsonPath: .status.ready
        - name: Phase
          type: string
          jsonPath: .status.phase
        - name: Age
          type: date
          jsonPath: .metadata.creationTimestamp
  scope: Namespaced
  names:
    plural: mysqls
    singular: mysql
    kind: MySQL
    shortNames:
      - my
  # å¯ç”¨å­èµ„æº
  subresources:
    status: {}
```

**æ­¥éª¤2ï¼šåº”ç”¨CRD**

```bash
# åˆ›å»ºCRD
kubectl apply -f mysql-crd.yaml

# éªŒè¯CRDå·²åˆ›å»º
kubectl get crd mysqls.database.example.com

# æŸ¥çœ‹CRDè¯¦æƒ…
kubectl describe crd mysqls.database.example.com

# æŸ¥çœ‹APIèµ„æº
kubectl api-resources | grep mysql
```

**æ­¥éª¤3ï¼šåˆ›å»ºè‡ªå®šä¹‰èµ„æºå®ä¾‹ï¼ˆCRï¼‰**

```yaml
# mysql-instance.yaml
apiVersion: database.example.com/v1
kind: MySQL
metadata:
  name: my-mysql
  namespace: default
spec:
  version: "8.0"
  storage: "10Gi"
  replicas: 3
```

```bash
# åˆ›å»ºMySQLå®ä¾‹
kubectl apply -f mysql-instance.yaml

# æŸ¥çœ‹MySQLèµ„æº
kubectl get mysql
kubectl get my  # ä½¿ç”¨çŸ­åç§°

# æŸ¥çœ‹è¯¦æƒ…
kubectl describe mysql my-mysql

# ä½¿ç”¨kubectl explainæŸ¥çœ‹å­—æ®µè¯´æ˜
kubectl explain mysql
kubectl explain mysql.spec
kubectl explain mysql.spec.version
```

### 13.1.4 CRDéªŒè¯

Kubernetesæ”¯æŒä¸‰ç§éªŒè¯æ–¹å¼ï¼š

**1. OpenAPI v3 SchemaéªŒè¯ï¼ˆæ¨èï¼‰**

```yaml
schema:
  openAPIV3Schema:
    type: object
    properties:
      spec:
        type: object
        required: ["version"]  # å¿…å¡«å­—æ®µ
        properties:
          version:
            type: string
            enum: ["5.7", "8.0"]  # æšä¸¾å€¼
          replicas:
            type: integer
            minimum: 1  # æœ€å°å€¼
            maximum: 10  # æœ€å¤§å€¼
          storage:
            type: string
            pattern: '^[0-9]+Gi$'  # æ­£åˆ™è¡¨è¾¾å¼
          config:
            type: object
            additionalProperties:  # å…è®¸é¢å¤–å±æ€§
              type: string
```

**2. Validating Webhookï¼ˆé«˜çº§éªŒè¯ï¼‰**

```yaml
# åœ¨CRDä¸­é…ç½®webhook
conversion:
  strategy: Webhook
  webhook:
    clientConfig:
      service:
        namespace: default
        name: mysql-webhook
        path: /validate
    conversionReviewVersions: ["v1"]
```

**3. CEL (Common Expression Language) éªŒè¯ï¼ˆK8S 1.25+ï¼‰**

```yaml
schema:
  openAPIV3Schema:
    type: object
    properties:
      spec:
        type: object
        properties:
          replicas:
            type: integer
          storage:
            type: string
        # CELéªŒè¯è§„åˆ™
        x-kubernetes-validations:
          - rule: "self.replicas <= 10"
            message: "replicas must be <= 10"
          - rule: "self.storage.matches('^[0-9]+Gi$')"
            message: "storage must be in format like 10Gi"
```

### 13.1.5 CRDç‰ˆæœ¬ç®¡ç†

CRDæ”¯æŒå¤šç‰ˆæœ¬ï¼Œå®ç°APIæ¼”è¿›ï¼š

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: mysqls.database.example.com
spec:
  group: database.example.com
  versions:
    # v1ç‰ˆæœ¬ï¼ˆå½“å‰å­˜å‚¨ç‰ˆæœ¬ï¼‰
    - name: v1
      served: true
      storage: true  # åªèƒ½æœ‰ä¸€ä¸ªç‰ˆæœ¬è®¾ç½®ä¸ºstorage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                version:
                  type: string
                replicas:
                  type: integer
                storage:
                  type: string
    
    # v1beta1ç‰ˆæœ¬ï¼ˆå·²å¼ƒç”¨ï¼‰
    - name: v1beta1
      served: true
      storage: false
      deprecated: true
      deprecationWarning: "database.example.com/v1beta1 MySQL is deprecated; use database.example.com/v1 MySQL"
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                mysqlVersion:  # æ—§å­—æ®µå
                  type: string
                instanceCount:  # æ—§å­—æ®µå
                  type: integer
  
  # ç‰ˆæœ¬è½¬æ¢ç­–ç•¥
  conversion:
    strategy: Webhook
    webhook:
      clientConfig:
        service:
          namespace: default
          name: mysql-webhook
          path: /convert
      conversionReviewVersions: ["v1", "v1beta1"]
```

**ç‰ˆæœ¬è½¬æ¢ç¤ºä¾‹**ï¼š

```go
// ç‰ˆæœ¬è½¬æ¢é€»è¾‘
func convertV1beta1ToV1(src *v1beta1.MySQL) *v1.MySQL {
    return &v1.MySQL{
        Spec: v1.MySQLSpec{
            Version:  src.Spec.MysqlVersion,  // å­—æ®µåè½¬æ¢
            Replicas: src.Spec.InstanceCount,
            Storage:  src.Spec.Storage,
        },
    }
}
```

### 13.1.6 CRDå­èµ„æº

**1. Statuså­èµ„æº**

å¯ç”¨statuså­èµ„æºåï¼Œspecå’Œstatuså¯ä»¥åˆ†åˆ«æ›´æ–°ï¼š

```yaml
subresources:
  status: {}
```

```bash
# æ›´æ–°specï¼ˆä¸å½±å“statusï¼‰
kubectl patch mysql my-mysql --type=merge -p '{"spec":{"replicas":5}}'

# æ›´æ–°statusï¼ˆéœ€è¦ç‰¹æ®Šæƒé™ï¼‰
kubectl patch mysql my-mysql --subresource=status --type=merge -p '{"status":{"ready":5}}'
```

**2. Scaleå­èµ„æº**

å¯ç”¨scaleå­èµ„æºåï¼Œå¯ä»¥ä½¿ç”¨kubectl scaleå‘½ä»¤ï¼š

```yaml
subresources:
  scale:
    specReplicasPath: .spec.replicas
    statusReplicasPath: .status.ready
    labelSelectorPath: .status.labelSelector
```

```bash
# ä½¿ç”¨kubectl scale
kubectl scale mysql my-mysql --replicas=5

# ä½¿ç”¨HPAè‡ªåŠ¨æ‰©ç¼©å®¹
kubectl autoscale mysql my-mysql --min=1 --max=10 --cpu-percent=80
```

### 13.1.7 CRDæœ€ä½³å®è·µ

**1. å‘½åè§„èŒƒ**

```yaml
# âœ… å¥½çš„å‘½å
group: database.example.com
kind: MySQL
plural: mysqls
singular: mysql

# âŒ ä¸å¥½çš„å‘½å
group: mygroup
kind: mysql  # é¦–å­—æ¯åº”å¤§å†™
plural: mysql  # åº”è¯¥æ˜¯å¤æ•°å½¢å¼
```

**2. å­—æ®µè®¾è®¡**

```yaml
spec:
  # âœ… ä½¿ç”¨æ˜ç¡®çš„å­—æ®µå
  version: "8.0"
  replicas: 3
  
  # âŒ é¿å…æ¨¡ç³Šçš„å­—æ®µå
  config: "some-config"
  data: "some-data"
  
  # âœ… ä½¿ç”¨åµŒå¥—ç»“æ„ç»„ç»‡ç›¸å…³å­—æ®µ
  storage:
    size: "10Gi"
    storageClassName: "fast-ssd"
  
  # âœ… ä½¿ç”¨æšä¸¾é™åˆ¶å¯é€‰å€¼
  version:
    type: string
    enum: ["5.7", "8.0", "8.1"]
```

**3. éªŒè¯è§„åˆ™**

```yaml
# âœ… æ·»åŠ å®Œæ•´çš„éªŒè¯è§„åˆ™
schema:
  openAPIV3Schema:
    type: object
    required: ["spec"]  # å¿…å¡«å­—æ®µ
    properties:
      spec:
        type: object
        required: ["version", "storage"]
        properties:
          version:
            type: string
            enum: ["5.7", "8.0"]
          replicas:
            type: integer
            minimum: 1
            maximum: 100
          storage:
            type: string
            pattern: '^[0-9]+Gi$'
```

**4. çŠ¶æ€ç®¡ç†**

```yaml
status:
  # âœ… ä½¿ç”¨æ¸…æ™°çš„çŠ¶æ€å­—æ®µ
  phase: "Running"  # Pending/Running/Failed
  ready: 3
  message: "All replicas are ready"
  conditions:
    - type: "Ready"
      status: "True"
      lastTransitionTime: "2024-01-01T00:00:00Z"
      reason: "AllReplicasReady"
      message: "All 3 replicas are ready"
```

### 13.1.8 CRDå®æˆ˜ç»ƒä¹ 

**ç»ƒä¹ 1ï¼šåˆ›å»ºRedis CRD**

```yaml
# redis-crd.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: redisclusters.cache.example.com
spec:
  group: cache.example.com
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              required: ["mode", "replicas"]
              properties:
                mode:
                  type: string
                  enum: ["standalone", "sentinel", "cluster"]
                replicas:
                  type: integer
                  minimum: 1
                version:
                  type: string
                  default: "7.0"
                storage:
                  type: string
                  pattern: '^[0-9]+Gi$'
                  default: "1Gi"
            status:
              type: object
              properties:
                phase:
                  type: string
                ready:
                  type: integer
      additionalPrinterColumns:
        - name: Mode
          type: string
          jsonPath: .spec.mode
        - name: Replicas
          type: integer
          jsonPath: .spec.replicas
        - name: Ready
          type: integer
          jsonPath: .status.ready
        - name: Phase
          type: string
          jsonPath: .status.phase
        - name: Age
          type: date
          jsonPath: .metadata.creationTimestamp
  scope: Namespaced
  names:
    plural: redisclusters
    singular: rediscluster
    kind: RedisCluster
    shortNames:
      - rc
  subresources:
    status: {}
    scale:
      specReplicasPath: .spec.replicas
      statusReplicasPath: .status.ready
```

```bash
# åº”ç”¨CRD
kubectl apply -f redis-crd.yaml

# åˆ›å»ºRediså®ä¾‹
cat <<EOF | kubectl apply -f -
apiVersion: cache.example.com/v1
kind: RedisCluster
metadata:
  name: my-redis
spec:
  mode: cluster
  replicas: 6
  version: "7.0"
  storage: "5Gi"
EOF

# æŸ¥çœ‹Redisèµ„æº
kubectl get rediscluster
kubectl get rc
kubectl describe rc my-redis
```

---

## 13.2 Operatoræ¨¡å¼ä¸åŸç†

### 13.2.1 ä»€ä¹ˆæ˜¯Operator

Operatoræ˜¯ä¸€ç§Kubernetesæ‰©å±•æ¨¡å¼ï¼Œå®ƒä½¿ç”¨è‡ªå®šä¹‰èµ„æºï¼ˆCRï¼‰æ¥ç®¡ç†åº”ç”¨åŠå…¶ç»„ä»¶ã€‚

**Operatorçš„æ ¸å¿ƒç»„æˆ**ï¼š

```
Operator = CRD + Controller + Domain Knowledge

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CRD (Custom Resource Definition)          â”‚
â”‚  å®šä¹‰è‡ªå®šä¹‰èµ„æºçš„ç»“æ„                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Controller (æ§åˆ¶å™¨)                        â”‚
â”‚  ç›‘å¬èµ„æºå˜åŒ–ï¼Œæ‰§è¡Œåè°ƒé€»è¾‘                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Domain Knowledge (é¢†åŸŸçŸ¥è¯†)                â”‚
â”‚  å°è£…åº”ç”¨çš„è¿ç»´çŸ¥è¯†å’Œæœ€ä½³å®è·µ                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 13.2.2 Operatorçš„å·¥ä½œåŸç†

**æ§åˆ¶å¾ªç¯ï¼ˆControl Loopï¼‰**ï¼š

```go
// Operatoræ§åˆ¶å¾ªç¯ä¼ªä»£ç 
for {
    // 1. ç›‘å¬èµ„æºå˜åŒ–
    event := watchResource()
    
    // 2. è·å–æœŸæœ›çŠ¶æ€
    desired := event.Object.Spec
    
    // 3. è·å–å½“å‰çŠ¶æ€
    current := getCurrentState()
    
    // 4. åè°ƒï¼ˆReconcileï¼‰
    if current != desired {
        // æ‰§è¡Œæ“ä½œä½¿å½“å‰çŠ¶æ€æ¥è¿‘æœŸæœ›çŠ¶æ€
        reconcile(current, desired)
    }
    
    // 5. æ›´æ–°çŠ¶æ€
    updateStatus(current)
}
```

**Reconcileåè°ƒé€»è¾‘**ï¼š

```
Reconcileæµç¨‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. è·å–CRï¼ˆCustom Resourceï¼‰            â”‚
â”‚     å¦‚æœä¸å­˜åœ¨ï¼Œæ‰§è¡Œæ¸…ç†é€»è¾‘å¹¶è¿”å›        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. æ£€æŸ¥Finalizer                        â”‚
â”‚     å¦‚æœCRè¢«åˆ é™¤ï¼Œæ‰§è¡Œæ¸…ç†é€»è¾‘            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. åè°ƒå­èµ„æº                           â”‚
â”‚     - åˆ›å»º/æ›´æ–°StatefulSet               â”‚
â”‚     - åˆ›å»º/æ›´æ–°Service                   â”‚
â”‚     - åˆ›å»º/æ›´æ–°ConfigMap                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. æ‰§è¡Œä¸šåŠ¡é€»è¾‘                         â”‚
â”‚     - é…ç½®ä¸»ä»å¤åˆ¶                       â”‚
â”‚     - æ‰§è¡Œå¤‡ä»½ä»»åŠ¡                       â”‚
â”‚     - ç›‘æ§å¥åº·çŠ¶æ€                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. æ›´æ–°Status                           â”‚
â”‚     è®°å½•å½“å‰çŠ¶æ€å’Œé”™è¯¯ä¿¡æ¯                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 13.2.3 Operatorèƒ½åŠ›ç­‰çº§

CNCFå®šä¹‰äº†Operatorçš„5ä¸ªèƒ½åŠ›ç­‰çº§ï¼š

```
Operatorèƒ½åŠ›ç­‰çº§æ¨¡å‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Level 5: Auto Pilot (è‡ªåŠ¨é©¾é©¶)            â”‚
â”‚  âœ… è‡ªåŠ¨æ‰©ç¼©å®¹                             â”‚
â”‚  âœ… è‡ªåŠ¨è°ƒä¼˜                               â”‚
â”‚  âœ… å¼‚å¸¸æ£€æµ‹ä¸è‡ªåŠ¨ä¿®å¤                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Level 4: Deep Insights (æ·±åº¦æ´å¯Ÿ)         â”‚
â”‚  âœ… ç›‘æ§æŒ‡æ ‡                               â”‚
â”‚  âœ… å‘Šè­¦                                   â”‚
â”‚  âœ… æ—¥å¿—èšåˆ                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Level 3: Full Lifecycle (å…¨ç”Ÿå‘½å‘¨æœŸ)      â”‚
â”‚  âœ… åº”ç”¨å‡çº§                               â”‚
â”‚  âœ… å¤‡ä»½ä¸æ¢å¤                             â”‚
â”‚  âœ… æ•…éšœè½¬ç§»                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Level 2: Seamless Upgrades (æ— ç¼å‡çº§)     â”‚
â”‚  âœ… æ»šåŠ¨æ›´æ–°                               â”‚
â”‚  âœ… ç‰ˆæœ¬ç®¡ç†                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Level 1: Basic Install (åŸºç¡€å®‰è£…)         â”‚
â”‚  âœ… è‡ªåŠ¨åŒ–éƒ¨ç½²                             â”‚
â”‚  âœ… é…ç½®ç®¡ç†                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 13.2.4 å¸¸è§çš„Operatorç¤ºä¾‹

**1. Prometheus Operator**

```yaml
apiVersion: monitoring.coreos.com/v1
kind: Prometheus
metadata:
  name: prometheus
spec:
  replicas: 2
  serviceAccountName: prometheus
  serviceMonitorSelector:
    matchLabels:
      team: frontend
  resources:
    requests:
      memory: 400Mi
```

**2. MySQL Operator (Percona)**

```yaml
apiVersion: pxc.percona.com/v1
kind: PerconaXtraDBCluster
metadata:
  name: cluster1
spec:
  crVersion: 1.12.0
  secretsName: my-cluster-secrets
  pxc:
    size: 3
    image: percona/percona-xtradb-cluster:8.0.27
    resources:
      requests:
        memory: 1G
        cpu: 600m
```

**3. Elasticsearch Operator**

```yaml
apiVersion: elasticsearch.k8s.elastic.co/v1
kind: Elasticsearch
metadata:
  name: quickstart
spec:
  version: 8.5.0
  nodeSets:
  - name: default
    count: 3
    config:
      node.store.allow_mmap: false
```

### 13.2.5 Operatorå¼€å‘æ¡†æ¶å¯¹æ¯”

| ç‰¹æ€§ | Kubebuilder | Operator SDK | KUDO |
|------|-------------|--------------|------|
| **è¯­è¨€** | Go | Go/Ansible/Helm | YAML |
| **å­¦ä¹ æ›²çº¿** | ä¸­ç­‰ | ä¸­ç­‰ | ç®€å• |
| **çµæ´»æ€§** | é«˜ | é«˜ | ä¸­ |
| **ç¤¾åŒºæ”¯æŒ** | å®˜æ–¹ | Red Hat | D2iQ |
| **é€‚ç”¨åœºæ™¯** | å¤æ‚Operator | é€šç”¨Operator | ç®€å•Operator |
| **ä»£ç ç”Ÿæˆ** | å®Œæ•´ | å®Œæ•´ | æœ‰é™ |

æˆ‘ä»¬å°†é‡ç‚¹å­¦ä¹ **Kubebuilder**å’Œ**Operator SDK**ã€‚

---

æ¥ä¸‹æ¥çš„13.3èŠ‚å°†è¯¦ç»†ä»‹ç»å¦‚ä½•ä½¿ç”¨Kubebuilderå¼€å‘Operatorã€‚ç”±äºå†…å®¹è¾ƒé•¿ï¼Œæˆ‘å°†åœ¨ä¸‹ä¸€æ¬¡ç»§ç»­ç¼–å†™ã€‚

**å½“å‰è¿›åº¦**ï¼š
- âœ… 13.1 CRDæ·±å…¥ç†è§£ï¼ˆå®Œæˆï¼‰
- âœ… 13.2 Operatoræ¨¡å¼ä¸åŸç†ï¼ˆå®Œæˆï¼‰
- â³ 13.3 ä½¿ç”¨Kubebuilderå¼€å‘Operatorï¼ˆè¿›è¡Œä¸­ï¼‰
- ğŸ“… 13.4 ä½¿ç”¨Operator SDKå¼€å‘Operatorï¼ˆå¾…ç¼–å†™ï¼‰
- ğŸ“… 13.5 Operatoræœ€ä½³å®è·µï¼ˆå¾…ç¼–å†™ï¼‰
- ğŸ“… 13.6 å®æˆ˜ï¼šå¼€å‘MySQL Operatorï¼ˆå¾…ç¼–å†™ï¼‰

---

## 13.3 ä½¿ç”¨Kubebuilderå¼€å‘Operator

### 13.3.1 Kubebuilderç®€ä»‹

Kubebuilderæ˜¯Kuberneteså®˜æ–¹æ¨èçš„Operatorå¼€å‘æ¡†æ¶ï¼Œç”±Kubernetes SIG API Machineryç»´æŠ¤ã€‚

**Kubebuilderçš„ä¼˜åŠ¿**ï¼š
- âœ… å®˜æ–¹æ”¯æŒï¼Œä¸Kubernetes APIç´§å¯†é›†æˆ
- âœ… è‡ªåŠ¨ç”Ÿæˆè„šæ‰‹æ¶ä»£ç 
- âœ… å†…ç½®æµ‹è¯•æ¡†æ¶
- âœ… æ”¯æŒWebhook
- âœ… å®Œå–„çš„æ–‡æ¡£å’Œç¤¾åŒºæ”¯æŒ

**Kubebuilderé¡¹ç›®ç»“æ„**ï¼š

```
myoperator/
â”œâ”€â”€ api/
â”‚   â””â”€â”€ v1/
â”‚       â”œâ”€â”€ groupversion_info.go
â”‚       â”œâ”€â”€ myresource_types.go      # CRDå®šä¹‰
â”‚       â””â”€â”€ zz_generated.deepcopy.go
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ crd/                         # CRD YAML
â”‚   â”œâ”€â”€ rbac/                        # RBACé…ç½®
â”‚   â”œâ”€â”€ manager/                     # Operatoréƒ¨ç½²é…ç½®
â”‚   â””â”€â”€ samples/                     # CRç¤ºä¾‹
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ myresource_controller.go     # æ§åˆ¶å™¨é€»è¾‘
â”‚   â””â”€â”€ suite_test.go
â”œâ”€â”€ main.go                          # å…¥å£æ–‡ä»¶
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ Makefile
â””â”€â”€ go.mod
```

### 13.3.2 ç¯å¢ƒå‡†å¤‡

**å®‰è£…ä¾èµ–**ï¼š

```bash
# 1. å®‰è£…Go (1.20+)
wget https://go.dev/dl/go1.21.5.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.21.5.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin

# 2. å®‰è£…Kubebuilder
curl -L -o kubebuilder https://go.kubebuilder.io/dl/latest/$(go env GOOS)/$(go env GOARCH)
chmod +x kubebuilder && sudo mv kubebuilder /usr/local/bin/

# 3. éªŒè¯å®‰è£…
kubebuilder version

# 4. å®‰è£…kubectlå’Œkindï¼ˆç”¨äºæœ¬åœ°æµ‹è¯•ï¼‰
# kubectlå·²å®‰è£…
kind create cluster --name operator-test

# 5. å®‰è£…controller-genï¼ˆä»£ç ç”Ÿæˆå·¥å…·ï¼‰
go install sigs.k8s.io/controller-tools/cmd/controller-gen@latest
```

### 13.3.3 åˆ›å»ºOperatoré¡¹ç›®

**æ­¥éª¤1ï¼šåˆå§‹åŒ–é¡¹ç›®**

```bash
# åˆ›å»ºé¡¹ç›®ç›®å½•
mkdir guestbook-operator
cd guestbook-operator

# åˆå§‹åŒ–é¡¹ç›®
kubebuilder init   --domain example.com   --repo github.com/example/guestbook-operator   --owner "Your Name"

# æŸ¥çœ‹ç”Ÿæˆçš„æ–‡ä»¶
tree -L 2
```

**æ­¥éª¤2ï¼šåˆ›å»ºAPI**

```bash
# åˆ›å»ºAPIå’ŒController
kubebuilder create api   --group webapp   --version v1   --kind Guestbook   --resource   --controller

# è¿™å°†ç”Ÿæˆï¼š
# - api/v1/guestbook_types.go (CRDå®šä¹‰)
# - controllers/guestbook_controller.go (æ§åˆ¶å™¨)
# - config/crd/bases/webapp.example.com_guestbooks.yaml (CRD YAML)
# - config/samples/webapp_v1_guestbook.yaml (CRç¤ºä¾‹)
```

### 13.3.4 å®šä¹‰CRD

ç¼–è¾‘ `api/v1/guestbook_types.go`ï¼š

```go
package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// GuestbookSpec defines the desired state of Guestbook
type GuestbookSpec struct {
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:validation:Maximum=10
	// +kubebuilder:default=1
	// Replicas is the number of frontend replicas
	Replicas int32 `json:"replicas,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern=`^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`
	// RedisName is the name of the Redis instance
	RedisName string `json:"redisName"`

	// +kubebuilder:validation:Enum=ClusterIP;NodePort;LoadBalancer
	// +kubebuilder:default=ClusterIP
	// ServiceType is the type of Service
	ServiceType string `json:"serviceType,omitempty"`
}

// GuestbookStatus defines the observed state of Guestbook
type GuestbookStatus struct {
	// Phase represents the current phase of the Guestbook
	// +kubebuilder:validation:Enum=Pending;Running;Failed
	Phase string `json:"phase,omitempty"`

	// ReadyReplicas is the number of ready replicas
	ReadyReplicas int32 `json:"readyReplicas,omitempty"`

	// Conditions represent the latest available observations
	Conditions []metav1.Condition `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.readyReplicas
// +kubebuilder:printcolumn:name="Replicas",type=integer,JSONPath=`.spec.replicas`
// +kubebuilder:printcolumn:name="Ready",type=integer,JSONPath=`.status.readyReplicas`
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`

// Guestbook is the Schema for the guestbooks API
type Guestbook struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   GuestbookSpec   `json:"spec,omitempty"`
	Status GuestbookStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// GuestbookList contains a list of Guestbook
type GuestbookList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Guestbook `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Guestbook{}, &GuestbookList{})
}
```

**Kubebuilderæ ‡è®°è¯´æ˜**ï¼š

```go
// éªŒè¯æ ‡è®°
// +kubebuilder:validation:Minimum=1              // æœ€å°å€¼
// +kubebuilder:validation:Maximum=10             // æœ€å¤§å€¼
// +kubebuilder:validation:Required               // å¿…å¡«
// +kubebuilder:validation:Pattern=`^[a-z]+$`     // æ­£åˆ™è¡¨è¾¾å¼
// +kubebuilder:validation:Enum=A;B;C             // æšä¸¾å€¼
// +kubebuilder:default=value                     // é»˜è®¤å€¼

// å­èµ„æºæ ‡è®°
// +kubebuilder:subresource:status                // å¯ç”¨statuså­èµ„æº
// +kubebuilder:subresource:scale                 // å¯ç”¨scaleå­èµ„æº

// æ‰“å°åˆ—æ ‡è®°
// +kubebuilder:printcolumn:name="Name",type=string,JSONPath=`.spec.field`

// RBACæ ‡è®°
// +kubebuilder:rbac:groups=webapp.example.com,resources=guestbooks,verbs=get;list;watch;create;update;patch;delete
```

### 13.3.5 ç”Ÿæˆä»£ç å’ŒCRD

```bash
# ç”ŸæˆDeepCopyæ–¹æ³•å’ŒCRD YAML
make generate
make manifests

# æŸ¥çœ‹ç”Ÿæˆçš„CRD
cat config/crd/bases/webapp.example.com_guestbooks.yaml
```

### 13.3.6 å®ç°Controlleré€»è¾‘

ç¼–è¾‘ `controllers/guestbook_controller.go`ï¼š

```go
package controllers

import (
	"context"
	"fmt"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	webappv1 "github.com/example/guestbook-operator/api/v1"
)

// GuestbookReconciler reconciles a Guestbook object
type GuestbookReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=webapp.example.com,resources=guestbooks,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=webapp.example.com,resources=guestbooks/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=webapp.example.com,resources=guestbooks/finalizers,verbs=update
// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=services,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop
func (r *GuestbookReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)

	// 1. è·å–Guestbookå®ä¾‹
	guestbook := &webappv1.Guestbook{}
	err := r.Get(ctx, req.NamespacedName, guestbook)
	if err != nil {
		if errors.IsNotFound(err) {
			// èµ„æºå·²è¢«åˆ é™¤
			log.Info("Guestbook resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		// è¯»å–å¤±è´¥
		log.Error(err, "Failed to get Guestbook")
		return ctrl.Result{}, err
	}

	// 2. æ£€æŸ¥Deploymentæ˜¯å¦å­˜åœ¨
	deployment := &appsv1.Deployment{}
	err = r.Get(ctx, types.NamespacedName{
		Name:      guestbook.Name,
		Namespace: guestbook.Namespace,
	}, deployment)

	if err != nil && errors.IsNotFound(err) {
		// Deploymentä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°çš„
		dep := r.deploymentForGuestbook(guestbook)
		log.Info("Creating a new Deployment", "Deployment.Namespace", dep.Namespace, "Deployment.Name", dep.Name)
		err = r.Create(ctx, dep)
		if err != nil {
			log.Error(err, "Failed to create new Deployment", "Deployment.Namespace", dep.Namespace, "Deployment.Name", dep.Name)
			return ctrl.Result{}, err
		}
		// Deploymentåˆ›å»ºæˆåŠŸï¼Œé‡æ–°å…¥é˜Ÿ
		return ctrl.Result{Requeue: true}, nil
	} else if err != nil {
		log.Error(err, "Failed to get Deployment")
		return ctrl.Result{}, err
	}

	// 3. ç¡®ä¿Deploymentçš„å‰¯æœ¬æ•°ä¸Specä¸€è‡´
	size := guestbook.Spec.Replicas
	if *deployment.Spec.Replicas != size {
		deployment.Spec.Replicas = &size
		err = r.Update(ctx, deployment)
		if err != nil {
			log.Error(err, "Failed to update Deployment", "Deployment.Namespace", deployment.Namespace, "Deployment.Name", deployment.Name)
			return ctrl.Result{}, err
		}
		// Specæ›´æ–°æˆåŠŸï¼Œé‡æ–°å…¥é˜Ÿ
		return ctrl.Result{Requeue: true}, nil
	}

	// 4. æ£€æŸ¥Serviceæ˜¯å¦å­˜åœ¨
	service := &corev1.Service{}
	err = r.Get(ctx, types.NamespacedName{
		Name:      guestbook.Name,
		Namespace: guestbook.Namespace,
	}, service)

	if err != nil && errors.IsNotFound(err) {
		// Serviceä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°çš„
		svc := r.serviceForGuestbook(guestbook)
		log.Info("Creating a new Service", "Service.Namespace", svc.Namespace, "Service.Name", svc.Name)
		err = r.Create(ctx, svc)
		if err != nil {
			log.Error(err, "Failed to create new Service", "Service.Namespace", svc.Namespace, "Service.Name", svc.Name)
			return ctrl.Result{}, err
		}
		// Serviceåˆ›å»ºæˆåŠŸ
		return ctrl.Result{Requeue: true}, nil
	} else if err != nil {
		log.Error(err, "Failed to get Service")
		return ctrl.Result{}, err
	}

	// 5. æ›´æ–°Status
	guestbook.Status.ReadyReplicas = deployment.Status.ReadyReplicas
	if deployment.Status.ReadyReplicas == size {
		guestbook.Status.Phase = "Running"
	} else {
		guestbook.Status.Phase = "Pending"
	}

	err = r.Status().Update(ctx, guestbook)
	if err != nil {
		log.Error(err, "Failed to update Guestbook status")
		return ctrl.Result{}, err
	}

	return ctrl.Result{}, nil
}

// deploymentForGuestbook returns a Guestbook Deployment object
func (r *GuestbookReconciler) deploymentForGuestbook(g *webappv1.Guestbook) *appsv1.Deployment {
	ls := labelsForGuestbook(g.Name)
	replicas := g.Spec.Replicas

	dep := &appsv1.Deployment{
		ObjectMeta: metav1.ObjectMeta{
			Name:      g.Name,
			Namespace: g.Namespace,
		},
		Spec: appsv1.DeploymentSpec{
			Replicas: &replicas,
			Selector: &metav1.LabelSelector{
				MatchLabels: ls,
			},
			Template: corev1.PodTemplateSpec{
				ObjectMeta: metav1.ObjectMeta{
					Labels: ls,
				},
				Spec: corev1.PodSpec{
					Containers: []corev1.Container{{
						Image:   "gcr.io/google-samples/gb-frontend:v4",
						Name:    "guestbook",
						Ports: []corev1.ContainerPort{{
							ContainerPort: 80,
							Name:          "http",
						}},
						Env: []corev1.EnvVar{{
							Name:  "GET_HOSTS_FROM",
							Value: "dns",
						}},
					}},
				},
			},
		},
	}

	// è®¾ç½®OwnerReference
	controllerutil.SetControllerReference(g, dep, r.Scheme)
	return dep
}

// serviceForGuestbook returns a Guestbook Service object
func (r *GuestbookReconciler) serviceForGuestbook(g *webappv1.Guestbook) *corev1.Service {
	ls := labelsForGuestbook(g.Name)

	svc := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      g.Name,
			Namespace: g.Namespace,
		},
		Spec: corev1.ServiceSpec{
			Type:     corev1.ServiceType(g.Spec.ServiceType),
			Selector: ls,
			Ports: []corev1.ServicePort{{
				Port:     80,
				Name:     "http",
				Protocol: corev1.ProtocolTCP,
			}},
		},
	}

	// è®¾ç½®OwnerReference
	controllerutil.SetControllerReference(g, svc, r.Scheme)
	return svc
}

// labelsForGuestbook returns the labels for selecting the resources
func labelsForGuestbook(name string) map[string]string {
	return map[string]string{"app": "guestbook", "guestbook_cr": name}
}

// SetupWithManager sets up the controller with the Manager.
func (r *GuestbookReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&webappv1.Guestbook{}).
		Owns(&appsv1.Deployment{}).
		Owns(&corev1.Service{}).
		Complete(r)
}
```

### 13.3.7 æœ¬åœ°æµ‹è¯•

```bash
# 1. å®‰è£…CRDåˆ°é›†ç¾¤
make install

# 2. éªŒè¯CRDå·²å®‰è£…
kubectl get crd guestbooks.webapp.example.com

# 3. æœ¬åœ°è¿è¡ŒControllerï¼ˆç”¨äºå¼€å‘è°ƒè¯•ï¼‰
make run

# 4. åœ¨å¦ä¸€ä¸ªç»ˆç«¯åˆ›å»ºCR
kubectl apply -f config/samples/webapp_v1_guestbook.yaml

# 5. æŸ¥çœ‹èµ„æº
kubectl get guestbook
kubectl get deployment
kubectl get service

# 6. æŸ¥çœ‹Controlleræ—¥å¿—
# åœ¨è¿è¡Œmake runçš„ç»ˆç«¯æŸ¥çœ‹æ—¥å¿—è¾“å‡º

# 7. æµ‹è¯•æ›´æ–°
kubectl patch guestbook guestbook-sample --type=merge -p '{"spec":{"replicas":3}}'

# 8. æŸ¥çœ‹çŠ¶æ€
kubectl describe guestbook guestbook-sample

# 9. æ¸…ç†
kubectl delete guestbook guestbook-sample
```

### 13.3.8 æ„å»ºå’Œéƒ¨ç½²

**æ­¥éª¤1ï¼šæ„å»ºé•œåƒ**

```bash
# æ„å»ºDockeré•œåƒ
make docker-build IMG=your-registry/guestbook-operator:v0.1.0

# æ¨é€é•œåƒ
make docker-push IMG=your-registry/guestbook-operator:v0.1.0
```

**æ­¥éª¤2ï¼šéƒ¨ç½²åˆ°é›†ç¾¤**

```bash
# éƒ¨ç½²Operator
make deploy IMG=your-registry/guestbook-operator:v0.1.0

# éªŒè¯éƒ¨ç½²
kubectl get deployment -n guestbook-operator-system
kubectl get pods -n guestbook-operator-system

# æŸ¥çœ‹æ—¥å¿—
kubectl logs -n guestbook-operator-system deployment/guestbook-operator-controller-manager
```

**æ­¥éª¤3ï¼šåˆ›å»ºCR**

```yaml
# guestbook-sample.yaml
apiVersion: webapp.example.com/v1
kind: Guestbook
metadata:
  name: my-guestbook
spec:
  replicas: 3
  redisName: redis-master
  serviceType: LoadBalancer
```

```bash
# åº”ç”¨CR
kubectl apply -f guestbook-sample.yaml

# æŸ¥çœ‹èµ„æº
kubectl get guestbook
kubectl get all -l app=guestbook

# è®¿é—®åº”ç”¨
kubectl get svc my-guestbook
# ä½¿ç”¨LoadBalancerçš„EXTERNAL-IPè®¿é—®
```

### 13.3.9 æ·»åŠ Webhook

Webhookç”¨äºéªŒè¯å’Œä¿®æ”¹èµ„æºã€‚

**åˆ›å»ºWebhook**ï¼š

```bash
# åˆ›å»ºWebhook
kubebuilder create webhook   --group webapp   --version v1   --kind Guestbook   --defaulting   --programmatic-validation
```

**å®ç°Webhooké€»è¾‘**ï¼š

ç¼–è¾‘ `api/v1/guestbook_webhook.go`ï¼š

```go
package v1

import (
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

var guestbooklog = logf.Log.WithName("guestbook-resource")

func (r *Guestbook) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

// +kubebuilder:webhook:path=/mutate-webapp-example-com-v1-guestbook,mutating=true,failurePolicy=fail,sideEffects=None,groups=webapp.example.com,resources=guestbooks,verbs=create;update,versions=v1,name=mguestbook.kb.io,admissionReviewVersions=v1

var _ webhook.Defaulter = &Guestbook{}

// Default implements webhook.Defaulter
func (r *Guestbook) Default() {
	guestbooklog.Info("default", "name", r.Name)

	// è®¾ç½®é»˜è®¤å€¼
	if r.Spec.Replicas == 0 {
		r.Spec.Replicas = 1
	}
	if r.Spec.ServiceType == "" {
		r.Spec.ServiceType = "ClusterIP"
	}
}

// +kubebuilder:webhook:path=/validate-webapp-example-com-v1-guestbook,mutating=false,failurePolicy=fail,sideEffects=None,groups=webapp.example.com,resources=guestbooks,verbs=create;update,versions=v1,name=vguestbook.kb.io,admissionReviewVersions=v1

var _ webhook.Validator = &Guestbook{}

// ValidateCreate implements webhook.Validator
func (r *Guestbook) ValidateCreate() error {
	guestbooklog.Info("validate create", "name", r.Name)

	// éªŒè¯é€»è¾‘
	if r.Spec.Replicas < 1 || r.Spec.Replicas > 10 {
		return fmt.Errorf("replicas must be between 1 and 10")
	}
	return nil
}

// ValidateUpdate implements webhook.Validator
func (r *Guestbook) ValidateUpdate(old runtime.Object) error {
	guestbooklog.Info("validate update", "name", r.Name)

	// éªŒè¯æ›´æ–°é€»è¾‘
	oldGuestbook := old.(*Guestbook)
	if r.Spec.RedisName != oldGuestbook.Spec.RedisName {
		return fmt.Errorf("redisName is immutable")
	}
	return nil
}

// ValidateDelete implements webhook.Validator
func (r *Guestbook) ValidateDelete() error {
	guestbooklog.Info("validate delete", "name", r.Name)
	return nil
}
```

**éƒ¨ç½²Webhook**ï¼š

```bash
# ç”ŸæˆWebhooké…ç½®
make manifests

# éƒ¨ç½²ï¼ˆéœ€è¦cert-managerï¼‰
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml

# é‡æ–°éƒ¨ç½²Operator
make deploy IMG=your-registry/guestbook-operator:v0.1.0
```

### 13.3.10 ç¼–å†™æµ‹è¯•

ç¼–è¾‘ `controllers/guestbook_controller_test.go`ï¼š

```go
package controllers

import (
	"context"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"

	webappv1 "github.com/example/guestbook-operator/api/v1"
)

var _ = Describe("Guestbook Controller", func() {
	const (
		GuestbookName      = "test-guestbook"
		GuestbookNamespace = "default"
		timeout            = time.Second * 10
		interval           = time.Millisecond * 250
	)

	Context("When creating Guestbook", func() {
		It("Should create Deployment and Service", func() {
			By("Creating a new Guestbook")
			ctx := context.Background()
			guestbook := &webappv1.Guestbook{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "webapp.example.com/v1",
					Kind:       "Guestbook",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      GuestbookName,
					Namespace: GuestbookNamespace,
				},
				Spec: webappv1.GuestbookSpec{
					Replicas:    3,
					RedisName:   "redis-master",
					ServiceType: "ClusterIP",
				},
			}
			Expect(k8sClient.Create(ctx, guestbook)).Should(Succeed())

			guestbookLookupKey := types.NamespacedName{Name: GuestbookName, Namespace: GuestbookNamespace}
			createdGuestbook := &webappv1.Guestbook{}

			Eventually(func() bool {
				err := k8sClient.Get(ctx, guestbookLookupKey, createdGuestbook)
				return err == nil
			}, timeout, interval).Should(BeTrue())

			By("Checking the Deployment is created")
			deployment := &appsv1.Deployment{}
			Eventually(func() bool {
				err := k8sClient.Get(ctx, guestbookLookupKey, deployment)
				return err == nil
			}, timeout, interval).Should(BeTrue())

			Expect(*deployment.Spec.Replicas).Should(Equal(int32(3)))

			By("Checking the Service is created")
			service := &corev1.Service{}
			Eventually(func() bool {
				err := k8sClient.Get(ctx, guestbookLookupKey, service)
				return err == nil
			}, timeout, interval).Should(BeTrue())

			Expect(service.Spec.Type).Should(Equal(corev1.ServiceTypeClusterIP))
		})
	})
})
```

**è¿è¡Œæµ‹è¯•**ï¼š

```bash
# è¿è¡Œå•å…ƒæµ‹è¯•
make test

# è¿è¡Œé›†æˆæµ‹è¯•
make test-integration
```

---

**å½“å‰ç¬¬13ç« è¿›åº¦**ï¼š
- âœ… 13.1 CRDæ·±å…¥ç†è§£ï¼ˆå®Œæˆï¼‰
- âœ… 13.2 Operatoræ¨¡å¼ä¸åŸç†ï¼ˆå®Œæˆï¼‰
- âœ… 13.3 ä½¿ç”¨Kubebuilderå¼€å‘Operatorï¼ˆå®Œæˆï¼‰
- â³ 13.4 ä½¿ç”¨Operator SDKå¼€å‘Operatorï¼ˆå¾…ç¼–å†™ï¼‰
- ğŸ“… 13.5 Operatoræœ€ä½³å®è·µï¼ˆå¾…ç¼–å†™ï¼‰
- ğŸ“… 13.6 å®æˆ˜ï¼šå¼€å‘MySQL Operatorï¼ˆå¾…ç¼–å†™ï¼‰

æ¥ä¸‹æ¥å°†ç»§ç»­ç¼–å†™13.4-13.6èŠ‚çš„å†…å®¹ã€‚


## 13.4 ä½¿ç”¨Operator SDKå¼€å‘Operator

### 13.4.1 Operator SDKç®€ä»‹

Operator SDKæ˜¯Red Hatå¼€å‘çš„Operatorå¼€å‘æ¡†æ¶ï¼Œæ”¯æŒå¤šç§å¼€å‘æ–¹å¼ã€‚

**Operator SDK vs Kubebuilderå¯¹æ¯”**ï¼š

| ç‰¹æ€§ | Operator SDK | Kubebuilder |
|------|-------------|-------------|
| **ç»´æŠ¤æ–¹** | Red Hat | Kubernetes SIG |
| **æ”¯æŒè¯­è¨€** | Go/Ansible/Helm | Go |
| **å­¦ä¹ æ›²çº¿** | ä¸­ç­‰ | ä¸­ç­‰ |
| **çµæ´»æ€§** | é«˜ï¼ˆå¤šç§æ–¹å¼ï¼‰ | é«˜ï¼ˆçº¯Goï¼‰ |
| **é€‚ç”¨åœºæ™¯** | å¤šæ ·åŒ–éœ€æ±‚ | Goå¼€å‘è€… |
| **ç¤¾åŒº** | æ´»è·ƒ | å®˜æ–¹æ”¯æŒ |

**Operator SDKçš„ä¸‰ç§å¼€å‘æ–¹å¼**ï¼š

```
Operator SDKå¼€å‘æ–¹å¼ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Go Operator                            â”‚
â”‚     - å®Œå…¨æ§åˆ¶ï¼Œæœ€çµæ´»                      â”‚
â”‚     - é€‚åˆå¤æ‚ä¸šåŠ¡é€»è¾‘                      â”‚
â”‚     - éœ€è¦Goè¯­è¨€çŸ¥è¯†                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  2. Ansible Operator                       â”‚
â”‚     - ä½¿ç”¨Ansible Playbook                 â”‚
â”‚     - é€‚åˆè¿ç»´äººå‘˜                         â”‚
â”‚     - æ— éœ€ç¼–ç¨‹çŸ¥è¯†                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  3. Helm Operator                          â”‚
â”‚     - åŸºäºHelm Chart                       â”‚
â”‚     - å¿«é€Ÿå¼€å‘                             â”‚
â”‚     - é€‚åˆç®€å•åœºæ™¯                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 13.4.2 ç¯å¢ƒå‡†å¤‡

**å®‰è£…Operator SDK**ï¼š

```bash
# 1. ä¸‹è½½Operator SDK
export ARCH=$(case $(uname -m) in x86_64) echo -n amd64 ;; aarch64) echo -n arm64 ;; *) echo -n $(uname -m) ;; esac)
export OS=$(uname | awk '{print tolower($0)}')
export OPERATOR_SDK_DL_URL=https://github.com/operator-framework/operator-sdk/releases/download/v1.32.0
curl -LO ${OPERATOR_SDK_DL_URL}/operator-sdk_${OS}_${ARCH}

# 2. éªŒè¯äºŒè¿›åˆ¶æ–‡ä»¶
gpg --keyserver keyserver.ubuntu.com --recv-keys 052996E2A20B5C7E

curl -LO ${OPERATOR_SDK_DL_URL}/checksums.txt
curl -LO ${OPERATOR_SDK_DL_URL}/checksums.txt.asc
gpg -u "Operator SDK (release) <cncf-operator-sdk@cncf.io>" --verify checksums.txt.asc

grep operator-sdk_${OS}_${ARCH} checksums.txt | sha256sum -c -

# 3. å®‰è£…
chmod +x operator-sdk_${OS}_${ARCH}
sudo mv operator-sdk_${OS}_${ARCH} /usr/local/bin/operator-sdk

# 4. éªŒè¯å®‰è£…
operator-sdk version
```

### 13.4.3 Go Operatorå¼€å‘

**æ­¥éª¤1ï¼šåˆå§‹åŒ–é¡¹ç›®**

```bash
# åˆ›å»ºé¡¹ç›®ç›®å½•
mkdir memcached-operator
cd memcached-operator

# åˆå§‹åŒ–Go Operatoré¡¹ç›®
operator-sdk init   --domain example.com   --repo github.com/example/memcached-operator

# æŸ¥çœ‹ç”Ÿæˆçš„æ–‡ä»¶
tree -L 2
```

**æ­¥éª¤2ï¼šåˆ›å»ºAPI**

```bash
# åˆ›å»ºAPIå’ŒController
operator-sdk create api   --group cache   --version v1alpha1   --kind Memcached   --resource   --controller

# ç”Ÿæˆçš„æ–‡ä»¶ï¼š
# - api/v1alpha1/memcached_types.go
# - controllers/memcached_controller.go
# - config/crd/bases/cache.example.com_memcacheds.yaml
# - config/samples/cache_v1alpha1_memcached.yaml
```

**æ­¥éª¤3ï¼šå®šä¹‰API**

ç¼–è¾‘ `api/v1alpha1/memcached_types.go`ï¼š

```go
package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// MemcachedSpec defines the desired state of Memcached
type MemcachedSpec struct {
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:validation:Maximum=10
	// +kubebuilder:default=3
	// Size is the number of memcached instances
	Size int32 `json:"size"`

	// +kubebuilder:validation:Pattern=`^[0-9]+Mi$`
	// +kubebuilder:default="64Mi"
	// Memory is the memory limit for each instance
	Memory string `json:"memory,omitempty"`

	// +kubebuilder:default="memcached:1.6.22-alpine"
	// Image is the memcached image
	Image string `json:"image,omitempty"`
}

// MemcachedStatus defines the observed state of Memcached
type MemcachedStatus struct {
	// Nodes are the names of the memcached pods
	Nodes []string `json:"nodes,omitempty"`

	// Conditions represent the latest available observations
	Conditions []metav1.Condition `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Size",type=integer,JSONPath=`.spec.size`
// +kubebuilder:printcolumn:name="Ready",type=integer,JSONPath=`.status.conditions[?(@.type=="Ready")].status`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`

// Memcached is the Schema for the memcacheds API
type Memcached struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   MemcachedSpec   `json:"spec,omitempty"`
	Status MemcachedStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MemcachedList contains a list of Memcached
type MemcachedList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Memcached `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Memcached{}, &MemcachedList{})
}
```

**æ­¥éª¤4ï¼šå®ç°Controller**

ç¼–è¾‘ `controllers/memcached_controller.go`ï¼š

```go
package controllers

import (
	"context"
	"fmt"
	"reflect"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	cachev1alpha1 "github.com/example/memcached-operator/api/v1alpha1"
)

const memcachedFinalizer = "cache.example.com/finalizer"

// MemcachedReconciler reconciles a Memcached object
type MemcachedReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/finalizers,verbs=update
// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;watch

func (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)

	// 1. è·å–Memcachedå®ä¾‹
	memcached := &cachev1alpha1.Memcached{}
	err := r.Get(ctx, req.NamespacedName, memcached)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Info("Memcached resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		log.Error(err, "Failed to get Memcached")
		return ctrl.Result{}, err
	}

	// 2. æ£€æŸ¥æ˜¯å¦æ­£åœ¨åˆ é™¤
	isMemcachedMarkedToBeDeleted := memcached.GetDeletionTimestamp() != nil
	if isMemcachedMarkedToBeDeleted {
		if controllerutil.ContainsFinalizer(memcached, memcachedFinalizer) {
			// æ‰§è¡Œæ¸…ç†é€»è¾‘
			if err := r.finalizeMemcached(log, memcached); err != nil {
				return ctrl.Result{}, err
			}

			// ç§»é™¤finalizer
			controllerutil.RemoveFinalizer(memcached, memcachedFinalizer)
			err := r.Update(ctx, memcached)
			if err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{}, nil
	}

	// 3. æ·»åŠ finalizer
	if !controllerutil.ContainsFinalizer(memcached, memcachedFinalizer) {
		controllerutil.AddFinalizer(memcached, memcachedFinalizer)
		err = r.Update(ctx, memcached)
		if err != nil {
			return ctrl.Result{}, err
		}
	}

	// 4. æ£€æŸ¥Deploymentæ˜¯å¦å­˜åœ¨
	found := &appsv1.Deployment{}
	err = r.Get(ctx, types.NamespacedName{Name: memcached.Name, Namespace: memcached.Namespace}, found)
	if err != nil && errors.IsNotFound(err) {
		// å®šä¹‰æ–°çš„Deployment
		dep := r.deploymentForMemcached(memcached)
		log.Info("Creating a new Deployment", "Deployment.Namespace", dep.Namespace, "Deployment.Name", dep.Name)
		err = r.Create(ctx, dep)
		if err != nil {
			log.Error(err, "Failed to create new Deployment", "Deployment.Namespace", dep.Namespace, "Deployment.Name", dep.Name)
			return ctrl.Result{}, err
		}
		// Deploymentåˆ›å»ºæˆåŠŸï¼Œæ›´æ–°çŠ¶æ€
		return ctrl.Result{Requeue: true}, nil
	} else if err != nil {
		log.Error(err, "Failed to get Deployment")
		return ctrl.Result{}, err
	}

	// 5. ç¡®ä¿Deploymentå¤§å°ä¸Specä¸€è‡´
	size := memcached.Spec.Size
	if *found.Spec.Replicas != size {
		found.Spec.Replicas = &size
		err = r.Update(ctx, found)
		if err != nil {
			log.Error(err, "Failed to update Deployment", "Deployment.Namespace", found.Namespace, "Deployment.Name", found.Name)
			return ctrl.Result{}, err
		}
		return ctrl.Result{Requeue: true}, nil
	}

	// 6. æ›´æ–°MemcachedçŠ¶æ€
	podList := &corev1.PodList{}
	listOpts := []client.ListOption{
		client.InNamespace(memcached.Namespace),
		client.MatchingLabels(labelsForMemcached(memcached.Name)),
	}
	if err = r.List(ctx, podList, listOpts...); err != nil {
		log.Error(err, "Failed to list pods", "Memcached.Namespace", memcached.Namespace, "Memcached.Name", memcached.Name)
		return ctrl.Result{}, err
	}
	podNames := getPodNames(podList.Items)

	// æ›´æ–°status.Nodes
	if !reflect.DeepEqual(podNames, memcached.Status.Nodes) {
		memcached.Status.Nodes = podNames
		err := r.Status().Update(ctx, memcached)
		if err != nil {
			log.Error(err, "Failed to update Memcached status")
			return ctrl.Result{}, err
		}
	}

	// æ›´æ–°Conditions
	if len(podNames) == int(size) {
		meta.SetStatusCondition(&memcached.Status.Conditions, metav1.Condition{
			Type:    "Ready",
			Status:  metav1.ConditionTrue,
			Reason:  "AllPodsReady",
			Message: fmt.Sprintf("All %d pods are ready", size),
		})
	} else {
		meta.SetStatusCondition(&memcached.Status.Conditions, metav1.Condition{
			Type:    "Ready",
			Status:  metav1.ConditionFalse,
			Reason:  "PodsNotReady",
			Message: fmt.Sprintf("Only %d/%d pods are ready", len(podNames), size),
		})
	}

	err = r.Status().Update(ctx, memcached)
	if err != nil {
		log.Error(err, "Failed to update Memcached status")
		return ctrl.Result{}, err
	}

	return ctrl.Result{}, nil
}

// deploymentForMemcached returns a memcached Deployment object
func (r *MemcachedReconciler) deploymentForMemcached(m *cachev1alpha1.Memcached) *appsv1.Deployment {
	ls := labelsForMemcached(m.Name)
	replicas := m.Spec.Size

	dep := &appsv1.Deployment{
		ObjectMeta: metav1.ObjectMeta{
			Name:      m.Name,
			Namespace: m.Namespace,
		},
		Spec: appsv1.DeploymentSpec{
			Replicas: &replicas,
			Selector: &metav1.LabelSelector{
				MatchLabels: ls,
			},
			Template: corev1.PodTemplateSpec{
				ObjectMeta: metav1.ObjectMeta{
					Labels: ls,
				},
				Spec: corev1.PodSpec{
					Containers: []corev1.Container{{
						Image:   m.Spec.Image,
						Name:    "memcached",
						Command: []string{"memcached", "-m=" + m.Spec.Memory, "-o", "modern", "-v"},
						Ports: []corev1.ContainerPort{{
							ContainerPort: 11211,
							Name:          "memcached",
						}},
						Resources: corev1.ResourceRequirements{
							Limits: corev1.ResourceList{
								corev1.ResourceMemory: resource.MustParse(m.Spec.Memory),
							},
							Requests: corev1.ResourceList{
								corev1.ResourceMemory: resource.MustParse(m.Spec.Memory),
							},
						},
					}},
				},
			},
		},
	}
	// è®¾ç½®OwnerReference
	controllerutil.SetControllerReference(m, dep, r.Scheme)
	return dep
}

// labelsForMemcached returns the labels for selecting the resources
func labelsForMemcached(name string) map[string]string {
	return map[string]string{"app": "memcached", "memcached_cr": name}
}

// getPodNames returns the pod names of the array of pods passed in
func getPodNames(pods []corev1.Pod) []string {
	var podNames []string
	for _, pod := range pods {
		podNames = append(podNames, pod.Name)
	}
	return podNames
}

// finalizeMemcached will perform the required operations before delete the CR.
func (r *MemcachedReconciler) finalizeMemcached(log logr.Logger, m *cachev1alpha1.Memcached) error {
	// TODO: æ·»åŠ æ¸…ç†é€»è¾‘
	log.Info("Successfully finalized memcached")
	return nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *MemcachedReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&cachev1alpha1.Memcached{}).
		Owns(&appsv1.Deployment{}).
		Complete(r)
}
```

**æ­¥éª¤5ï¼šæµ‹è¯•å’Œéƒ¨ç½²**

```bash
# ç”Ÿæˆä»£ç å’Œmanifests
make generate
make manifests

# å®‰è£…CRD
make install

# æœ¬åœ°è¿è¡Œ
make run

# åœ¨å¦ä¸€ä¸ªç»ˆç«¯åˆ›å»ºCR
kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml

# æŸ¥çœ‹èµ„æº
kubectl get memcached
kubectl get deployment
kubectl get pods

# æ„å»ºå’Œéƒ¨ç½²
make docker-build docker-push IMG=your-registry/memcached-operator:v0.1.0
make deploy IMG=your-registry/memcached-operator:v0.1.0
```

### 13.4.4 Ansible Operatorå¼€å‘

Ansible Operatorå…è®¸ä½¿ç”¨Ansible Playbookæ¥ç®¡ç†Kubernetesèµ„æºï¼Œæ— éœ€ç¼–å†™Goä»£ç ã€‚

**æ­¥éª¤1ï¼šåˆå§‹åŒ–Ansible Operatoré¡¹ç›®**

```bash
# åˆ›å»ºé¡¹ç›®ç›®å½•
mkdir nginx-operator
cd nginx-operator

# åˆå§‹åŒ–Ansible Operatoré¡¹ç›®
operator-sdk init   --plugins=ansible   --domain example.com

# åˆ›å»ºAPI
operator-sdk create api   --group webapp   --version v1   --kind Nginx   --generate-role

# ç”Ÿæˆçš„æ–‡ä»¶ç»“æ„ï¼š
# nginx-operator/
# â”œâ”€â”€ config/
# â”œâ”€â”€ roles/
# â”‚   â””â”€â”€ nginx/
# â”‚       â”œâ”€â”€ tasks/
# â”‚       â”‚   â””â”€â”€ main.yml
# â”‚       â”œâ”€â”€ defaults/
# â”‚       â”‚   â””â”€â”€ main.yml
# â”‚       â””â”€â”€ templates/
# â”œâ”€â”€ watches.yaml
# â”œâ”€â”€ requirements.yml
# â””â”€â”€ playbook.yml
```

**æ­¥éª¤2ï¼šå®šä¹‰CRD**

ç¼–è¾‘ `config/samples/webapp_v1_nginx.yaml`ï¼š

```yaml
apiVersion: webapp.example.com/v1
kind: Nginx
metadata:
  name: nginx-sample
spec:
  # Nginxå‰¯æœ¬æ•°
  replicas: 3
  
  # Nginxé•œåƒ
  image: nginx:1.21
  
  # Serviceç±»å‹
  serviceType: ClusterIP
  
  # ç«¯å£
  port: 80
```

**æ­¥éª¤3ï¼šç¼–å†™Ansible Role**

ç¼–è¾‘ `roles/nginx/tasks/main.yml`ï¼š

```yaml
---
# tasks file for Nginx

- name: Create Nginx Deployment
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: "{{ ansible_operator_meta.name }}-deployment"
        namespace: "{{ ansible_operator_meta.namespace }}"
        labels:
          app: nginx
          nginx_cr: "{{ ansible_operator_meta.name }}"
      spec:
        replicas: "{{ replicas }}"
        selector:
          matchLabels:
            app: nginx
            nginx_cr: "{{ ansible_operator_meta.name }}"
        template:
          metadata:
            labels:
              app: nginx
              nginx_cr: "{{ ansible_operator_meta.name }}"
          spec:
            containers:
            - name: nginx
              image: "{{ image }}"
              ports:
              - containerPort: "{{ port }}"
                name: http

- name: Create Nginx Service
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: Service
      metadata:
        name: "{{ ansible_operator_meta.name }}-service"
        namespace: "{{ ansible_operator_meta.namespace }}"
        labels:
          app: nginx
          nginx_cr: "{{ ansible_operator_meta.name }}"
      spec:
        type: "{{ service_type }}"
        selector:
          app: nginx
          nginx_cr: "{{ ansible_operator_meta.name }}"
        ports:
        - port: "{{ port }}"
          targetPort: http
          protocol: TCP
          name: http

- name: Get Deployment status
  kubernetes.core.k8s_info:
    api_version: apps/v1
    kind: Deployment
    name: "{{ ansible_operator_meta.name }}-deployment"
    namespace: "{{ ansible_operator_meta.namespace }}"
  register: deployment

- name: Update CR status
  operator_sdk.util.k8s_status:
    api_version: webapp.example.com/v1
    kind: Nginx
    name: "{{ ansible_operator_meta.name }}"
    namespace: "{{ ansible_operator_meta.namespace }}"
    status:
      replicas: "{{ deployment.resources[0].status.replicas | default(0) }}"
      readyReplicas: "{{ deployment.resources[0].status.readyReplicas | default(0) }}"
      phase: "{% if deployment.resources[0].status.readyReplicas == replicas %}Running{% else %}Pending{% endif %}"
```

**æ­¥éª¤4ï¼šé…ç½®é»˜è®¤å€¼**

ç¼–è¾‘ `roles/nginx/defaults/main.yml`ï¼š

```yaml
---
# defaults file for Nginx
replicas: 1
image: nginx:1.21
service_type: ClusterIP
port: 80
```

**æ­¥éª¤5ï¼šé…ç½®Watches**

ç¼–è¾‘ `watches.yaml`ï¼š

```yaml
---
# Use the 'create api' subcommand to add watches to this file.
- version: v1
  group: webapp.example.com
  kind: Nginx
  role: nginx
  # åè°ƒé—´éš”ï¼ˆç§’ï¼‰
  reconcilePeriod: 30s
  # æœ€å¤§å¹¶å‘åè°ƒæ•°
  maxConcurrentReconciles: 1
```

**æ­¥éª¤6ï¼šæµ‹è¯•å’Œéƒ¨ç½²**

```bash
# å®‰è£…Ansibleä¾èµ–
pip3 install ansible kubernetes

# å®‰è£…Ansible collections
ansible-galaxy collection install -r requirements.yml

# å®‰è£…CRD
make install

# æœ¬åœ°è¿è¡Œ
make run

# åœ¨å¦ä¸€ä¸ªç»ˆç«¯åˆ›å»ºCR
kubectl apply -f config/samples/webapp_v1_nginx.yaml

# æŸ¥çœ‹èµ„æº
kubectl get nginx
kubectl get deployment
kubectl get service

# æ„å»ºå’Œéƒ¨ç½²
make docker-build docker-push IMG=your-registry/nginx-operator:v0.1.0
make deploy IMG=your-registry/nginx-operator:v0.1.0
```

### 13.4.5 Helm Operatorå¼€å‘

Helm OperatoråŸºäºHelm Chartï¼Œæ˜¯æœ€å¿«é€Ÿçš„Operatorå¼€å‘æ–¹å¼ã€‚

**æ­¥éª¤1ï¼šåˆå§‹åŒ–Helm Operatoré¡¹ç›®**

```bash
# åˆ›å»ºé¡¹ç›®ç›®å½•
mkdir redis-operator
cd redis-operator

# åˆå§‹åŒ–Helm Operatoré¡¹ç›®
operator-sdk init   --plugins=helm   --domain example.com

# ä½¿ç”¨ç°æœ‰Helm Chartåˆ›å»ºAPI
operator-sdk create api   --group cache   --version v1   --kind Redis   --helm-chart=bitnami/redis

# æˆ–è€…ä½¿ç”¨æœ¬åœ°Chart
# operator-sdk create api #   --group cache #   --version v1 #   --kind Redis #   --helm-chart=./redis-chart
```

**æ­¥éª¤2ï¼šè‡ªå®šä¹‰Helm Chart**

å¦‚æœéœ€è¦è‡ªå®šä¹‰Chartï¼Œç¼–è¾‘ `helm-charts/redis/values.yaml`ï¼š

```yaml
# Default values for redis.
replicaCount: 1

image:
  repository: redis
  pullPolicy: IfNotPresent
  tag: "7.0-alpine"

service:
  type: ClusterIP
  port: 6379

resources:
  limits:
    cpu: 100m
    memory: 128Mi
  requests:
    cpu: 100m
    memory: 128Mi

persistence:
  enabled: true
  storageClass: ""
  size: 8Gi
```

**æ­¥éª¤3ï¼šé…ç½®Watches**

ç¼–è¾‘ `watches.yaml`ï¼š

```yaml
---
# Use the 'create api' subcommand to add watches to this file.
- group: cache.example.com
  version: v1
  kind: Redis
  chart: helm-charts/redis
  # è¦†ç›–values
  overrideValues:
    replicaCount: "{{ .Spec.replicas | default 1 }}"
    image.tag: "{{ .Spec.version | default "7.0-alpine" }}"
    persistence.size: "{{ .Spec.storage | default "8Gi" }}"
```

**æ­¥éª¤4ï¼šåˆ›å»ºCRç¤ºä¾‹**

ç¼–è¾‘ `config/samples/cache_v1_redis.yaml`ï¼š

```yaml
apiVersion: cache.example.com/v1
kind: Redis
metadata:
  name: redis-sample
spec:
  # è¿™äº›å­—æ®µä¼šè¦†ç›–Helm Chartçš„values
  replicas: 3
  version: "7.0-alpine"
  storage: "10Gi"
```

**æ­¥éª¤5ï¼šæµ‹è¯•å’Œéƒ¨ç½²**

```bash
# å®‰è£…CRD
make install

# æœ¬åœ°è¿è¡Œ
make run

# åœ¨å¦ä¸€ä¸ªç»ˆç«¯åˆ›å»ºCR
kubectl apply -f config/samples/cache_v1_redis.yaml

# æŸ¥çœ‹èµ„æº
kubectl get redis
kubectl get all -l app.kubernetes.io/instance=redis-sample

# æ„å»ºå’Œéƒ¨ç½²
make docker-build docker-push IMG=your-registry/redis-operator:v0.1.0
make deploy IMG=your-registry/redis-operator:v0.1.0
```

### 13.4.6 ä¸‰ç§æ–¹å¼å¯¹æ¯”æ€»ç»“

**é€‰æ‹©å»ºè®®**ï¼š

```
é€‰æ‹©Operatorå¼€å‘æ–¹å¼ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Go Operator                               â”‚
â”‚  âœ… é€‚åˆï¼šå¤æ‚ä¸šåŠ¡é€»è¾‘ã€é«˜æ€§èƒ½è¦æ±‚          â”‚
â”‚  âœ… ä¼˜åŠ¿ï¼šå®Œå…¨æ§åˆ¶ã€æœ€çµæ´»                  â”‚
â”‚  âŒ åŠ£åŠ¿ï¼šéœ€è¦Goè¯­è¨€çŸ¥è¯†ã€å¼€å‘å‘¨æœŸé•¿        â”‚
â”‚  ğŸ“Š æ¨èåœºæ™¯ï¼š                             â”‚
â”‚     - æ•°æ®åº“Operatorï¼ˆMySQLã€PostgreSQLï¼‰  â”‚
â”‚     - æœ‰çŠ¶æ€åº”ç”¨                           â”‚
â”‚     - éœ€è¦å¤æ‚åè°ƒé€»è¾‘                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Ansible Operator                          â”‚
â”‚  âœ… é€‚åˆï¼šè¿ç»´äººå‘˜ã€å·²æœ‰Ansibleç»éªŒ         â”‚
â”‚  âœ… ä¼˜åŠ¿ï¼šæ— éœ€ç¼–ç¨‹ã€å¿«é€Ÿå¼€å‘                â”‚
â”‚  âŒ åŠ£åŠ¿ï¼šæ€§èƒ½è¾ƒä½ã€è°ƒè¯•å›°éš¾                â”‚
â”‚  ğŸ“Š æ¨èåœºæ™¯ï¼š                             â”‚
â”‚     - ç®€å•çš„åº”ç”¨éƒ¨ç½²                       â”‚
â”‚     - é…ç½®ç®¡ç†                             â”‚
â”‚     - è¿ç»´è‡ªåŠ¨åŒ–                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Helm Operator                             â”‚
â”‚  âœ… é€‚åˆï¼šå·²æœ‰Helm Chartã€å¿«é€ŸåŸå‹          â”‚
â”‚  âœ… ä¼˜åŠ¿ï¼šæœ€å¿«é€Ÿã€åˆ©ç”¨ç°æœ‰Chart             â”‚
â”‚  âŒ åŠ£åŠ¿ï¼šåŠŸèƒ½æœ‰é™ã€éš¾ä»¥æ‰©å±•                â”‚
â”‚  ğŸ“Š æ¨èåœºæ™¯ï¼š                             â”‚
â”‚     - ç®€å•åº”ç”¨éƒ¨ç½²                         â”‚
â”‚     - Helm ChartåŒ…è£…                       â”‚
â”‚     - å¿«é€ŸéªŒè¯æƒ³æ³•                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ€§èƒ½å¯¹æ¯”**ï¼š

| æŒ‡æ ‡ | Go Operator | Ansible Operator | Helm Operator |
|------|------------|------------------|---------------|
| **å¯åŠ¨æ—¶é—´** | å¿« | ä¸­ç­‰ | å¿« |
| **åè°ƒé€Ÿåº¦** | æœ€å¿« | æ…¢ | ä¸­ç­‰ |
| **å†…å­˜å ç”¨** | ä½ | é«˜ | ä¸­ç­‰ |
| **CPUå ç”¨** | ä½ | é«˜ | ä¸­ç­‰ |
| **å¹¶å‘èƒ½åŠ›** | é«˜ | ä½ | ä¸­ç­‰ |

**å¼€å‘å¤æ‚åº¦å¯¹æ¯”**ï¼š

| é˜¶æ®µ | Go Operator | Ansible Operator | Helm Operator |
|------|------------|------------------|---------------|
| **å­¦ä¹ æ›²çº¿** | é™¡å³­ | å¹³ç¼“ | å¹³ç¼“ |
| **å¼€å‘æ—¶é—´** | é•¿ | ä¸­ç­‰ | çŸ­ |
| **è°ƒè¯•éš¾åº¦** | ä¸­ç­‰ | å›°éš¾ | ç®€å• |
| **ç»´æŠ¤æˆæœ¬** | ä¸­ç­‰ | é«˜ | ä½ |

---

**å½“å‰ç¬¬13ç« è¿›åº¦**ï¼š
- âœ… 13.1 CRDæ·±å…¥ç†è§£ï¼ˆå®Œæˆï¼‰
- âœ… 13.2 Operatoræ¨¡å¼ä¸åŸç†ï¼ˆå®Œæˆï¼‰
- âœ… 13.3 ä½¿ç”¨Kubebuilderå¼€å‘Operatorï¼ˆå®Œæˆï¼‰
- âœ… 13.4 ä½¿ç”¨Operator SDKå¼€å‘Operatorï¼ˆå®Œæˆï¼‰
- â³ 13.5 Operatoræœ€ä½³å®è·µï¼ˆå¾…ç¼–å†™ï¼‰
- ğŸ“… 13.6 å®æˆ˜ï¼šå¼€å‘MySQL Operatorï¼ˆå¾…ç¼–å†™ï¼‰

æ¥ä¸‹æ¥å°†ç»§ç»­ç¼–å†™13.5å’Œ13.6èŠ‚çš„å†…å®¹ã€‚


## 13.5 Operatoræœ€ä½³å®è·µ

### 13.5.1 é”™è¯¯å¤„ç†ä¸é‡è¯•

**1. é”™è¯¯åˆ†ç±»**

```go
// å®šä¹‰é”™è¯¯ç±»å‹
type ReconcileError struct {
	Reason  string
	Message string
	Retry   bool  // æ˜¯å¦éœ€è¦é‡è¯•
}

func (e *ReconcileError) Error() string {
	return fmt.Sprintf("%s: %s", e.Reason, e.Message)
}

// å¯é‡è¯•é”™è¯¯
func NewRetryableError(reason, message string) error {
	return &ReconcileError{
		Reason:  reason,
		Message: message,
		Retry:   true,
	}
}

// ä¸å¯é‡è¯•é”™è¯¯
func NewNonRetryableError(reason, message string) error {
	return &ReconcileError{
		Reason:  reason,
		Message: message,
		Retry:   false,
	}
}
```

**2. é‡è¯•ç­–ç•¥**

```go
func (r *MyReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// ... è·å–èµ„æº ...

	// æ‰§è¡Œåè°ƒé€»è¾‘
	err := r.reconcileResource(ctx, myResource)
	if err != nil {
		// åˆ¤æ–­é”™è¯¯ç±»å‹
		if reconcileErr, ok := err.(*ReconcileError); ok {
			if reconcileErr.Retry {
				// å¯é‡è¯•é”™è¯¯ï¼Œä½¿ç”¨æŒ‡æ•°é€€é¿
				return ctrl.Result{
					Requeue:      true,
					RequeueAfter: time.Second * 30,
				}, nil
			} else {
				// ä¸å¯é‡è¯•é”™è¯¯ï¼Œè®°å½•æ—¥å¿—å¹¶æ›´æ–°çŠ¶æ€
				log.Error(err, "Non-retryable error occurred")
				r.updateErrorStatus(ctx, myResource, err)
				return ctrl.Result{}, nil
			}
		}
		
		// æœªçŸ¥é”™è¯¯ï¼Œé»˜è®¤é‡è¯•
		return ctrl.Result{}, err
	}

	return ctrl.Result{}, nil
}
```

**3. æŒ‡æ•°é€€é¿é‡è¯•**

```go
import (
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/client-go/util/retry"
)

func (r *MyReconciler) retryWithBackoff(ctx context.Context, fn func() error) error {
	backoff := wait.Backoff{
		Steps:    5,
		Duration: 10 * time.Millisecond,
		Factor:   2.0,
		Jitter:   0.1,
	}

	return retry.OnError(backoff, func(err error) bool {
		// åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•
		return isRetryableError(err)
	}, fn)
}
```

### 13.5.2 èµ„æºæ¸…ç†ä¸Finalizer

**1. æ·»åŠ Finalizer**

```go
const myFinalizer = "myoperator.example.com/finalizer"

func (r *MyReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	myResource := &myv1.MyResource{}
	err := r.Get(ctx, req.NamespacedName, myResource)
	if err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	// æ£€æŸ¥æ˜¯å¦æ­£åœ¨åˆ é™¤
	if myResource.ObjectMeta.DeletionTimestamp.IsZero() {
		// èµ„æºæœªè¢«åˆ é™¤ï¼Œæ·»åŠ finalizer
		if !controllerutil.ContainsFinalizer(myResource, myFinalizer) {
			controllerutil.AddFinalizer(myResource, myFinalizer)
			if err := r.Update(ctx, myResource); err != nil {
				return ctrl.Result{}, err
			}
		}
	} else {
		// èµ„æºæ­£åœ¨åˆ é™¤ï¼Œæ‰§è¡Œæ¸…ç†é€»è¾‘
		if controllerutil.ContainsFinalizer(myResource, myFinalizer) {
			// æ‰§è¡Œæ¸…ç†
			if err := r.finalizeMyResource(ctx, myResource); err != nil {
				return ctrl.Result{}, err
			}

			// ç§»é™¤finalizer
			controllerutil.RemoveFinalizer(myResource, myFinalizer)
			if err := r.Update(ctx, myResource); err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{}, nil
	}

	// æ­£å¸¸åè°ƒé€»è¾‘
	// ...

	return ctrl.Result{}, nil
}
```

**2. æ¸…ç†é€»è¾‘å®ç°**

```go
func (r *MyReconciler) finalizeMyResource(ctx context.Context, resource *myv1.MyResource) error {
	log := log.FromContext(ctx)
	log.Info("Finalizing MyResource", "name", resource.Name)

	// 1. æ¸…ç†å¤–éƒ¨èµ„æºï¼ˆå¦‚äº‘æœåŠ¡ã€æ•°æ®åº“ç­‰ï¼‰
	if err := r.cleanupExternalResources(ctx, resource); err != nil {
		return fmt.Errorf("failed to cleanup external resources: %w", err)
	}

	// 2. æ¸…ç†å…³è”çš„Kubernetesèµ„æº
	// æ³¨æ„ï¼šé€šè¿‡OwnerReferenceå…³è”çš„èµ„æºä¼šè‡ªåŠ¨åˆ é™¤
	// è¿™é‡Œåªéœ€è¦æ¸…ç†æ²¡æœ‰OwnerReferenceçš„èµ„æº
	if err := r.cleanupOrphanedResources(ctx, resource); err != nil {
		return fmt.Errorf("failed to cleanup orphaned resources: %w", err)
	}

	// 3. è®°å½•æ¸…ç†äº‹ä»¶
	r.Recorder.Event(resource, corev1.EventTypeNormal, "Finalized", "Successfully finalized MyResource")

	log.Info("Successfully finalized MyResource", "name", resource.Name)
	return nil
}

func (r *MyReconciler) cleanupExternalResources(ctx context.Context, resource *myv1.MyResource) error {
	// ç¤ºä¾‹ï¼šåˆ é™¤äº‘å­˜å‚¨æ¡¶
	// if resource.Spec.StorageBucket != "" {
	//     return r.CloudProvider.DeleteBucket(resource.Spec.StorageBucket)
	// }
	return nil
}

func (r *MyReconciler) cleanupOrphanedResources(ctx context.Context, resource *myv1.MyResource) error {
	// ç¤ºä¾‹ï¼šåˆ é™¤æ²¡æœ‰OwnerReferenceçš„ConfigMap
	configMap := &corev1.ConfigMap{}
	err := r.Get(ctx, types.NamespacedName{
		Name:      resource.Name + "-config",
		Namespace: resource.Namespace,
	}, configMap)
	
	if err == nil {
		return r.Delete(ctx, configMap)
	}
	
	return client.IgnoreNotFound(err)
}
```

### 13.5.3 æ€§èƒ½ä¼˜åŒ–

**1. ä½¿ç”¨ç¼“å­˜å‡å°‘APIè°ƒç”¨**

```go
import (
	"sigs.k8s.io/controller-runtime/pkg/cache"
)

func (r *MyReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&myv1.MyResource{}).
		Owns(&appsv1.Deployment{}).
		// é…ç½®ç¼“å­˜
		WithOptions(controller.Options{
			MaxConcurrentReconciles: 3,  // å¹¶å‘åè°ƒæ•°
		}).
		Complete(r)
}

// ä½¿ç”¨ç¼“å­˜è¯»å–
func (r *MyReconciler) getDeployment(ctx context.Context, name, namespace string) (*appsv1.Deployment, error) {
	deployment := &appsv1.Deployment{}
	// ä»ç¼“å­˜è¯»å–ï¼Œä¸ç›´æ¥è®¿é—®API Server
	err := r.Get(ctx, types.NamespacedName{
		Name:      name,
		Namespace: namespace,
	}, deployment)
	return deployment, err
}
```

**2. æ‰¹é‡æ“ä½œ**

```go
func (r *MyReconciler) reconcileMultipleResources(ctx context.Context, resources []myv1.MyResource) error {
	// æ‰¹é‡è·å–Deployment
	deploymentList := &appsv1.DeploymentList{}
	err := r.List(ctx, deploymentList, client.InNamespace("default"))
	if err != nil {
		return err
	}

	// åˆ›å»ºDeploymentæ˜ å°„
	deploymentMap := make(map[string]*appsv1.Deployment)
	for i := range deploymentList.Items {
		dep := &deploymentList.Items[i]
		deploymentMap[dep.Name] = dep
	}

	// æ‰¹é‡å¤„ç†
	for _, resource := range resources {
		if dep, exists := deploymentMap[resource.Name]; exists {
			// å¤„ç†å·²å­˜åœ¨çš„Deployment
			r.updateDeployment(ctx, &resource, dep)
		} else {
			// åˆ›å»ºæ–°çš„Deployment
			r.createDeployment(ctx, &resource)
		}
	}

	return nil
}
```

**3. é™æµå’Œå¹¶å‘æ§åˆ¶**

```go
import (
	"golang.org/x/time/rate"
	"k8s.io/client-go/util/workqueue"
)

func (r *MyReconciler) SetupWithManager(mgr ctrl.Manager) error {
	// é…ç½®é™æµå™¨
	rateLimiter := workqueue.NewMaxOfRateLimiter(
		workqueue.NewItemExponentialFailureRateLimiter(5*time.Millisecond, 1000*time.Second),
		&workqueue.BucketRateLimiter{Limiter: rate.NewLimiter(rate.Limit(10), 100)},
	)

	return ctrl.NewControllerManagedBy(mgr).
		For(&myv1.MyResource{}).
		WithOptions(controller.Options{
			MaxConcurrentReconciles: 5,  // æœ€å¤§å¹¶å‘æ•°
			RateLimiter:            rateLimiter,
		}).
		Complete(r)
}
```

### 13.5.4 å®‰å…¨åŠ å›º

**1. RBACæœ€å°æƒé™**

```go
// +kubebuilder:rbac:groups=mygroup.example.com,resources=myresources,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=mygroup.example.com,resources=myresources/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=mygroup.example.com,resources=myresources/finalizers,verbs=update
// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=events,verbs=create;patch

// ä¸è¦ä½¿ç”¨é€šé…ç¬¦
// âŒ +kubebuilder:rbac:groups=*,resources=*,verbs=*
```

**2. è¾“å…¥éªŒè¯**

```go
// ä½¿ç”¨WebhookéªŒè¯
func (r *MyResource) ValidateCreate() error {
	// éªŒè¯å¿…å¡«å­—æ®µ
	if r.Spec.Name == "" {
		return fmt.Errorf("spec.name is required")
	}

	// éªŒè¯æ ¼å¼
	if !isValidName(r.Spec.Name) {
		return fmt.Errorf("spec.name must match pattern ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$")
	}

	// éªŒè¯èŒƒå›´
	if r.Spec.Replicas < 1 || r.Spec.Replicas > 100 {
		return fmt.Errorf("spec.replicas must be between 1 and 100")
	}

	return nil
}

func (r *MyResource) ValidateUpdate(old runtime.Object) error {
	oldResource := old.(*MyResource)

	// éªŒè¯ä¸å¯å˜å­—æ®µ
	if r.Spec.Name != oldResource.Spec.Name {
		return fmt.Errorf("spec.name is immutable")
	}

	return r.ValidateCreate()
}
```

**3. æ•æ„Ÿä¿¡æ¯å¤„ç†**

```go
func (r *MyReconciler) handleSecrets(ctx context.Context, resource *myv1.MyResource) error {
	// ä»Secretè¯»å–æ•æ„Ÿä¿¡æ¯
	secret := &corev1.Secret{}
	err := r.Get(ctx, types.NamespacedName{
		Name:      resource.Spec.SecretName,
		Namespace: resource.Namespace,
	}, secret)
	if err != nil {
		return err
	}

	// ä¸è¦åœ¨æ—¥å¿—ä¸­æ‰“å°æ•æ„Ÿä¿¡æ¯
	// âŒ log.Info("Password", "password", string(secret.Data["password"]))
	// âœ… log.Info("Using secret", "secretName", secret.Name)

	// ä¸è¦åœ¨Statusä¸­å­˜å‚¨æ•æ„Ÿä¿¡æ¯
	// âŒ resource.Status.Password = string(secret.Data["password"])

	return nil
}
```

### 13.5.5 å¯è§‚æµ‹æ€§

**1. æ—¥å¿—è®°å½•**

```go
import (
	"github.com/go-logr/logr"
	ctrl "sigs.k8s.io/controller-runtime"
)

func (r *MyReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)

	// ç»“æ„åŒ–æ—¥å¿—
	log.Info("Reconciling MyResource",
		"namespace", req.Namespace,
		"name", req.Name,
	)

	// ä¸åŒçº§åˆ«çš„æ—¥å¿—
	log.V(1).Info("Debug information", "detail", "some detail")  // Debug
	log.Info("Normal operation")                                  // Info
	log.Error(err, "Failed to reconcile", "reason", "some reason") // Error

	// ä½¿ç”¨WithValuesæ·»åŠ ä¸Šä¸‹æ–‡
	log = log.WithValues("resourceVersion", myResource.ResourceVersion)
	log.Info("Processing resource")

	return ctrl.Result{}, nil
}
```

**2. MetricsæŒ‡æ ‡**

```go
import (
	"github.com/prometheus/client_golang/prometheus"
	"sigs.k8s.io/controller-runtime/pkg/metrics"
)

var (
	reconcileTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "myoperator_reconcile_total",
			Help: "Total number of reconciliations",
		},
		[]string{"namespace", "name", "result"},
	)

	reconcileDuration = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "myoperator_reconcile_duration_seconds",
			Help:    "Duration of reconciliations",
			Buckets: prometheus.DefBuckets,
		},
		[]string{"namespace", "name"},
	)

	resourceCount = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "myoperator_resource_count",
			Help: "Number of MyResource instances",
		},
		[]string{"namespace", "phase"},
	)
)

func init() {
	// æ³¨å†Œmetrics
	metrics.Registry.MustRegister(
		reconcileTotal,
		reconcileDuration,
		resourceCount,
	)
}

func (r *MyReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	start := time.Now()
	defer func() {
		duration := time.Since(start).Seconds()
		reconcileDuration.WithLabelValues(req.Namespace, req.Name).Observe(duration)
	}()

	// ... åè°ƒé€»è¾‘ ...

	// è®°å½•ç»“æœ
	reconcileTotal.WithLabelValues(req.Namespace, req.Name, "success").Inc()

	// æ›´æ–°èµ„æºè®¡æ•°
	resourceCount.WithLabelValues(req.Namespace, myResource.Status.Phase).Set(1)

	return ctrl.Result{}, nil
}
```

**3. Eventsäº‹ä»¶**

```go
import (
	"k8s.io/client-go/tools/record"
)

type MyReconciler struct {
	client.Client
	Scheme   *runtime.Scheme
	Recorder record.EventRecorder  // æ·»åŠ äº‹ä»¶è®°å½•å™¨
}

func (r *MyReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// ... è·å–èµ„æº ...

	// è®°å½•æ­£å¸¸äº‹ä»¶
	r.Recorder.Event(myResource, corev1.EventTypeNormal, "Created", "Successfully created Deployment")

	// è®°å½•è­¦å‘Šäº‹ä»¶
	r.Recorder.Event(myResource, corev1.EventTypeWarning, "Failed", "Failed to create Service")

	// è®°å½•å¸¦åŸå› çš„äº‹ä»¶
	r.Recorder.Eventf(myResource, corev1.EventTypeNormal, "Scaled", "Scaled from %d to %d replicas", oldReplicas, newReplicas)

	return ctrl.Result{}, nil
}

// åœ¨main.goä¸­é…ç½®EventRecorder
func main() {
	// ...
	if err = (&controllers.MyReconciler{
		Client:   mgr.GetClient(),
		Scheme:   mgr.GetScheme(),
		Recorder: mgr.GetEventRecorderFor("myoperator-controller"),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "MyResource")
		os.Exit(1)
	}
	// ...
}
```

### 13.5.6 æµ‹è¯•ç­–ç•¥

**1. å•å…ƒæµ‹è¯•**

```go
import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("MyResource Controller", func() {
	Context("When reconciling a resource", func() {
		const resourceName = "test-resource"

		ctx := context.Background()

		typeNamespacedName := types.NamespacedName{
			Name:      resourceName,
			Namespace: "default",
		}
		myresource := &myv1.MyResource{}

		BeforeEach(func() {
			By("creating the custom resource for the Kind MyResource")
			err := k8sClient.Get(ctx, typeNamespacedName, myresource)
			if err != nil && errors.IsNotFound(err) {
				resource := &myv1.MyResource{
					ObjectMeta: metav1.ObjectMeta{
						Name:      resourceName,
						Namespace: "default",
					},
					Spec: myv1.MyResourceSpec{
						Replicas: 3,
					},
				}
				Expect(k8sClient.Create(ctx, resource)).To(Succeed())
			}
		})

		AfterEach(func() {
			resource := &myv1.MyResource{}
			err := k8sClient.Get(ctx, typeNamespacedName, resource)
			Expect(err).NotTo(HaveOccurred())

			By("Cleanup the specific resource instance MyResource")
			Expect(k8sClient.Delete(ctx, resource)).To(Succeed())
		})

		It("should successfully reconcile the resource", func() {
			By("Reconciling the created resource")
			controllerReconciler := &MyReconciler{
				Client: k8sClient,
				Scheme: k8sClient.Scheme(),
			}

			_, err := controllerReconciler.Reconcile(ctx, reconcile.Request{
				NamespacedName: typeNamespacedName,
			})
			Expect(err).NotTo(HaveOccurred())

			By("Checking if Deployment was created")
			deployment := &appsv1.Deployment{}
			Eventually(func() error {
				return k8sClient.Get(ctx, typeNamespacedName, deployment)
			}, timeout, interval).Should(Succeed())

			Expect(*deployment.Spec.Replicas).Should(Equal(int32(3)))
		})
	})
})
```

**2. é›†æˆæµ‹è¯•**

```go
// ä½¿ç”¨envtestè¿›è¡Œé›†æˆæµ‹è¯•
var _ = Describe("MyResource Integration", func() {
	It("should handle full lifecycle", func() {
		ctx := context.Background()

		// 1. åˆ›å»ºèµ„æº
		resource := &myv1.MyResource{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "test-lifecycle",
				Namespace: "default",
			},
			Spec: myv1.MyResourceSpec{
				Replicas: 2,
			},
		}
		Expect(k8sClient.Create(ctx, resource)).To(Succeed())

		// 2. ç­‰å¾…Deploymentåˆ›å»º
		deployment := &appsv1.Deployment{}
		Eventually(func() error {
			return k8sClient.Get(ctx, types.NamespacedName{
				Name:      resource.Name,
				Namespace: resource.Namespace,
			}, deployment)
		}, timeout, interval).Should(Succeed())

		// 3. æ›´æ–°èµ„æº
		resource.Spec.Replicas = 5
		Expect(k8sClient.Update(ctx, resource)).To(Succeed())

		// 4. éªŒè¯Deploymentæ›´æ–°
		Eventually(func() int32 {
			k8sClient.Get(ctx, types.NamespacedName{
				Name:      deployment.Name,
				Namespace: deployment.Namespace,
			}, deployment)
			return *deployment.Spec.Replicas
		}, timeout, interval).Should(Equal(int32(5)))

		// 5. åˆ é™¤èµ„æº
		Expect(k8sClient.Delete(ctx, resource)).To(Succeed())

		// 6. éªŒè¯Deploymentè¢«åˆ é™¤
		Eventually(func() bool {
			err := k8sClient.Get(ctx, types.NamespacedName{
				Name:      deployment.Name,
				Namespace: deployment.Namespace,
			}, deployment)
			return errors.IsNotFound(err)
		}, timeout, interval).Should(BeTrue())
	})
})
```

### 13.5.7 æ–‡æ¡£å’Œç¤ºä¾‹

**1. APIæ–‡æ¡£**

```go
// MyResourceSpec defines the desired state of MyResource
type MyResourceSpec struct {
	// Replicas is the number of desired replicas.
	// This is a pointer to distinguish between explicit zero and not specified.
	// Defaults to 1.
	// +optional
	// +kubebuilder:default=1
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:validation:Maximum=100
	Replicas *int32 `json:"replicas,omitempty"`

	// Image is the container image to use.
	// More info: https://kubernetes.io/docs/concepts/containers/images
	// +required
	// +kubebuilder:validation:Required
	Image string `json:"image"`

	// Resources describes the compute resource requirements.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	Resources corev1.ResourceRequirements `json:"resources,omitempty"`
}
```

**2. ç¤ºä¾‹CR**

```yaml
# config/samples/full-example.yaml
apiVersion: mygroup.example.com/v1
kind: MyResource
metadata:
  name: myresource-sample
  namespace: default
  labels:
    app: myapp
    environment: production
spec:
  # å‰¯æœ¬æ•°ï¼ˆ1-100ï¼‰
  replicas: 3
  
  # å®¹å™¨é•œåƒ
  image: nginx:1.21
  
  # èµ„æºé™åˆ¶
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi
  
  # è‡ªå®šä¹‰é…ç½®
  config:
    logLevel: info
    enableMetrics: true
```

**3. READMEæ–‡æ¡£**

```markdown
# MyOperator

## ç®€ä»‹

MyOperatoræ˜¯ä¸€ä¸ªKubernetes Operatorï¼Œç”¨äºç®¡ç†MyResourceèµ„æºã€‚

## åŠŸèƒ½ç‰¹æ€§

- âœ… è‡ªåŠ¨åŒ–éƒ¨ç½²å’Œç®¡ç†
- âœ… è‡ªåŠ¨æ‰©ç¼©å®¹
- âœ… æ•…éšœè‡ªåŠ¨æ¢å¤
- âœ… å¤‡ä»½å’Œæ¢å¤

## å¿«é€Ÿå¼€å§‹

### å®‰è£…

\`\`\`bash
# å®‰è£…CRD
kubectl apply -f https://raw.githubusercontent.com/example/myoperator/main/config/crd/bases/mygroup.example.com_myresources.yaml

# å®‰è£…Operator
kubectl apply -f https://raw.githubusercontent.com/example/myoperator/main/config/manager/manager.yaml
\`\`\`

### åˆ›å»ºèµ„æº

\`\`\`bash
kubectl apply -f config/samples/mygroup_v1_myresource.yaml
\`\`\`

### æŸ¥çœ‹èµ„æº

\`\`\`bash
kubectl get myresource
kubectl describe myresource myresource-sample
\`\`\`

## é…ç½®è¯´æ˜

è¯¦è§ [APIæ–‡æ¡£](docs/api.md)

## æ•…éšœæ’æŸ¥

è¯¦è§ [æ•…éšœæ’æŸ¥æŒ‡å—](docs/troubleshooting.md)

## è´¡çŒ®æŒ‡å—

è¯¦è§ [CONTRIBUTING.md](CONTRIBUTING.md)
```

---

**å½“å‰ç¬¬13ç« è¿›åº¦**ï¼š
- âœ… 13.1 CRDæ·±å…¥ç†è§£ï¼ˆå®Œæˆï¼‰
- âœ… 13.2 Operatoræ¨¡å¼ä¸åŸç†ï¼ˆå®Œæˆï¼‰
- âœ… 13.3 ä½¿ç”¨Kubebuilderå¼€å‘Operatorï¼ˆå®Œæˆï¼‰
- âœ… 13.4 ä½¿ç”¨Operator SDKå¼€å‘Operatorï¼ˆå®Œæˆï¼‰
- âœ… 13.5 Operatoræœ€ä½³å®è·µï¼ˆå®Œæˆï¼‰
- â³ 13.6 å®æˆ˜ï¼šå¼€å‘MySQL Operatorï¼ˆå¾…ç¼–å†™ï¼‰

æ¥ä¸‹æ¥å°†ç¼–å†™æœ€åä¸€èŠ‚13.6çš„å†…å®¹ã€‚


## 13.6 å®æˆ˜ï¼šå¼€å‘MySQL Operator

### 13.6.1 é¡¹ç›®éœ€æ±‚åˆ†æ

**åŠŸèƒ½éœ€æ±‚**ï¼š
- âœ… æ”¯æŒMySQLå•å®ä¾‹å’Œä¸»ä»å¤åˆ¶éƒ¨ç½²
- âœ… è‡ªåŠ¨é…ç½®ä¸»ä»å¤åˆ¶
- âœ… è‡ªåŠ¨å¤‡ä»½å’Œæ¢å¤
- âœ… æ•…éšœè‡ªåŠ¨æ£€æµ‹å’Œæ¢å¤
- âœ… åŠ¨æ€æ‰©ç¼©å®¹
- âœ… ç›‘æ§å’Œå‘Šè­¦é›†æˆ

**æŠ€æœ¯æ¶æ„**ï¼š

```
MySQL Operatoræ¶æ„ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MySQL Operator                            â”‚
â”‚  â”œâ”€ MySQL Controller                       â”‚
â”‚  â”œâ”€ Backup Controller                      â”‚
â”‚  â””â”€ Restore Controller                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MySQL CR (Custom Resource)                â”‚
â”‚  â”œâ”€ Spec: æœŸæœ›çŠ¶æ€                         â”‚
â”‚  â”‚   â”œâ”€ Mode: standalone/replication       â”‚
â”‚  â”‚   â”œâ”€ Replicas: å‰¯æœ¬æ•°                   â”‚
â”‚  â”‚   â”œâ”€ Version: MySQLç‰ˆæœ¬                 â”‚
â”‚  â”‚   â””â”€ Storage: å­˜å‚¨é…ç½®                  â”‚
â”‚  â””â”€ Status: å½“å‰çŠ¶æ€                       â”‚
â”‚      â”œâ”€ Phase: Running/Pending/Failed      â”‚
â”‚      â”œâ”€ Master: ä¸»èŠ‚ç‚¹ä¿¡æ¯                 â”‚
â”‚      â””â”€ Slaves: ä»èŠ‚ç‚¹ä¿¡æ¯                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Kubernetes Resources                      â”‚
â”‚  â”œâ”€ StatefulSet (MySQL Pods)               â”‚
â”‚  â”œâ”€ Service (Master/Slave)                 â”‚
â”‚  â”œâ”€ ConfigMap (MySQLé…ç½®)                  â”‚
â”‚  â”œâ”€ Secret (å¯†ç )                          â”‚
â”‚  â””â”€ PVC (æŒä¹…åŒ–å­˜å‚¨)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 13.6.2 é¡¹ç›®åˆå§‹åŒ–

```bash
# åˆ›å»ºé¡¹ç›®
mkdir mysql-operator
cd mysql-operator

# åˆå§‹åŒ–é¡¹ç›®
kubebuilder init   --domain example.com   --repo github.com/example/mysql-operator

# åˆ›å»ºMySQL API
kubebuilder create api   --group database   --version v1alpha1   --kind MySQL   --resource   --controller

# åˆ›å»ºBackup API
kubebuilder create api   --group database   --version v1alpha1   --kind MySQLBackup   --resource   --controller
```

### 13.6.3 å®šä¹‰API

**MySQL CRDå®šä¹‰** (`api/v1alpha1/mysql_types.go`)ï¼š

```go
package v1alpha1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// MySQLMode defines the mode of MySQL deployment
// +kubebuilder:validation:Enum=standalone;replication
type MySQLMode string

const (
	MySQLModeStandalone  MySQLMode = "standalone"
	MySQLModeReplication MySQLMode = "replication"
)

// MySQLSpec defines the desired state of MySQL
type MySQLSpec struct {
	// Mode is the deployment mode
	// +kubebuilder:default=standalone
	Mode MySQLMode `json:"mode,omitempty"`

	// Replicas is the number of MySQL instances
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:validation:Maximum=10
	// +kubebuilder:default=1
	Replicas int32 `json:"replicas,omitempty"`

	// Version is the MySQL version
	// +kubebuilder:validation:Enum="5.7";"8.0";"8.1"
	// +kubebuilder:default="8.0"
	Version string `json:"version,omitempty"`

	// Storage configuration
	Storage MySQLStorage `json:"storage"`

	// Resources configuration
	// +optional
	Resources corev1.ResourceRequirements `json:"resources,omitempty"`

	// Backup configuration
	// +optional
	Backup *MySQLBackupSpec `json:"backup,omitempty"`

	// Root password secret name
	// +optional
	RootPasswordSecret string `json:"rootPasswordSecret,omitempty"`
}

// MySQLStorage defines storage configuration
type MySQLStorage struct {
	// StorageClassName
	// +optional
	StorageClassName string `json:"storageClassName,omitempty"`

	// Size
	// +kubebuilder:validation:Pattern=`^[0-9]+Gi$`
	// +kubebuilder:default="10Gi"
	Size string `json:"size,omitempty"`
}

// MySQLBackupSpec defines backup configuration
type MySQLBackupSpec struct {
	// Schedule in Cron format
	Schedule string `json:"schedule"`

	// Retention period in days
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:default=7
	RetentionDays int32 `json:"retentionDays,omitempty"`

	// Storage location
	StorageLocation string `json:"storageLocation"`
}

// MySQLStatus defines the observed state of MySQL
type MySQLStatus struct {
	// Phase represents the current phase
	// +kubebuilder:validation:Enum=Pending;Running;Failed
	Phase string `json:"phase,omitempty"`

	// Master node information
	Master MySQLNodeStatus `json:"master,omitempty"`

	// Slave nodes information
	Slaves []MySQLNodeStatus `json:"slaves,omitempty"`

	// Conditions
	Conditions []metav1.Condition `json:"conditions,omitempty"`

	// Last backup time
	LastBackupTime *metav1.Time `json:"lastBackupTime,omitempty"`
}

// MySQLNodeStatus defines node status
type MySQLNodeStatus struct {
	// Pod name
	PodName string `json:"podName"`

	// Ready status
	Ready bool `json:"ready"`

	// Role (master/slave)
	Role string `json:"role"`

	// Replication lag (seconds)
	// +optional
	ReplicationLag *int32 `json:"replicationLag,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas
// +kubebuilder:printcolumn:name="Mode",type=string,JSONPath=`.spec.mode`
// +kubebuilder:printcolumn:name="Version",type=string,JSONPath=`.spec.version`
// +kubebuilder:printcolumn:name="Replicas",type=integer,JSONPath=`.spec.replicas`
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`

// MySQL is the Schema for the mysqls API
type MySQL struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   MySQLSpec   `json:"spec,omitempty"`
	Status MySQLStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MySQLList contains a list of MySQL
type MySQLList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MySQL `json:"items"`
}

func init() {
	SchemeBuilder.Register(&MySQL{}, &MySQLList{})
}
```

### 13.6.4 å®ç°Controller

**MySQL Controller** (`controllers/mysql_controller.go`)ï¼š

```go
package controllers

import (
	"context"
	"fmt"
	"time"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	databasev1alpha1 "github.com/example/mysql-operator/api/v1alpha1"
)

const mysqlFinalizer = "database.example.com/finalizer"

// MySQLReconciler reconciles a MySQL object
type MySQLReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=database.example.com,resources=mysqls,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=database.example.com,resources=mysqls/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=database.example.com,resources=mysqls/finalizers,verbs=update
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=configmaps,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=secrets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=persistentvolumeclaims,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;watch
// +kubebuilder:rbac:groups=core,resources=pods/exec,verbs=create

func (r *MySQLReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)

	// 1. è·å–MySQLå®ä¾‹
	mysql := &databasev1alpha1.MySQL{}
	err := r.Get(ctx, req.NamespacedName, mysql)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Info("MySQL resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		log.Error(err, "Failed to get MySQL")
		return ctrl.Result{}, err
	}

	// 2. å¤„ç†åˆ é™¤é€»è¾‘
	if mysql.ObjectMeta.DeletionTimestamp.IsZero() {
		if !controllerutil.ContainsFinalizer(mysql, mysqlFinalizer) {
			controllerutil.AddFinalizer(mysql, mysqlFinalizer)
			if err := r.Update(ctx, mysql); err != nil {
				return ctrl.Result{}, err
			}
		}
	} else {
		if controllerutil.ContainsFinalizer(mysql, mysqlFinalizer) {
			if err := r.finalizeMySQL(ctx, mysql); err != nil {
				return ctrl.Result{}, err
			}
			controllerutil.RemoveFinalizer(mysql, mysqlFinalizer)
			if err := r.Update(ctx, mysql); err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{}, nil
	}

	// 3. åè°ƒConfigMap
	if err := r.reconcileConfigMap(ctx, mysql); err != nil {
		log.Error(err, "Failed to reconcile ConfigMap")
		return ctrl.Result{}, err
	}

	// 4. åè°ƒSecret
	if err := r.reconcileSecret(ctx, mysql); err != nil {
		log.Error(err, "Failed to reconcile Secret")
		return ctrl.Result{}, err
	}

	// 5. åè°ƒService
	if err := r.reconcileServices(ctx, mysql); err != nil {
		log.Error(err, "Failed to reconcile Services")
		return ctrl.Result{}, err
	}

	// 6. åè°ƒStatefulSet
	if err := r.reconcileStatefulSet(ctx, mysql); err != nil {
		log.Error(err, "Failed to reconcile StatefulSet")
		return ctrl.Result{}, err
	}

	// 7. é…ç½®ä¸»ä»å¤åˆ¶
	if mysql.Spec.Mode == databasev1alpha1.MySQLModeReplication && mysql.Spec.Replicas > 1 {
		if err := r.configureReplication(ctx, mysql); err != nil {
			log.Error(err, "Failed to configure replication")
			return ctrl.Result{RequeueAfter: time.Second * 30}, err
		}
	}

	// 8. æ›´æ–°çŠ¶æ€
	if err := r.updateStatus(ctx, mysql); err != nil {
		log.Error(err, "Failed to update status")
		return ctrl.Result{}, err
	}

	return ctrl.Result{RequeueAfter: time.Minute}, nil
}

// reconcileConfigMap creates or updates ConfigMap
func (r *MySQLReconciler) reconcileConfigMap(ctx context.Context, mysql *databasev1alpha1.MySQL) error {
	configMap := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      mysql.Name + "-config",
			Namespace: mysql.Namespace,
		},
		Data: map[string]string{
			"my.cnf": r.generateMySQLConfig(mysql),
		},
	}

	controllerutil.SetControllerReference(mysql, configMap, r.Scheme)

	found := &corev1.ConfigMap{}
	err := r.Get(ctx, types.NamespacedName{Name: configMap.Name, Namespace: configMap.Namespace}, found)
	if err != nil && errors.IsNotFound(err) {
		return r.Create(ctx, configMap)
	} else if err != nil {
		return err
	}

	// æ›´æ–°ConfigMap
	found.Data = configMap.Data
	return r.Update(ctx, found)
}

// generateMySQLConfig generates MySQL configuration
func (r *MySQLReconciler) generateMySQLConfig(mysql *databasev1alpha1.MySQL) string {
	config := `[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
gtid-mode=ON
enforce-gtid-consistency=ON
max_connections=1000
character-set-server=utf8mb4
collation-server=utf8mb4_unicode_ci
`
	if mysql.Spec.Mode == databasev1alpha1.MySQLModeReplication {
		config += `
# Replication settings
relay-log=relay-bin
log-slave-updates=ON
read-only=OFF
`
	}
	return config
}

// reconcileSecret creates or updates Secret
func (r *MySQLReconciler) reconcileSecret(ctx context.Context, mysql *databasev1alpha1.MySQL) error {
	// å¦‚æœç”¨æˆ·æŒ‡å®šäº†Secretï¼Œåˆ™ä½¿ç”¨ç”¨æˆ·çš„Secret
	if mysql.Spec.RootPasswordSecret != "" {
		return nil
	}

	// å¦åˆ™åˆ›å»ºé»˜è®¤Secret
	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      mysql.Name + "-secret",
			Namespace: mysql.Namespace,
		},
		StringData: map[string]string{
			"root-password": r.generatePassword(),
		},
	}

	controllerutil.SetControllerReference(mysql, secret, r.Scheme)

	found := &corev1.Secret{}
	err := r.Get(ctx, types.NamespacedName{Name: secret.Name, Namespace: secret.Namespace}, found)
	if err != nil && errors.IsNotFound(err) {
		return r.Create(ctx, secret)
	}
	return err
}

// generatePassword generates a random password
func (r *MySQLReconciler) generatePassword() string {
	// ç®€åŒ–å®ç°ï¼Œç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨æ›´å®‰å…¨çš„æ–¹æ³•
	return "changeme123"
}

// reconcileServices creates or updates Services
func (r *MySQLReconciler) reconcileServices(ctx context.Context, mysql *databasev1alpha1.MySQL) error {
	// Master Service (è¯»å†™)
	masterService := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      mysql.Name + "-master",
			Namespace: mysql.Namespace,
		},
		Spec: corev1.ServiceSpec{
			Selector: map[string]string{
				"app":   "mysql",
				"mysql": mysql.Name,
			},
			Ports: []corev1.ServicePort{
				{
					Port:     3306,
					Name:     "mysql",
					Protocol: corev1.ProtocolTCP,
				},
			},
			ClusterIP: "None",  // Headless Service
		},
	}

	controllerutil.SetControllerReference(mysql, masterService, r.Scheme)

	found := &corev1.Service{}
	err := r.Get(ctx, types.NamespacedName{Name: masterService.Name, Namespace: masterService.Namespace}, found)
	if err != nil && errors.IsNotFound(err) {
		if err := r.Create(ctx, masterService); err != nil {
			return err
		}
	}

	// Slave Service (åªè¯») - ä»…åœ¨å¤åˆ¶æ¨¡å¼ä¸‹åˆ›å»º
	if mysql.Spec.Mode == databasev1alpha1.MySQLModeReplication && mysql.Spec.Replicas > 1 {
		slaveService := &corev1.Service{
			ObjectMeta: metav1.ObjectMeta{
				Name:      mysql.Name + "-slave",
				Namespace: mysql.Namespace,
			},
			Spec: corev1.ServiceSpec{
				Selector: map[string]string{
					"app":   "mysql",
					"mysql": mysql.Name,
					"role":  "slave",
				},
				Ports: []corev1.ServicePort{
					{
						Port:     3306,
						Name:     "mysql",
						Protocol: corev1.ProtocolTCP,
					},
				},
			},
		}

		controllerutil.SetControllerReference(mysql, slaveService, r.Scheme)

		found := &corev1.Service{}
		err := r.Get(ctx, types.NamespacedName{Name: slaveService.Name, Namespace: slaveService.Namespace}, found)
		if err != nil && errors.IsNotFound(err) {
			return r.Create(ctx, slaveService)
		}
	}

	return nil
}

// reconcileStatefulSet creates or updates StatefulSet
func (r *MySQLReconciler) reconcileStatefulSet(ctx context.Context, mysql *databasev1alpha1.MySQL) error {
	labels := map[string]string{
		"app":   "mysql",
		"mysql": mysql.Name,
	}

	statefulSet := &appsv1.StatefulSet{
		ObjectMeta: metav1.ObjectMeta{
			Name:      mysql.Name,
			Namespace: mysql.Namespace,
		},
		Spec: appsv1.StatefulSetSpec{
			Replicas:    &mysql.Spec.Replicas,
			ServiceName: mysql.Name + "-master",
			Selector: &metav1.LabelSelector{
				MatchLabels: labels,
			},
			Template: corev1.PodTemplateSpec{
				ObjectMeta: metav1.ObjectMeta{
					Labels: labels,
				},
				Spec: corev1.PodSpec{
					Containers: []corev1.Container{
						{
							Name:  "mysql",
							Image: fmt.Sprintf("mysql:%s", mysql.Spec.Version),
							Ports: []corev1.ContainerPort{
								{
									ContainerPort: 3306,
									Name:          "mysql",
								},
							},
							Env: []corev1.EnvVar{
								{
									Name: "MYSQL_ROOT_PASSWORD",
									ValueFrom: &corev1.EnvVarSource{
										SecretKeyRef: &corev1.SecretKeySelector{
											LocalObjectReference: corev1.LocalObjectReference{
												Name: r.getSecretName(mysql),
											},
											Key: "root-password",
										},
									},
								},
							},
							VolumeMounts: []corev1.VolumeMount{
								{
									Name:      "data",
									MountPath: "/var/lib/mysql",
								},
								{
									Name:      "config",
									MountPath: "/etc/mysql/conf.d",
								},
							},
							Resources: mysql.Spec.Resources,
						},
					},
					Volumes: []corev1.Volume{
						{
							Name: "config",
							VolumeSource: corev1.VolumeSource{
								ConfigMap: &corev1.ConfigMapVolumeSource{
									LocalObjectReference: corev1.LocalObjectReference{
										Name: mysql.Name + "-config",
									},
								},
							},
						},
					},
				},
			},
			VolumeClaimTemplates: []corev1.PersistentVolumeClaim{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name: "data",
					},
					Spec: corev1.PersistentVolumeClaimSpec{
						AccessModes: []corev1.PersistentVolumeAccessMode{
							corev1.ReadWriteOnce,
						},
						StorageClassName: &mysql.Spec.Storage.StorageClassName,
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceStorage: resource.MustParse(mysql.Spec.Storage.Size),
							},
						},
					},
				},
			},
		},
	}

	controllerutil.SetControllerReference(mysql, statefulSet, r.Scheme)

	found := &appsv1.StatefulSet{}
	err := r.Get(ctx, types.NamespacedName{Name: statefulSet.Name, Namespace: statefulSet.Namespace}, found)
	if err != nil && errors.IsNotFound(err) {
		return r.Create(ctx, statefulSet)
	} else if err != nil {
		return err
	}

	// æ›´æ–°StatefulSet
	found.Spec.Replicas = statefulSet.Spec.Replicas
	found.Spec.Template = statefulSet.Spec.Template
	return r.Update(ctx, found)
}

// configureReplication configures MySQL replication
func (r *MySQLReconciler) configureReplication(ctx context.Context, mysql *databasev1alpha1.MySQL) error {
	// ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ï¼š
	// 1. åœ¨masterä¸Šåˆ›å»ºå¤åˆ¶ç”¨æˆ·
	// 2. è·å–masterçš„binlogä½ç½®
	// 3. åœ¨slaveä¸Šé…ç½®å¤åˆ¶
	// 4. å¯åŠ¨å¤åˆ¶
	log := log.FromContext(ctx)
	log.Info("Configuring MySQL replication", "mysql", mysql.Name)
	
	// TODO: å®ç°å®Œæ•´çš„å¤åˆ¶é…ç½®é€»è¾‘
	return nil
}

// updateStatus updates MySQL status
func (r *MySQLReconciler) updateStatus(ctx context.Context, mysql *databasev1alpha1.MySQL) error {
	// è·å–StatefulSetçŠ¶æ€
	statefulSet := &appsv1.StatefulSet{}
	err := r.Get(ctx, types.NamespacedName{Name: mysql.Name, Namespace: mysql.Namespace}, statefulSet)
	if err != nil {
		return err
	}

	// æ›´æ–°Phase
	if statefulSet.Status.ReadyReplicas == mysql.Spec.Replicas {
		mysql.Status.Phase = "Running"
	} else {
		mysql.Status.Phase = "Pending"
	}

	// TODO: æ›´æ–°Masterå’ŒSlaveçŠ¶æ€

	return r.Status().Update(ctx, mysql)
}

// finalizeMySQL performs cleanup
func (r *MySQLReconciler) finalizeMySQL(ctx context.Context, mysql *databasev1alpha1.MySQL) error {
	log := log.FromContext(ctx)
	log.Info("Finalizing MySQL", "name", mysql.Name)
	
	// TODO: æ‰§è¡Œæ¸…ç†é€»è¾‘ï¼ˆå¦‚åˆ é™¤å¤‡ä»½ã€æ¸…ç†å¤–éƒ¨èµ„æºç­‰ï¼‰
	
	return nil
}

// getSecretName returns the secret name
func (r *MySQLReconciler) getSecretName(mysql *databasev1alpha1.MySQL) string {
	if mysql.Spec.RootPasswordSecret != "" {
		return mysql.Spec.RootPasswordSecret
	}
	return mysql.Name + "-secret"
}

// SetupWithManager sets up the controller with the Manager.
func (r *MySQLReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&databasev1alpha1.MySQL{}).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.Service{}).
		Owns(&corev1.ConfigMap{}).
		Owns(&corev1.Secret{}).
		Complete(r)
}
```

### 13.6.5 æµ‹è¯•å’Œéƒ¨ç½²

**åˆ›å»ºMySQLå®ä¾‹**ï¼š

```yaml
# config/samples/database_v1alpha1_mysql.yaml
apiVersion: database.example.com/v1alpha1
kind: MySQL
metadata:
  name: mysql-sample
spec:
  mode: replication
  replicas: 3
  version: "8.0"
  storage:
    storageClassName: "standard"
    size: "10Gi"
  resources:
    requests:
      cpu: "500m"
      memory: "1Gi"
    limits:
      cpu: "1000m"
      memory: "2Gi"
  backup:
    schedule: "0 2 * * *"  # æ¯å¤©å‡Œæ™¨2ç‚¹å¤‡ä»½
    retentionDays: 7
    storageLocation: "s3://my-bucket/mysql-backups"
```

**éƒ¨ç½²å’Œæµ‹è¯•**ï¼š

```bash
# 1. ç”Ÿæˆä»£ç å’Œmanifests
make generate
make manifests

# 2. å®‰è£…CRD
make install

# 3. æœ¬åœ°è¿è¡Œ
make run

# 4. åœ¨å¦ä¸€ä¸ªç»ˆç«¯åˆ›å»ºMySQLå®ä¾‹
kubectl apply -f config/samples/database_v1alpha1_mysql.yaml

# 5. æŸ¥çœ‹èµ„æº
kubectl get mysql
kubectl get statefulset
kubectl get pods
kubectl get svc

# 6. è¿æ¥MySQL
kubectl run mysql-client --rm -it --image=mysql:8.0 -- bash
mysql -h mysql-sample-master -uroot -pchangeme123

# 7. æµ‹è¯•ä¸»ä»å¤åˆ¶
# åœ¨masterä¸Šåˆ›å»ºæ•°æ®åº“
CREATE DATABASE testdb;
USE testdb;
CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(50));
INSERT INTO users VALUES (1, 'Alice');

# åœ¨slaveä¸ŠéªŒè¯
mysql -h mysql-sample-slave -uroot -pchangeme123
USE testdb;
SELECT * FROM users;

# 8. æ„å»ºå’Œéƒ¨ç½²
make docker-build docker-push IMG=your-registry/mysql-operator:v0.1.0
make deploy IMG=your-registry/mysql-operator:v0.1.0
```

### 13.6.6 æœ¬ç« æ€»ç»“

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œä½ å·²ç»æŒæ¡äº†ï¼š

**æ ¸å¿ƒçŸ¥è¯†ç‚¹**ï¼š
- âœ… CRDçš„æ·±å…¥ç†è§£å’Œä½¿ç”¨
- âœ… Operatoræ¨¡å¼çš„è®¾è®¡ç†å¿µ
- âœ… Kubebuilderå¼€å‘æ¡†æ¶
- âœ… Operator SDKçš„ä¸‰ç§å¼€å‘æ–¹å¼
- âœ… Operatoræœ€ä½³å®è·µ
- âœ… å®Œæ•´çš„MySQL Operatorå®æˆ˜

**æŠ€èƒ½æå‡**ï¼š
- âœ… èƒ½å¤Ÿè®¾è®¡å’Œå®ç°è‡ªå®šä¹‰èµ„æº
- âœ… èƒ½å¤Ÿå¼€å‘ç”Ÿäº§çº§Operator
- âœ… æŒæ¡é”™è¯¯å¤„ç†å’Œèµ„æºæ¸…ç†
- âœ… ç†è§£æ€§èƒ½ä¼˜åŒ–å’Œå®‰å…¨åŠ å›º
- âœ… å…·å¤‡å¯è§‚æµ‹æ€§å®æ–½èƒ½åŠ›

**ä¸‹ä¸€æ­¥å­¦ä¹ **ï¼š
- ç¬¬14ç« ï¼šå‡†å…¥æ§åˆ¶ä¸ç­–ç•¥ç®¡ç†
- ç¬¬15ç« ï¼šè°ƒåº¦å™¨æ‰©å±•ä¸è‡ªå®šä¹‰
- ç¬¬16ç« ï¼šå¤šé›†ç¾¤ç®¡ç†ä¸è”é‚¦

---

**è‡³æ­¤ï¼Œç¬¬13ç« ã€Šè‡ªå®šä¹‰èµ„æºä¸Operatorå¼€å‘ã€‹å…¨éƒ¨å†…å®¹å®Œæˆï¼**

æ­å–œä½ å®Œæˆäº†K8Sä¸­å·ç¬¬ä¸€ç« çš„å­¦ä¹ ï¼ä½ å·²ç»å…·å¤‡äº†æ‰©å±•Kubernetesèƒ½åŠ›çš„æ ¸å¿ƒæŠ€èƒ½ï¼Œèƒ½å¤Ÿå¼€å‘è‡ªå·±çš„Operatoræ¥è‡ªåŠ¨åŒ–ç®¡ç†å¤æ‚çš„åº”ç”¨ã€‚

**ç»§ç»­åŠ æ²¹ï¼Œäº‘åŸç”Ÿçš„ä¸–ç•Œç­‰å¾…ä½ å»æ¢ç´¢ï¼** ğŸš€
